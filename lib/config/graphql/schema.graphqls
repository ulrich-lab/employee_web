schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

type AcceptParcipateEvent {
  id: UUID!
}

input AddVisitorBrowserInputType {
  companyId: UUID!
  firstname: String!
  hostDepartment: UUID = null
  hostEmployee: UUID = null
  hostService: UUID = null
  idNumber: String!
  lastname: String!
  phoneNumber: String!
  reason: String
  regNo: String = null
  status: String!
  vehicle: UUID = null
  visitor: UUID = null
}

"""
columns and relationships of "agencies"
"""
type agencies {
  address: String
  city: String!

  """An object relationship"""
  company: companies!
  company_id: uuid!
  created_at: timestamptz

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  location: geometry
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String!

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz
}

"""
aggregated selection of "agencies"
"""
type agencies_aggregate {
  aggregate: agencies_aggregate_fields
  nodes: [agencies!]!
}

input agencies_aggregate_bool_exp {
  count: agencies_aggregate_bool_exp_count
}

input agencies_aggregate_bool_exp_count {
  arguments: [agencies_select_column!]
  distinct: Boolean
  filter: agencies_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "agencies"
"""
type agencies_aggregate_fields {
  count(columns: [agencies_select_column!], distinct: Boolean): Int!
  max: agencies_max_fields
  min: agencies_min_fields
}

"""
order by aggregate values of table "agencies"
"""
input agencies_aggregate_order_by {
  count: order_by
  max: agencies_max_order_by
  min: agencies_min_order_by
}

"""
input type for inserting array relation for remote table "agencies"
"""
input agencies_arr_rel_insert_input {
  data: [agencies_insert_input!]!

  """upsert condition"""
  on_conflict: agencies_on_conflict
}

"""
Boolean expression to filter rows from the table "agencies". All fields are combined with a logical 'AND'.
"""
input agencies_bool_exp {
  _and: [agencies_bool_exp!]
  _not: agencies_bool_exp
  _or: [agencies_bool_exp!]
  address: String_comparison_exp
  city: String_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  name: uuid_comparison_exp
  neighborhood: String_comparison_exp
  office: String_comparison_exp
  phone_number: String_comparison_exp
  po_box: String_comparison_exp
  region: String_comparison_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "agencies"
"""
enum agencies_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agencies_pkey
}

"""
input type for inserting data into table "agencies"
"""
input agencies_insert_input {
  address: String
  city: String
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  departments: departments_arr_rel_insert_input
  employees: employees_arr_rel_insert_input
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type agencies_max_fields {
  address: String
  city: String
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "agencies"
"""
input agencies_max_order_by {
  address: order_by
  city: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  neighborhood: order_by
  office: order_by
  phone_number: order_by
  po_box: order_by
  region: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type agencies_min_fields {
  address: String
  city: String
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "agencies"
"""
input agencies_min_order_by {
  address: order_by
  city: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  neighborhood: order_by
  office: order_by
  phone_number: order_by
  po_box: order_by
  region: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "agencies"
"""
type agencies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agencies!]!
}

"""
input type for inserting object relation for remote table "agencies"
"""
input agencies_obj_rel_insert_input {
  data: agencies_insert_input!

  """upsert condition"""
  on_conflict: agencies_on_conflict
}

"""
on_conflict condition type for table "agencies"
"""
input agencies_on_conflict {
  constraint: agencies_constraint!
  update_columns: [agencies_update_column!]! = []
  where: agencies_bool_exp
}

"""Ordering options when selecting data from "agencies"."""
input agencies_order_by {
  address: order_by
  city: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  departments_aggregate: departments_aggregate_order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  location: order_by
  name: order_by
  neighborhood: order_by
  office: order_by
  phone_number: order_by
  po_box: order_by
  region: order_by
  text_content: text_content_order_by
  updated_at: order_by
}

"""primary key columns input for table: agencies"""
input agencies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agencies"
"""
enum agencies_select_column {
  """column name"""
  address

  """column name"""
  city

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  neighborhood

  """column name"""
  office

  """column name"""
  phone_number

  """column name"""
  po_box

  """column name"""
  region

  """column name"""
  updated_at
}

"""
input type for updating data in table "agencies"
"""
input agencies_set_input {
  address: String
  city: String
  company_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "agencies"
"""
input agencies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agencies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agencies_stream_cursor_value_input {
  address: String
  city: String
  company_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  updated_at: timestamptz
}

"""
update columns of table "agencies"
"""
enum agencies_update_column {
  """column name"""
  address

  """column name"""
  city

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  neighborhood

  """column name"""
  office

  """column name"""
  phone_number

  """column name"""
  po_box

  """column name"""
  region

  """column name"""
  updated_at
}

input agencies_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: agencies_set_input

  """filter the rows which have to be updated"""
  where: agencies_bool_exp!
}

"""
columns and relationships of "alarms"
"""
type alarms {
  alarm_time: timestamp
  created_at: timestamptz

  """An object relationship"""
  employee: employees!
  employee_id: uuid!

  """An object relationship"""
  event: events!
  event_id: uuid!
  id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "alarms"
"""
type alarms_aggregate {
  aggregate: alarms_aggregate_fields
  nodes: [alarms!]!
}

input alarms_aggregate_bool_exp {
  count: alarms_aggregate_bool_exp_count
}

input alarms_aggregate_bool_exp_count {
  arguments: [alarms_select_column!]
  distinct: Boolean
  filter: alarms_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "alarms"
"""
type alarms_aggregate_fields {
  count(columns: [alarms_select_column!], distinct: Boolean): Int!
  max: alarms_max_fields
  min: alarms_min_fields
}

"""
order by aggregate values of table "alarms"
"""
input alarms_aggregate_order_by {
  count: order_by
  max: alarms_max_order_by
  min: alarms_min_order_by
}

"""
input type for inserting array relation for remote table "alarms"
"""
input alarms_arr_rel_insert_input {
  data: [alarms_insert_input!]!

  """upsert condition"""
  on_conflict: alarms_on_conflict
}

"""
Boolean expression to filter rows from the table "alarms". All fields are combined with a logical 'AND'.
"""
input alarms_bool_exp {
  _and: [alarms_bool_exp!]
  _not: alarms_bool_exp
  _or: [alarms_bool_exp!]
  alarm_time: timestamp_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  event: events_bool_exp
  event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "alarms"
"""
enum alarms_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  alarms_pkey
}

"""
input type for inserting data into table "alarms"
"""
input alarms_insert_input {
  alarm_time: timestamp
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  event: events_obj_rel_insert_input
  event_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type alarms_max_fields {
  alarm_time: timestamp
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "alarms"
"""
input alarms_max_order_by {
  alarm_time: order_by
  created_at: order_by
  employee_id: order_by
  event_id: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type alarms_min_fields {
  alarm_time: timestamp
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "alarms"
"""
input alarms_min_order_by {
  alarm_time: order_by
  created_at: order_by
  employee_id: order_by
  event_id: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "alarms"
"""
type alarms_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [alarms!]!
}

"""
on_conflict condition type for table "alarms"
"""
input alarms_on_conflict {
  constraint: alarms_constraint!
  update_columns: [alarms_update_column!]! = []
  where: alarms_bool_exp
}

"""Ordering options when selecting data from "alarms"."""
input alarms_order_by {
  alarm_time: order_by
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  event: events_order_by
  event_id: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: alarms"""
input alarms_pk_columns_input {
  id: uuid!
}

"""
select columns of table "alarms"
"""
enum alarms_select_column {
  """column name"""
  alarm_time

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "alarms"
"""
input alarms_set_input {
  alarm_time: timestamp
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "alarms"
"""
input alarms_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: alarms_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input alarms_stream_cursor_value_input {
  alarm_time: timestamp
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "alarms"
"""
enum alarms_update_column {
  """column name"""
  alarm_time

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  updated_at
}

input alarms_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: alarms_set_input

  """filter the rows which have to be updated"""
  where: alarms_bool_exp!
}

"""
columns and relationships of "app_versions"
"""
type app_versions {
  created_at: timestamptz
  name: String!
  url: String!
  version: String!
}

"""
aggregated selection of "app_versions"
"""
type app_versions_aggregate {
  aggregate: app_versions_aggregate_fields
  nodes: [app_versions!]!
}

"""
aggregate fields of "app_versions"
"""
type app_versions_aggregate_fields {
  count(columns: [app_versions_select_column!], distinct: Boolean): Int!
  max: app_versions_max_fields
  min: app_versions_min_fields
}

"""
Boolean expression to filter rows from the table "app_versions". All fields are combined with a logical 'AND'.
"""
input app_versions_bool_exp {
  _and: [app_versions_bool_exp!]
  _not: app_versions_bool_exp
  _or: [app_versions_bool_exp!]
  created_at: timestamptz_comparison_exp
  name: String_comparison_exp
  url: String_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "app_versions"
"""
enum app_versions_constraint {
  """
  unique or primary key constraint on columns "version"
  """
  app_versions_pkey
}

"""
input type for inserting data into table "app_versions"
"""
input app_versions_insert_input {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""aggregate max on columns"""
type app_versions_max_fields {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""aggregate min on columns"""
type app_versions_min_fields {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""
response of any mutation on the table "app_versions"
"""
type app_versions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [app_versions!]!
}

"""
on_conflict condition type for table "app_versions"
"""
input app_versions_on_conflict {
  constraint: app_versions_constraint!
  update_columns: [app_versions_update_column!]! = []
  where: app_versions_bool_exp
}

"""Ordering options when selecting data from "app_versions"."""
input app_versions_order_by {
  created_at: order_by
  name: order_by
  url: order_by
  version: order_by
}

"""primary key columns input for table: app_versions"""
input app_versions_pk_columns_input {
  version: String!
}

"""
select columns of table "app_versions"
"""
enum app_versions_select_column {
  """column name"""
  created_at

  """column name"""
  name

  """column name"""
  url

  """column name"""
  version
}

"""
input type for updating data in table "app_versions"
"""
input app_versions_set_input {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""
Streaming cursor of the table "app_versions"
"""
input app_versions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: app_versions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input app_versions_stream_cursor_value_input {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""
update columns of table "app_versions"
"""
enum app_versions_update_column {
  """column name"""
  created_at

  """column name"""
  name

  """column name"""
  url

  """column name"""
  version
}

input app_versions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: app_versions_set_input

  """filter the rows which have to be updated"""
  where: app_versions_bool_exp!
}

"""
columns and relationships of "appointment_status"
"""
type appointment_status {
  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!
  status: String!
}

"""
aggregated selection of "appointment_status"
"""
type appointment_status_aggregate {
  aggregate: appointment_status_aggregate_fields
  nodes: [appointment_status!]!
}

"""
aggregate fields of "appointment_status"
"""
type appointment_status_aggregate_fields {
  count(columns: [appointment_status_select_column!], distinct: Boolean): Int!
  max: appointment_status_max_fields
  min: appointment_status_min_fields
}

"""
Boolean expression to filter rows from the table "appointment_status". All fields are combined with a logical 'AND'.
"""
input appointment_status_bool_exp {
  _and: [appointment_status_bool_exp!]
  _not: appointment_status_bool_exp
  _or: [appointment_status_bool_exp!]
  appointments: appointments_bool_exp
  appointments_aggregate: appointments_aggregate_bool_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "appointment_status"
"""
enum appointment_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  appointment_status_pkey
}

enum appointment_status_enum {
  CANCELED
  COMPLETED
  PENDING
}

"""
Boolean expression to compare columns of type "appointment_status_enum". All fields are combined with logical 'AND'.
"""
input appointment_status_enum_comparison_exp {
  _eq: appointment_status_enum
  _in: [appointment_status_enum!]
  _is_null: Boolean
  _neq: appointment_status_enum
  _nin: [appointment_status_enum!]
}

"""
input type for inserting data into table "appointment_status"
"""
input appointment_status_insert_input {
  appointments: appointments_arr_rel_insert_input
  status: String
}

"""aggregate max on columns"""
type appointment_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type appointment_status_min_fields {
  status: String
}

"""
response of any mutation on the table "appointment_status"
"""
type appointment_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [appointment_status!]!
}

"""
input type for inserting object relation for remote table "appointment_status"
"""
input appointment_status_obj_rel_insert_input {
  data: appointment_status_insert_input!

  """upsert condition"""
  on_conflict: appointment_status_on_conflict
}

"""
on_conflict condition type for table "appointment_status"
"""
input appointment_status_on_conflict {
  constraint: appointment_status_constraint!
  update_columns: [appointment_status_update_column!]! = []
  where: appointment_status_bool_exp
}

"""Ordering options when selecting data from "appointment_status"."""
input appointment_status_order_by {
  appointments_aggregate: appointments_aggregate_order_by
  status: order_by
}

"""primary key columns input for table: appointment_status"""
input appointment_status_pk_columns_input {
  status: String!
}

"""
select columns of table "appointment_status"
"""
enum appointment_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "appointment_status"
"""
input appointment_status_set_input {
  status: String
}

"""
Streaming cursor of the table "appointment_status"
"""
input appointment_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: appointment_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input appointment_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "appointment_status"
"""
enum appointment_status_update_column {
  """column name"""
  status
}

input appointment_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: appointment_status_set_input

  """filter the rows which have to be updated"""
  where: appointment_status_bool_exp!
}

"""
columns and relationships of "appointments"
"""
type appointments {
  """An object relationship"""
  appointment_status: appointment_status
  created_at: timestamptz
  date: date
  description: String

  """An object relationship"""
  employee: employees
  employee_id: uuid
  end_time: time
  id: uuid!
  start_time: time
  status: appointment_status_enum
  updated_at: timestamptz

  """An object relationship"""
  visitor: visitors
  visitor_id: uuid
}

"""
aggregated selection of "appointments"
"""
type appointments_aggregate {
  aggregate: appointments_aggregate_fields
  nodes: [appointments!]!
}

input appointments_aggregate_bool_exp {
  count: appointments_aggregate_bool_exp_count
}

input appointments_aggregate_bool_exp_count {
  arguments: [appointments_select_column!]
  distinct: Boolean
  filter: appointments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "appointments"
"""
type appointments_aggregate_fields {
  count(columns: [appointments_select_column!], distinct: Boolean): Int!
  max: appointments_max_fields
  min: appointments_min_fields
}

"""
order by aggregate values of table "appointments"
"""
input appointments_aggregate_order_by {
  count: order_by
  max: appointments_max_order_by
  min: appointments_min_order_by
}

"""
input type for inserting array relation for remote table "appointments"
"""
input appointments_arr_rel_insert_input {
  data: [appointments_insert_input!]!

  """upsert condition"""
  on_conflict: appointments_on_conflict
}

"""
Boolean expression to filter rows from the table "appointments". All fields are combined with a logical 'AND'.
"""
input appointments_bool_exp {
  _and: [appointments_bool_exp!]
  _not: appointments_bool_exp
  _or: [appointments_bool_exp!]
  appointment_status: appointment_status_bool_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  description: String_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  end_time: time_comparison_exp
  id: uuid_comparison_exp
  start_time: time_comparison_exp
  status: appointment_status_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  visitor: visitors_bool_exp
  visitor_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "appointments"
"""
enum appointments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  appointments_pkey
}

"""
input type for inserting data into table "appointments"
"""
input appointments_insert_input {
  appointment_status: appointment_status_obj_rel_insert_input
  created_at: timestamptz
  date: date
  description: String
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  end_time: time
  id: uuid
  start_time: time
  status: appointment_status_enum
  updated_at: timestamptz
  visitor: visitors_obj_rel_insert_input
  visitor_id: uuid
}

"""aggregate max on columns"""
type appointments_max_fields {
  created_at: timestamptz
  date: date
  description: String
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
  visitor_id: uuid
}

"""
order by max() on columns of table "appointments"
"""
input appointments_max_order_by {
  created_at: order_by
  date: order_by
  description: order_by
  employee_id: order_by
  id: order_by
  updated_at: order_by
  visitor_id: order_by
}

"""aggregate min on columns"""
type appointments_min_fields {
  created_at: timestamptz
  date: date
  description: String
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
  visitor_id: uuid
}

"""
order by min() on columns of table "appointments"
"""
input appointments_min_order_by {
  created_at: order_by
  date: order_by
  description: order_by
  employee_id: order_by
  id: order_by
  updated_at: order_by
  visitor_id: order_by
}

"""
response of any mutation on the table "appointments"
"""
type appointments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [appointments!]!
}

"""
on_conflict condition type for table "appointments"
"""
input appointments_on_conflict {
  constraint: appointments_constraint!
  update_columns: [appointments_update_column!]! = []
  where: appointments_bool_exp
}

"""Ordering options when selecting data from "appointments"."""
input appointments_order_by {
  appointment_status: appointment_status_order_by
  created_at: order_by
  date: order_by
  description: order_by
  employee: employees_order_by
  employee_id: order_by
  end_time: order_by
  id: order_by
  start_time: order_by
  status: order_by
  updated_at: order_by
  visitor: visitors_order_by
  visitor_id: order_by
}

"""primary key columns input for table: appointments"""
input appointments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "appointments"
"""
enum appointments_select_column {
  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  description

  """column name"""
  employee_id

  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  start_time

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  visitor_id
}

"""
input type for updating data in table "appointments"
"""
input appointments_set_input {
  created_at: timestamptz
  date: date
  description: String
  employee_id: uuid
  end_time: time
  id: uuid
  start_time: time
  status: appointment_status_enum
  updated_at: timestamptz
  visitor_id: uuid
}

"""
Streaming cursor of the table "appointments"
"""
input appointments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: appointments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input appointments_stream_cursor_value_input {
  created_at: timestamptz
  date: date
  description: String
  employee_id: uuid
  end_time: time
  id: uuid
  start_time: time
  status: appointment_status_enum
  updated_at: timestamptz
  visitor_id: uuid
}

"""
update columns of table "appointments"
"""
enum appointments_update_column {
  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  description

  """column name"""
  employee_id

  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  start_time

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  visitor_id
}

input appointments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: appointments_set_input

  """filter the rows which have to be updated"""
  where: appointments_bool_exp!
}

type AppointmentTodayPercentage {
  percent: Float
  todayCount: Int!
  tomorrowCount: Int!
}

"""
columns and relationships of "attachments"
"""
type attachments {
  created_at: timestamptz
  extension: String
  file_path: String!
  file_size: String
  file_type: String
  filename: String!

  """An array relationship"""
  group_messages(
    """distinct select on columns"""
    distinct_on: [group_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_messages_order_by!]

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): [group_messages!]!

  """An aggregate relationship"""
  group_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [group_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_messages_order_by!]

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): group_messages_aggregate!
  height: String
  id: uuid!
  length: String

  """An object relationship"""
  message: messages!
  message_id: uuid!
  mime_type: String
  samples: String
  updated_at: timestamptz
  width: String
}

"""
aggregated selection of "attachments"
"""
type attachments_aggregate {
  aggregate: attachments_aggregate_fields
  nodes: [attachments!]!
}

input attachments_aggregate_bool_exp {
  count: attachments_aggregate_bool_exp_count
}

input attachments_aggregate_bool_exp_count {
  arguments: [attachments_select_column!]
  distinct: Boolean
  filter: attachments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attachments"
"""
type attachments_aggregate_fields {
  count(columns: [attachments_select_column!], distinct: Boolean): Int!
  max: attachments_max_fields
  min: attachments_min_fields
}

"""
order by aggregate values of table "attachments"
"""
input attachments_aggregate_order_by {
  count: order_by
  max: attachments_max_order_by
  min: attachments_min_order_by
}

"""
input type for inserting array relation for remote table "attachments"
"""
input attachments_arr_rel_insert_input {
  data: [attachments_insert_input!]!

  """upsert condition"""
  on_conflict: attachments_on_conflict
}

"""
Boolean expression to filter rows from the table "attachments". All fields are combined with a logical 'AND'.
"""
input attachments_bool_exp {
  _and: [attachments_bool_exp!]
  _not: attachments_bool_exp
  _or: [attachments_bool_exp!]
  created_at: timestamptz_comparison_exp
  extension: String_comparison_exp
  file_path: String_comparison_exp
  file_size: String_comparison_exp
  file_type: String_comparison_exp
  filename: String_comparison_exp
  group_messages: group_messages_bool_exp
  group_messages_aggregate: group_messages_aggregate_bool_exp
  height: String_comparison_exp
  id: uuid_comparison_exp
  length: String_comparison_exp
  message: messages_bool_exp
  message_id: uuid_comparison_exp
  mime_type: String_comparison_exp
  samples: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  width: String_comparison_exp
}

"""
unique or primary key constraints on table "attachments"
"""
enum attachments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  attachments_pkey
}

"""
input type for inserting data into table "attachments"
"""
input attachments_insert_input {
  created_at: timestamptz
  extension: String
  file_path: String
  file_size: String
  file_type: String
  filename: String
  group_messages: group_messages_arr_rel_insert_input
  height: String
  id: uuid
  length: String
  message: messages_obj_rel_insert_input
  message_id: uuid
  mime_type: String
  samples: String
  updated_at: timestamptz
  width: String
}

"""aggregate max on columns"""
type attachments_max_fields {
  created_at: timestamptz
  extension: String
  file_path: String
  file_size: String
  file_type: String
  filename: String
  height: String
  id: uuid
  length: String
  message_id: uuid
  mime_type: String
  samples: String
  updated_at: timestamptz
  width: String
}

"""
order by max() on columns of table "attachments"
"""
input attachments_max_order_by {
  created_at: order_by
  extension: order_by
  file_path: order_by
  file_size: order_by
  file_type: order_by
  filename: order_by
  height: order_by
  id: order_by
  length: order_by
  message_id: order_by
  mime_type: order_by
  samples: order_by
  updated_at: order_by
  width: order_by
}

"""aggregate min on columns"""
type attachments_min_fields {
  created_at: timestamptz
  extension: String
  file_path: String
  file_size: String
  file_type: String
  filename: String
  height: String
  id: uuid
  length: String
  message_id: uuid
  mime_type: String
  samples: String
  updated_at: timestamptz
  width: String
}

"""
order by min() on columns of table "attachments"
"""
input attachments_min_order_by {
  created_at: order_by
  extension: order_by
  file_path: order_by
  file_size: order_by
  file_type: order_by
  filename: order_by
  height: order_by
  id: order_by
  length: order_by
  message_id: order_by
  mime_type: order_by
  samples: order_by
  updated_at: order_by
  width: order_by
}

"""
response of any mutation on the table "attachments"
"""
type attachments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attachments!]!
}

"""
input type for inserting object relation for remote table "attachments"
"""
input attachments_obj_rel_insert_input {
  data: attachments_insert_input!

  """upsert condition"""
  on_conflict: attachments_on_conflict
}

"""
on_conflict condition type for table "attachments"
"""
input attachments_on_conflict {
  constraint: attachments_constraint!
  update_columns: [attachments_update_column!]! = []
  where: attachments_bool_exp
}

"""Ordering options when selecting data from "attachments"."""
input attachments_order_by {
  created_at: order_by
  extension: order_by
  file_path: order_by
  file_size: order_by
  file_type: order_by
  filename: order_by
  group_messages_aggregate: group_messages_aggregate_order_by
  height: order_by
  id: order_by
  length: order_by
  message: messages_order_by
  message_id: order_by
  mime_type: order_by
  samples: order_by
  updated_at: order_by
  width: order_by
}

"""primary key columns input for table: attachments"""
input attachments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attachments"
"""
enum attachments_select_column {
  """column name"""
  created_at

  """column name"""
  extension

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  file_type

  """column name"""
  filename

  """column name"""
  height

  """column name"""
  id

  """column name"""
  length

  """column name"""
  message_id

  """column name"""
  mime_type

  """column name"""
  samples

  """column name"""
  updated_at

  """column name"""
  width
}

"""
input type for updating data in table "attachments"
"""
input attachments_set_input {
  created_at: timestamptz
  extension: String
  file_path: String
  file_size: String
  file_type: String
  filename: String
  height: String
  id: uuid
  length: String
  message_id: uuid
  mime_type: String
  samples: String
  updated_at: timestamptz
  width: String
}

"""
Streaming cursor of the table "attachments"
"""
input attachments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attachments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attachments_stream_cursor_value_input {
  created_at: timestamptz
  extension: String
  file_path: String
  file_size: String
  file_type: String
  filename: String
  height: String
  id: uuid
  length: String
  message_id: uuid
  mime_type: String
  samples: String
  updated_at: timestamptz
  width: String
}

"""
update columns of table "attachments"
"""
enum attachments_update_column {
  """column name"""
  created_at

  """column name"""
  extension

  """column name"""
  file_path

  """column name"""
  file_size

  """column name"""
  file_type

  """column name"""
  filename

  """column name"""
  height

  """column name"""
  id

  """column name"""
  length

  """column name"""
  message_id

  """column name"""
  mime_type

  """column name"""
  samples

  """column name"""
  updated_at

  """column name"""
  width
}

input attachments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: attachments_set_input

  """filter the rows which have to be updated"""
  where: attachments_bool_exp!
}

"""
columns and relationships of "attendance"
"""
type attendance {
  """An object relationship"""
  attendance_state: attendance_state
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz

  """An object relationship"""
  employee: employees
  employee_id: uuid
  id: uuid!
  location: geometry

  """An object relationship"""
  shift: shifts
  shift_id: uuid
}

"""
aggregated selection of "attendance"
"""
type attendance_aggregate {
  aggregate: attendance_aggregate_fields
  nodes: [attendance!]!
}

input attendance_aggregate_bool_exp {
  count: attendance_aggregate_bool_exp_count
}

input attendance_aggregate_bool_exp_count {
  arguments: [attendance_select_column!]
  distinct: Boolean
  filter: attendance_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attendance"
"""
type attendance_aggregate_fields {
  count(columns: [attendance_select_column!], distinct: Boolean): Int!
  max: attendance_max_fields
  min: attendance_min_fields
}

"""
order by aggregate values of table "attendance"
"""
input attendance_aggregate_order_by {
  count: order_by
  max: attendance_max_order_by
  min: attendance_min_order_by
}

"""
input type for inserting array relation for remote table "attendance"
"""
input attendance_arr_rel_insert_input {
  data: [attendance_insert_input!]!

  """upsert condition"""
  on_conflict: attendance_on_conflict
}

"""
Boolean expression to filter rows from the table "attendance". All fields are combined with a logical 'AND'.
"""
input attendance_bool_exp {
  _and: [attendance_bool_exp!]
  _not: attendance_bool_exp
  _or: [attendance_bool_exp!]
  attendance_state: attendance_state_bool_exp
  building_id: uuid_comparison_exp
  clock_in_date: date_comparison_exp
  clock_in_time: timestamptz_comparison_exp
  clock_out_time: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  shift: shifts_bool_exp
  shift_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "attendance"
"""
enum attendance_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  attendance_pkey
}

"""
input type for inserting data into table "attendance"
"""
input attendance_insert_input {
  attendance_state: attendance_state_obj_rel_insert_input
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  location: geometry
  shift: shifts_obj_rel_insert_input
  shift_id: uuid
}

"""aggregate max on columns"""
type attendance_max_fields {
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
order by max() on columns of table "attendance"
"""
input attendance_max_order_by {
  building_id: order_by
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee_id: order_by
  id: order_by
  shift_id: order_by
}

"""aggregate min on columns"""
type attendance_min_fields {
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
order by min() on columns of table "attendance"
"""
input attendance_min_order_by {
  building_id: order_by
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee_id: order_by
  id: order_by
  shift_id: order_by
}

"""
response of any mutation on the table "attendance"
"""
type attendance_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attendance!]!
}

"""
input type for inserting object relation for remote table "attendance"
"""
input attendance_obj_rel_insert_input {
  data: attendance_insert_input!

  """upsert condition"""
  on_conflict: attendance_on_conflict
}

"""
on_conflict condition type for table "attendance"
"""
input attendance_on_conflict {
  constraint: attendance_constraint!
  update_columns: [attendance_update_column!]! = []
  where: attendance_bool_exp
}

"""Ordering options when selecting data from "attendance"."""
input attendance_order_by {
  attendance_state: attendance_state_order_by
  building_id: order_by
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  location: order_by
  shift: shifts_order_by
  shift_id: order_by
}

"""primary key columns input for table: attendance"""
input attendance_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attendance"
"""
enum attendance_select_column {
  """column name"""
  building_id

  """column name"""
  clock_in_date

  """column name"""
  clock_in_time

  """column name"""
  clock_out_time

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  shift_id
}

"""
input type for updating data in table "attendance"
"""
input attendance_set_input {
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  location: geometry
  shift_id: uuid
}

"""
columns and relationships of "attendance_state"
"""
type attendance_state {
  """An object relationship"""
  attendance: attendance
  attendance_id: uuid
  id: uuid!
  is_late: Boolean
}

"""
aggregated selection of "attendance_state"
"""
type attendance_state_aggregate {
  aggregate: attendance_state_aggregate_fields
  nodes: [attendance_state!]!
}

"""
aggregate fields of "attendance_state"
"""
type attendance_state_aggregate_fields {
  count(columns: [attendance_state_select_column!], distinct: Boolean): Int!
  max: attendance_state_max_fields
  min: attendance_state_min_fields
}

"""
Boolean expression to filter rows from the table "attendance_state". All fields are combined with a logical 'AND'.
"""
input attendance_state_bool_exp {
  _and: [attendance_state_bool_exp!]
  _not: attendance_state_bool_exp
  _or: [attendance_state_bool_exp!]
  attendance: attendance_bool_exp
  attendance_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_late: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "attendance_state"
"""
enum attendance_state_constraint {
  """
  unique or primary key constraint on columns "attendance_id"
  """
  attendance_state_attendance_id_key

  """
  unique or primary key constraint on columns "id"
  """
  attendance_state_pkey
}

"""
input type for inserting data into table "attendance_state"
"""
input attendance_state_insert_input {
  attendance: attendance_obj_rel_insert_input
  attendance_id: uuid
  id: uuid
  is_late: Boolean
}

"""aggregate max on columns"""
type attendance_state_max_fields {
  attendance_id: uuid
  id: uuid
}

"""aggregate min on columns"""
type attendance_state_min_fields {
  attendance_id: uuid
  id: uuid
}

"""
response of any mutation on the table "attendance_state"
"""
type attendance_state_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attendance_state!]!
}

"""
input type for inserting object relation for remote table "attendance_state"
"""
input attendance_state_obj_rel_insert_input {
  data: attendance_state_insert_input!

  """upsert condition"""
  on_conflict: attendance_state_on_conflict
}

"""
on_conflict condition type for table "attendance_state"
"""
input attendance_state_on_conflict {
  constraint: attendance_state_constraint!
  update_columns: [attendance_state_update_column!]! = []
  where: attendance_state_bool_exp
}

"""Ordering options when selecting data from "attendance_state"."""
input attendance_state_order_by {
  attendance: attendance_order_by
  attendance_id: order_by
  id: order_by
  is_late: order_by
}

"""primary key columns input for table: attendance_state"""
input attendance_state_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attendance_state"
"""
enum attendance_state_select_column {
  """column name"""
  attendance_id

  """column name"""
  id

  """column name"""
  is_late
}

"""
input type for updating data in table "attendance_state"
"""
input attendance_state_set_input {
  attendance_id: uuid
  id: uuid
  is_late: Boolean
}

"""
Streaming cursor of the table "attendance_state"
"""
input attendance_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attendance_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attendance_state_stream_cursor_value_input {
  attendance_id: uuid
  id: uuid
  is_late: Boolean
}

"""
update columns of table "attendance_state"
"""
enum attendance_state_update_column {
  """column name"""
  attendance_id

  """column name"""
  id

  """column name"""
  is_late
}

input attendance_state_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: attendance_state_set_input

  """filter the rows which have to be updated"""
  where: attendance_state_bool_exp!
}

"""
Streaming cursor of the table "attendance"
"""
input attendance_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attendance_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attendance_stream_cursor_value_input {
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  location: geometry
  shift_id: uuid
}

"""
update columns of table "attendance"
"""
enum attendance_update_column {
  """column name"""
  building_id

  """column name"""
  clock_in_date

  """column name"""
  clock_in_time

  """column name"""
  clock_out_time

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  shift_id
}

input attendance_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: attendance_set_input

  """filter the rows which have to be updated"""
  where: attendance_bool_exp!
}

type AttendanceCountByWeek {
  day: String!
  lateEmployees: Int!
  onTimeEmployees: Int!
  presentEmployees: Int!
}

input AttendanceInpuType {
  endDate: DateTime!
  startDate: DateTime!
}

type AttendanceType {
  clockIn: DateTime!
  clockOut: DateTime
  employee: EmployeeAttendatceType!
  timeInBuilding: String
}

type AttendnacePercentage {
  attendancePercentage: Float!
  totalEmployee: Int!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "companies"
"""
type companies {
  abbrev: String
  address: String

  """An array relationship"""
  agencies(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An aggregate relationship"""
  agencies_aggregate(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): agencies_aggregate!
  city: String!

  """An array relationship"""
  company_settings(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): [company_settings!]!

  """An aggregate relationship"""
  company_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): company_settings_aggregate!
  created_at: timestamptz

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!
  email: String!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  location: geometry
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String

  """An array relationship"""
  positions(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """An aggregate relationship"""
  positions_aggregate(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): positions_aggregate!
  profile_picture: String
  region: String!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An array relationship"""
  servicesByCompanyId(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  servicesByCompanyId_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!
}

"""
aggregated selection of "companies"
"""
type companies_aggregate {
  aggregate: companies_aggregate_fields
  nodes: [companies!]!
}

input companies_aggregate_bool_exp {
  count: companies_aggregate_bool_exp_count
}

input companies_aggregate_bool_exp_count {
  arguments: [companies_select_column!]
  distinct: Boolean
  filter: companies_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "companies"
"""
type companies_aggregate_fields {
  count(columns: [companies_select_column!], distinct: Boolean): Int!
  max: companies_max_fields
  min: companies_min_fields
}

"""
order by aggregate values of table "companies"
"""
input companies_aggregate_order_by {
  count: order_by
  max: companies_max_order_by
  min: companies_min_order_by
}

"""
input type for inserting array relation for remote table "companies"
"""
input companies_arr_rel_insert_input {
  data: [companies_insert_input!]!

  """upsert condition"""
  on_conflict: companies_on_conflict
}

"""
Boolean expression to filter rows from the table "companies". All fields are combined with a logical 'AND'.
"""
input companies_bool_exp {
  _and: [companies_bool_exp!]
  _not: companies_bool_exp
  _or: [companies_bool_exp!]
  abbrev: String_comparison_exp
  address: String_comparison_exp
  agencies: agencies_bool_exp
  agencies_aggregate: agencies_aggregate_bool_exp
  city: String_comparison_exp
  company_settings: company_settings_bool_exp
  company_settings_aggregate: company_settings_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  email: String_comparison_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  name: uuid_comparison_exp
  neighborhood: String_comparison_exp
  phone_number: String_comparison_exp
  po_box: String_comparison_exp
  positions: positions_bool_exp
  positions_aggregate: positions_aggregate_bool_exp
  profile_picture: String_comparison_exp
  region: String_comparison_exp
  services: services_bool_exp
  servicesByCompanyId: services_bool_exp
  servicesByCompanyId_aggregate: services_aggregate_bool_exp
  services_aggregate: services_aggregate_bool_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
  visitors: visitors_bool_exp
  visitors_aggregate: visitors_aggregate_bool_exp
}

"""
unique or primary key constraints on table "companies"
"""
enum companies_constraint {
  """
  unique or primary key constraint on columns "abbrev"
  """
  companies_abbrev_key

  """
  unique or primary key constraint on columns "email"
  """
  companies_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  companies_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  companies_pkey
}

"""
input type for inserting data into table "companies"
"""
input companies_insert_input {
  abbrev: String
  address: String
  agencies: agencies_arr_rel_insert_input
  city: String
  company_settings: company_settings_arr_rel_insert_input
  created_at: timestamptz
  departments: departments_arr_rel_insert_input
  email: String
  employees: employees_arr_rel_insert_input
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  positions: positions_arr_rel_insert_input
  profile_picture: String
  region: String
  services: services_arr_rel_insert_input
  servicesByCompanyId: services_arr_rel_insert_input
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
  visitors: visitors_arr_rel_insert_input
}

"""aggregate max on columns"""
type companies_max_fields {
  abbrev: String
  address: String
  city: String
  created_at: timestamptz
  email: String
  id: uuid
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "companies"
"""
input companies_max_order_by {
  abbrev: order_by
  address: order_by
  city: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  neighborhood: order_by
  phone_number: order_by
  po_box: order_by
  profile_picture: order_by
  region: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type companies_min_fields {
  abbrev: String
  address: String
  city: String
  created_at: timestamptz
  email: String
  id: uuid
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "companies"
"""
input companies_min_order_by {
  abbrev: order_by
  address: order_by
  city: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  neighborhood: order_by
  phone_number: order_by
  po_box: order_by
  profile_picture: order_by
  region: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "companies"
"""
type companies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [companies!]!
}

"""
input type for inserting object relation for remote table "companies"
"""
input companies_obj_rel_insert_input {
  data: companies_insert_input!

  """upsert condition"""
  on_conflict: companies_on_conflict
}

"""
on_conflict condition type for table "companies"
"""
input companies_on_conflict {
  constraint: companies_constraint!
  update_columns: [companies_update_column!]! = []
  where: companies_bool_exp
}

"""Ordering options when selecting data from "companies"."""
input companies_order_by {
  abbrev: order_by
  address: order_by
  agencies_aggregate: agencies_aggregate_order_by
  city: order_by
  company_settings_aggregate: company_settings_aggregate_order_by
  created_at: order_by
  departments_aggregate: departments_aggregate_order_by
  email: order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  location: order_by
  name: order_by
  neighborhood: order_by
  phone_number: order_by
  po_box: order_by
  positions_aggregate: positions_aggregate_order_by
  profile_picture: order_by
  region: order_by
  servicesByCompanyId_aggregate: services_aggregate_order_by
  services_aggregate: services_aggregate_order_by
  text_content: text_content_order_by
  updated_at: order_by
  visitors_aggregate: visitors_aggregate_order_by
}

"""primary key columns input for table: companies"""
input companies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "companies"
"""
enum companies_select_column {
  """column name"""
  abbrev

  """column name"""
  address

  """column name"""
  city

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  neighborhood

  """column name"""
  phone_number

  """column name"""
  po_box

  """column name"""
  profile_picture

  """column name"""
  region

  """column name"""
  updated_at
}

"""
input type for updating data in table "companies"
"""
input companies_set_input {
  abbrev: String
  address: String
  city: String
  created_at: timestamptz
  email: String
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "companies"
"""
input companies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: companies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input companies_stream_cursor_value_input {
  abbrev: String
  address: String
  city: String
  created_at: timestamptz
  email: String
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  updated_at: timestamptz
}

"""
update columns of table "companies"
"""
enum companies_update_column {
  """column name"""
  abbrev

  """column name"""
  address

  """column name"""
  city

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  neighborhood

  """column name"""
  phone_number

  """column name"""
  po_box

  """column name"""
  profile_picture

  """column name"""
  region

  """column name"""
  updated_at
}

input companies_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: companies_set_input

  """filter the rows which have to be updated"""
  where: companies_bool_exp!
}

"""
columns and relationships of "company_settings"
"""
type company_settings {
  break_duration: interval

  """An object relationship"""
  company: companies
  company_id: uuid
  end_work_time: time!
  id: uuid!
  max_late_time: interval!
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  start_work_time: time!
  working_days: [Int!]
}

"""
aggregated selection of "company_settings"
"""
type company_settings_aggregate {
  aggregate: company_settings_aggregate_fields
  nodes: [company_settings!]!
}

input company_settings_aggregate_bool_exp {
  count: company_settings_aggregate_bool_exp_count
}

input company_settings_aggregate_bool_exp_count {
  arguments: [company_settings_select_column!]
  distinct: Boolean
  filter: company_settings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "company_settings"
"""
type company_settings_aggregate_fields {
  avg: company_settings_avg_fields
  count(columns: [company_settings_select_column!], distinct: Boolean): Int!
  max: company_settings_max_fields
  min: company_settings_min_fields
  stddev: company_settings_stddev_fields
  stddev_pop: company_settings_stddev_pop_fields
  stddev_samp: company_settings_stddev_samp_fields
  sum: company_settings_sum_fields
  var_pop: company_settings_var_pop_fields
  var_samp: company_settings_var_samp_fields
  variance: company_settings_variance_fields
}

"""
order by aggregate values of table "company_settings"
"""
input company_settings_aggregate_order_by {
  avg: company_settings_avg_order_by
  count: order_by
  max: company_settings_max_order_by
  min: company_settings_min_order_by
  stddev: company_settings_stddev_order_by
  stddev_pop: company_settings_stddev_pop_order_by
  stddev_samp: company_settings_stddev_samp_order_by
  sum: company_settings_sum_order_by
  var_pop: company_settings_var_pop_order_by
  var_samp: company_settings_var_samp_order_by
  variance: company_settings_variance_order_by
}

"""
input type for inserting array relation for remote table "company_settings"
"""
input company_settings_arr_rel_insert_input {
  data: [company_settings_insert_input!]!

  """upsert condition"""
  on_conflict: company_settings_on_conflict
}

"""aggregate avg on columns"""
type company_settings_avg_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by avg() on columns of table "company_settings"
"""
input company_settings_avg_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""
Boolean expression to filter rows from the table "company_settings". All fields are combined with a logical 'AND'.
"""
input company_settings_bool_exp {
  _and: [company_settings_bool_exp!]
  _not: company_settings_bool_exp
  _or: [company_settings_bool_exp!]
  break_duration: interval_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  end_work_time: time_comparison_exp
  id: uuid_comparison_exp
  max_late_time: interval_comparison_exp
  max_leave_days_per_year: Int_comparison_exp
  number_of_leave_days: Int_comparison_exp
  start_work_time: time_comparison_exp
  working_days: Int_array_comparison_exp
}

"""
unique or primary key constraints on table "company_settings"
"""
enum company_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  company_settings_pkey
}

"""
input type for incrementing numeric columns in table "company_settings"
"""
input company_settings_inc_input {
  max_leave_days_per_year: Int
  number_of_leave_days: Int
}

"""
input type for inserting data into table "company_settings"
"""
input company_settings_insert_input {
  break_duration: interval
  company: companies_obj_rel_insert_input
  company_id: uuid
  end_work_time: time
  id: uuid
  max_late_time: interval
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  start_work_time: time
  working_days: [Int!]
}

"""aggregate max on columns"""
type company_settings_max_fields {
  company_id: uuid
  id: uuid
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  working_days: [Int!]
}

"""
order by max() on columns of table "company_settings"
"""
input company_settings_max_order_by {
  company_id: order_by
  id: order_by
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
  working_days: order_by
}

"""aggregate min on columns"""
type company_settings_min_fields {
  company_id: uuid
  id: uuid
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  working_days: [Int!]
}

"""
order by min() on columns of table "company_settings"
"""
input company_settings_min_order_by {
  company_id: order_by
  id: order_by
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
  working_days: order_by
}

"""
response of any mutation on the table "company_settings"
"""
type company_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [company_settings!]!
}

"""
on_conflict condition type for table "company_settings"
"""
input company_settings_on_conflict {
  constraint: company_settings_constraint!
  update_columns: [company_settings_update_column!]! = []
  where: company_settings_bool_exp
}

"""Ordering options when selecting data from "company_settings"."""
input company_settings_order_by {
  break_duration: order_by
  company: companies_order_by
  company_id: order_by
  end_work_time: order_by
  id: order_by
  max_late_time: order_by
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
  start_work_time: order_by
  working_days: order_by
}

"""primary key columns input for table: company_settings"""
input company_settings_pk_columns_input {
  id: uuid!
}

"""
select columns of table "company_settings"
"""
enum company_settings_select_column {
  """column name"""
  break_duration

  """column name"""
  company_id

  """column name"""
  end_work_time

  """column name"""
  id

  """column name"""
  max_late_time

  """column name"""
  max_leave_days_per_year

  """column name"""
  number_of_leave_days

  """column name"""
  start_work_time

  """column name"""
  working_days
}

"""
input type for updating data in table "company_settings"
"""
input company_settings_set_input {
  break_duration: interval
  company_id: uuid
  end_work_time: time
  id: uuid
  max_late_time: interval
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  start_work_time: time
  working_days: [Int!]
}

"""aggregate stddev on columns"""
type company_settings_stddev_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by stddev() on columns of table "company_settings"
"""
input company_settings_stddev_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""aggregate stddev_pop on columns"""
type company_settings_stddev_pop_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by stddev_pop() on columns of table "company_settings"
"""
input company_settings_stddev_pop_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""aggregate stddev_samp on columns"""
type company_settings_stddev_samp_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by stddev_samp() on columns of table "company_settings"
"""
input company_settings_stddev_samp_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""
Streaming cursor of the table "company_settings"
"""
input company_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: company_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input company_settings_stream_cursor_value_input {
  break_duration: interval
  company_id: uuid
  end_work_time: time
  id: uuid
  max_late_time: interval
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  start_work_time: time
  working_days: [Int!]
}

"""aggregate sum on columns"""
type company_settings_sum_fields {
  max_leave_days_per_year: Int
  number_of_leave_days: Int
}

"""
order by sum() on columns of table "company_settings"
"""
input company_settings_sum_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""
update columns of table "company_settings"
"""
enum company_settings_update_column {
  """column name"""
  break_duration

  """column name"""
  company_id

  """column name"""
  end_work_time

  """column name"""
  id

  """column name"""
  max_late_time

  """column name"""
  max_leave_days_per_year

  """column name"""
  number_of_leave_days

  """column name"""
  start_work_time

  """column name"""
  working_days
}

input company_settings_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: company_settings_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: company_settings_set_input

  """filter the rows which have to be updated"""
  where: company_settings_bool_exp!
}

"""aggregate var_pop on columns"""
type company_settings_var_pop_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by var_pop() on columns of table "company_settings"
"""
input company_settings_var_pop_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""aggregate var_samp on columns"""
type company_settings_var_samp_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by var_samp() on columns of table "company_settings"
"""
input company_settings_var_samp_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""aggregate variance on columns"""
type company_settings_variance_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by variance() on columns of table "company_settings"
"""
input company_settings_variance_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""
columns and relationships of "conversations"
"""
type conversations {
  created_at: timestamptz

  """An array relationship"""
  employee_conversations(
    """distinct select on columns"""
    distinct_on: [employee_conversation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_conversation_order_by!]

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): [employee_conversation!]!

  """An aggregate relationship"""
  employee_conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_conversation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_conversation_order_by!]

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): employee_conversation_aggregate!
  id: uuid!
  is_group: Boolean

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!
  name: String
  updated_at: timestamptz
}

"""
aggregated selection of "conversations"
"""
type conversations_aggregate {
  aggregate: conversations_aggregate_fields
  nodes: [conversations!]!
}

"""
aggregate fields of "conversations"
"""
type conversations_aggregate_fields {
  count(columns: [conversations_select_column!], distinct: Boolean): Int!
  max: conversations_max_fields
  min: conversations_min_fields
}

"""
Boolean expression to filter rows from the table "conversations". All fields are combined with a logical 'AND'.
"""
input conversations_bool_exp {
  _and: [conversations_bool_exp!]
  _not: conversations_bool_exp
  _or: [conversations_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee_conversations: employee_conversation_bool_exp
  employee_conversations_aggregate: employee_conversation_aggregate_bool_exp
  id: uuid_comparison_exp
  is_group: Boolean_comparison_exp
  messages: messages_bool_exp
  messages_aggregate: messages_aggregate_bool_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conversations"
"""
enum conversations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  conversations_pkey
}

"""
input type for inserting data into table "conversations"
"""
input conversations_insert_input {
  created_at: timestamptz
  employee_conversations: employee_conversation_arr_rel_insert_input
  id: uuid
  is_group: Boolean
  messages: messages_arr_rel_insert_input
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conversations_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conversations_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conversations"
"""
type conversations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conversations!]!
}

"""
input type for inserting object relation for remote table "conversations"
"""
input conversations_obj_rel_insert_input {
  data: conversations_insert_input!

  """upsert condition"""
  on_conflict: conversations_on_conflict
}

"""
on_conflict condition type for table "conversations"
"""
input conversations_on_conflict {
  constraint: conversations_constraint!
  update_columns: [conversations_update_column!]! = []
  where: conversations_bool_exp
}

"""Ordering options when selecting data from "conversations"."""
input conversations_order_by {
  created_at: order_by
  employee_conversations_aggregate: employee_conversation_aggregate_order_by
  id: order_by
  is_group: order_by
  messages_aggregate: messages_aggregate_order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conversations"""
input conversations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "conversations"
"""
enum conversations_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_group

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conversations"
"""
input conversations_set_input {
  created_at: timestamptz
  id: uuid
  is_group: Boolean
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conversations"
"""
input conversations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conversations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conversations_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  is_group: Boolean
  name: String
  updated_at: timestamptz
}

"""
update columns of table "conversations"
"""
enum conversations_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_group

  """column name"""
  name

  """column name"""
  updated_at
}

input conversations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conversations_set_input

  """filter the rows which have to be updated"""
  where: conversations_bool_exp!
}

input CreateConvInput {
  firstParticipant: UUID!
  isGroup: Boolean!
  name: String = null
  secondParticipants: UUID!
}

type CreateConvOutput {
  id: UUID!
}

input CreateEmployeeInput {
  address: String!
  agencyId: UUID = null
  companyId: UUID!
  departmentId: UUID!
  email: String
  firstname: String!
  function: String!
  lastname: String!
  license: String!
  password: String!
  phoneNumber: String!
  positionId: UUID!
  region: String!
  roles: CreateEmployeeRole!
  serviceId: UUID!
  supervisorId: UUID = null
}

enum CreateEmployeeRole {
  ADMIN
  EMPLOYEE
  GUARD
}

type CreateVisitorType {
  id: UUID!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""Date (isoformat)"""
scalar Date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""Date with time (isoformat)"""
scalar DateTime

type DayAttendanceType {
  attendance: [AttendanceType!]!
  date: DateTime!
}

type DenyParcipateEvent {
  id: UUID!
}

"""
columns and relationships of "departments"
"""
type departments {
  abrev_code: String

  """An object relationship"""
  agency: agencies
  agency_id: uuid
  chief_department: uuid

  """An object relationship"""
  company: companies!
  company_id: uuid!
  created_at: timestamptz

  """An object relationship"""
  department: departments

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """An object relationship"""
  employee: employees

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  name: uuid
  parent_department_id: uuid

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  status: status_enum

  """An object relationship"""
  statusByStatus: status

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "departments"
"""
type departments_aggregate {
  aggregate: departments_aggregate_fields
  nodes: [departments!]!
}

input departments_aggregate_bool_exp {
  count: departments_aggregate_bool_exp_count
}

input departments_aggregate_bool_exp_count {
  arguments: [departments_select_column!]
  distinct: Boolean
  filter: departments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "departments"
"""
type departments_aggregate_fields {
  count(columns: [departments_select_column!], distinct: Boolean): Int!
  max: departments_max_fields
  min: departments_min_fields
}

"""
order by aggregate values of table "departments"
"""
input departments_aggregate_order_by {
  count: order_by
  max: departments_max_order_by
  min: departments_min_order_by
}

"""
input type for inserting array relation for remote table "departments"
"""
input departments_arr_rel_insert_input {
  data: [departments_insert_input!]!

  """upsert condition"""
  on_conflict: departments_on_conflict
}

"""
Boolean expression to filter rows from the table "departments". All fields are combined with a logical 'AND'.
"""
input departments_bool_exp {
  _and: [departments_bool_exp!]
  _not: departments_bool_exp
  _or: [departments_bool_exp!]
  abrev_code: String_comparison_exp
  agency: agencies_bool_exp
  agency_id: uuid_comparison_exp
  chief_department: uuid_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  department: departments_bool_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  employee: employees_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  name: uuid_comparison_exp
  parent_department_id: uuid_comparison_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  status: status_enum_comparison_exp
  statusByStatus: status_bool_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "departments"
"""
enum departments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  departments_pkey
}

"""
input type for inserting data into table "departments"
"""
input departments_insert_input {
  abrev_code: String
  agency: agencies_obj_rel_insert_input
  agency_id: uuid
  chief_department: uuid
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  department: departments_obj_rel_insert_input
  departments: departments_arr_rel_insert_input
  employee: employees_obj_rel_insert_input
  employees: employees_arr_rel_insert_input
  id: uuid
  name: uuid
  parent_department_id: uuid
  services: services_arr_rel_insert_input
  status: status_enum
  statusByStatus: status_obj_rel_insert_input
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type departments_max_fields {
  abrev_code: String
  agency_id: uuid
  chief_department: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  parent_department_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "departments"
"""
input departments_max_order_by {
  abrev_code: order_by
  agency_id: order_by
  chief_department: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  parent_department_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type departments_min_fields {
  abrev_code: String
  agency_id: uuid
  chief_department: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  parent_department_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "departments"
"""
input departments_min_order_by {
  abrev_code: order_by
  agency_id: order_by
  chief_department: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  parent_department_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "departments"
"""
type departments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [departments!]!
}

"""
input type for inserting object relation for remote table "departments"
"""
input departments_obj_rel_insert_input {
  data: departments_insert_input!

  """upsert condition"""
  on_conflict: departments_on_conflict
}

"""
on_conflict condition type for table "departments"
"""
input departments_on_conflict {
  constraint: departments_constraint!
  update_columns: [departments_update_column!]! = []
  where: departments_bool_exp
}

"""Ordering options when selecting data from "departments"."""
input departments_order_by {
  abrev_code: order_by
  agency: agencies_order_by
  agency_id: order_by
  chief_department: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  department: departments_order_by
  departments_aggregate: departments_aggregate_order_by
  employee: employees_order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  name: order_by
  parent_department_id: order_by
  services_aggregate: services_aggregate_order_by
  status: order_by
  statusByStatus: status_order_by
  text_content: text_content_order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: departments"""
input departments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "departments"
"""
enum departments_select_column {
  """column name"""
  abrev_code

  """column name"""
  agency_id

  """column name"""
  chief_department

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_department_id

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "departments"
"""
input departments_set_input {
  abrev_code: String
  agency_id: uuid
  chief_department: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  parent_department_id: uuid
  status: status_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "departments"
"""
input departments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: departments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input departments_stream_cursor_value_input {
  abrev_code: String
  agency_id: uuid
  chief_department: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  parent_department_id: uuid
  status: status_enum
  updated_at: timestamptz
}

"""
update columns of table "departments"
"""
enum departments_update_column {
  """column name"""
  abrev_code

  """column name"""
  agency_id

  """column name"""
  chief_department

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_department_id

  """column name"""
  status

  """column name"""
  updated_at
}

input departments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: departments_set_input

  """filter the rows which have to be updated"""
  where: departments_bool_exp!
}

"""
columns and relationships of "employee_conversation"
"""
type employee_conversation {
  """An object relationship"""
  conversation: conversations!
  conversation_id: uuid!
  created_at: timestamptz

  """An object relationship"""
  employee: employees!
  employee_id: uuid!
  id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "employee_conversation"
"""
type employee_conversation_aggregate {
  aggregate: employee_conversation_aggregate_fields
  nodes: [employee_conversation!]!
}

input employee_conversation_aggregate_bool_exp {
  count: employee_conversation_aggregate_bool_exp_count
}

input employee_conversation_aggregate_bool_exp_count {
  arguments: [employee_conversation_select_column!]
  distinct: Boolean
  filter: employee_conversation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employee_conversation"
"""
type employee_conversation_aggregate_fields {
  count(columns: [employee_conversation_select_column!], distinct: Boolean): Int!
  max: employee_conversation_max_fields
  min: employee_conversation_min_fields
}

"""
order by aggregate values of table "employee_conversation"
"""
input employee_conversation_aggregate_order_by {
  count: order_by
  max: employee_conversation_max_order_by
  min: employee_conversation_min_order_by
}

"""
input type for inserting array relation for remote table "employee_conversation"
"""
input employee_conversation_arr_rel_insert_input {
  data: [employee_conversation_insert_input!]!

  """upsert condition"""
  on_conflict: employee_conversation_on_conflict
}

"""
Boolean expression to filter rows from the table "employee_conversation". All fields are combined with a logical 'AND'.
"""
input employee_conversation_bool_exp {
  _and: [employee_conversation_bool_exp!]
  _not: employee_conversation_bool_exp
  _or: [employee_conversation_bool_exp!]
  conversation: conversations_bool_exp
  conversation_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "employee_conversation"
"""
enum employee_conversation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employee_conversation_pkey
}

"""
input type for inserting data into table "employee_conversation"
"""
input employee_conversation_insert_input {
  conversation: conversations_obj_rel_insert_input
  conversation_id: uuid
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type employee_conversation_max_fields {
  conversation_id: uuid
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "employee_conversation"
"""
input employee_conversation_max_order_by {
  conversation_id: order_by
  created_at: order_by
  employee_id: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type employee_conversation_min_fields {
  conversation_id: uuid
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "employee_conversation"
"""
input employee_conversation_min_order_by {
  conversation_id: order_by
  created_at: order_by
  employee_id: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "employee_conversation"
"""
type employee_conversation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employee_conversation!]!
}

"""
on_conflict condition type for table "employee_conversation"
"""
input employee_conversation_on_conflict {
  constraint: employee_conversation_constraint!
  update_columns: [employee_conversation_update_column!]! = []
  where: employee_conversation_bool_exp
}

"""Ordering options when selecting data from "employee_conversation"."""
input employee_conversation_order_by {
  conversation: conversations_order_by
  conversation_id: order_by
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: employee_conversation"""
input employee_conversation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_conversation"
"""
enum employee_conversation_select_column {
  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "employee_conversation"
"""
input employee_conversation_set_input {
  conversation_id: uuid
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "employee_conversation"
"""
input employee_conversation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employee_conversation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employee_conversation_stream_cursor_value_input {
  conversation_id: uuid
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "employee_conversation"
"""
enum employee_conversation_update_column {
  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  updated_at
}

input employee_conversation_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employee_conversation_set_input

  """filter the rows which have to be updated"""
  where: employee_conversation_bool_exp!
}

"""
columns and relationships of "employee_notifications"
"""
type employee_notifications {
  action: String!
  created_at: timestamptz

  """An object relationship"""
  employee: employees
  employee_id: uuid

  """An object relationship"""
  event: events
  event_id: uuid
  id: uuid!
  is_read: Boolean
  message: String!

  """An object relationship"""
  messageByMessageId: messages
  message_id: uuid
  title: String!
  type: employeenotificationtype
  updated_at: timestamptz

  """An object relationship"""
  visit: visits
  visits_id: uuid
}

"""
aggregated selection of "employee_notifications"
"""
type employee_notifications_aggregate {
  aggregate: employee_notifications_aggregate_fields
  nodes: [employee_notifications!]!
}

input employee_notifications_aggregate_bool_exp {
  bool_and: employee_notifications_aggregate_bool_exp_bool_and
  bool_or: employee_notifications_aggregate_bool_exp_bool_or
  count: employee_notifications_aggregate_bool_exp_count
}

input employee_notifications_aggregate_bool_exp_bool_and {
  arguments: employee_notifications_select_column_employee_notifications_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: employee_notifications_bool_exp
  predicate: Boolean_comparison_exp!
}

input employee_notifications_aggregate_bool_exp_bool_or {
  arguments: employee_notifications_select_column_employee_notifications_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: employee_notifications_bool_exp
  predicate: Boolean_comparison_exp!
}

input employee_notifications_aggregate_bool_exp_count {
  arguments: [employee_notifications_select_column!]
  distinct: Boolean
  filter: employee_notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employee_notifications"
"""
type employee_notifications_aggregate_fields {
  count(columns: [employee_notifications_select_column!], distinct: Boolean): Int!
  max: employee_notifications_max_fields
  min: employee_notifications_min_fields
}

"""
order by aggregate values of table "employee_notifications"
"""
input employee_notifications_aggregate_order_by {
  count: order_by
  max: employee_notifications_max_order_by
  min: employee_notifications_min_order_by
}

"""
input type for inserting array relation for remote table "employee_notifications"
"""
input employee_notifications_arr_rel_insert_input {
  data: [employee_notifications_insert_input!]!

  """upsert condition"""
  on_conflict: employee_notifications_on_conflict
}

"""
Boolean expression to filter rows from the table "employee_notifications". All fields are combined with a logical 'AND'.
"""
input employee_notifications_bool_exp {
  _and: [employee_notifications_bool_exp!]
  _not: employee_notifications_bool_exp
  _or: [employee_notifications_bool_exp!]
  action: String_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  event: events_bool_exp
  event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_read: Boolean_comparison_exp
  message: String_comparison_exp
  messageByMessageId: messages_bool_exp
  message_id: uuid_comparison_exp
  title: String_comparison_exp
  type: employeenotificationtype_comparison_exp
  updated_at: timestamptz_comparison_exp
  visit: visits_bool_exp
  visits_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "employee_notifications"
"""
enum employee_notifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employee_notifications_pkey
}

"""
input type for inserting data into table "employee_notifications"
"""
input employee_notifications_insert_input {
  action: String
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  event: events_obj_rel_insert_input
  event_id: uuid
  id: uuid
  is_read: Boolean
  message: String
  messageByMessageId: messages_obj_rel_insert_input
  message_id: uuid
  title: String
  type: employeenotificationtype
  updated_at: timestamptz
  visit: visits_obj_rel_insert_input
  visits_id: uuid
}

"""aggregate max on columns"""
type employee_notifications_max_fields {
  action: String
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  message: String
  message_id: uuid
  title: String
  type: employeenotificationtype
  updated_at: timestamptz
  visits_id: uuid
}

"""
order by max() on columns of table "employee_notifications"
"""
input employee_notifications_max_order_by {
  action: order_by
  created_at: order_by
  employee_id: order_by
  event_id: order_by
  id: order_by
  message: order_by
  message_id: order_by
  title: order_by
  type: order_by
  updated_at: order_by
  visits_id: order_by
}

"""aggregate min on columns"""
type employee_notifications_min_fields {
  action: String
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  message: String
  message_id: uuid
  title: String
  type: employeenotificationtype
  updated_at: timestamptz
  visits_id: uuid
}

"""
order by min() on columns of table "employee_notifications"
"""
input employee_notifications_min_order_by {
  action: order_by
  created_at: order_by
  employee_id: order_by
  event_id: order_by
  id: order_by
  message: order_by
  message_id: order_by
  title: order_by
  type: order_by
  updated_at: order_by
  visits_id: order_by
}

"""
response of any mutation on the table "employee_notifications"
"""
type employee_notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employee_notifications!]!
}

"""
on_conflict condition type for table "employee_notifications"
"""
input employee_notifications_on_conflict {
  constraint: employee_notifications_constraint!
  update_columns: [employee_notifications_update_column!]! = []
  where: employee_notifications_bool_exp
}

"""Ordering options when selecting data from "employee_notifications"."""
input employee_notifications_order_by {
  action: order_by
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  event: events_order_by
  event_id: order_by
  id: order_by
  is_read: order_by
  message: order_by
  messageByMessageId: messages_order_by
  message_id: order_by
  title: order_by
  type: order_by
  updated_at: order_by
  visit: visits_order_by
  visits_id: order_by
}

"""primary key columns input for table: employee_notifications"""
input employee_notifications_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_notifications"
"""
enum employee_notifications_select_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  message_id

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  visits_id
}

"""
select "employee_notifications_aggregate_bool_exp_bool_and_arguments_columns" columns of table "employee_notifications"
"""
enum employee_notifications_select_column_employee_notifications_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_read
}

"""
select "employee_notifications_aggregate_bool_exp_bool_or_arguments_columns" columns of table "employee_notifications"
"""
enum employee_notifications_select_column_employee_notifications_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_read
}

"""
input type for updating data in table "employee_notifications"
"""
input employee_notifications_set_input {
  action: String
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  is_read: Boolean
  message: String
  message_id: uuid
  title: String
  type: employeenotificationtype
  updated_at: timestamptz
  visits_id: uuid
}

"""
Streaming cursor of the table "employee_notifications"
"""
input employee_notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employee_notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employee_notifications_stream_cursor_value_input {
  action: String
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  is_read: Boolean
  message: String
  message_id: uuid
  title: String
  type: employeenotificationtype
  updated_at: timestamptz
  visits_id: uuid
}

"""
update columns of table "employee_notifications"
"""
enum employee_notifications_update_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  message_id

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  visits_id
}

input employee_notifications_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employee_notifications_set_input

  """filter the rows which have to be updated"""
  where: employee_notifications_bool_exp!
}

"""
columns and relationships of "employee_roles"
"""
type employee_roles {
  created_at: timestamptz

  """An object relationship"""
  employee: employees!
  employee_id: uuid!
  id: uuid!

  """An object relationship"""
  role: roles!
  role_id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "employee_roles"
"""
type employee_roles_aggregate {
  aggregate: employee_roles_aggregate_fields
  nodes: [employee_roles!]!
}

input employee_roles_aggregate_bool_exp {
  count: employee_roles_aggregate_bool_exp_count
}

input employee_roles_aggregate_bool_exp_count {
  arguments: [employee_roles_select_column!]
  distinct: Boolean
  filter: employee_roles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employee_roles"
"""
type employee_roles_aggregate_fields {
  count(columns: [employee_roles_select_column!], distinct: Boolean): Int!
  max: employee_roles_max_fields
  min: employee_roles_min_fields
}

"""
order by aggregate values of table "employee_roles"
"""
input employee_roles_aggregate_order_by {
  count: order_by
  max: employee_roles_max_order_by
  min: employee_roles_min_order_by
}

"""
input type for inserting array relation for remote table "employee_roles"
"""
input employee_roles_arr_rel_insert_input {
  data: [employee_roles_insert_input!]!

  """upsert condition"""
  on_conflict: employee_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "employee_roles". All fields are combined with a logical 'AND'.
"""
input employee_roles_bool_exp {
  _and: [employee_roles_bool_exp!]
  _not: employee_roles_bool_exp
  _or: [employee_roles_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  role: roles_bool_exp
  role_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "employee_roles"
"""
enum employee_roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employee_roles_pkey
}

"""
input type for inserting data into table "employee_roles"
"""
input employee_roles_insert_input {
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  role: roles_obj_rel_insert_input
  role_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type employee_roles_max_fields {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "employee_roles"
"""
input employee_roles_max_order_by {
  created_at: order_by
  employee_id: order_by
  id: order_by
  role_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type employee_roles_min_fields {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "employee_roles"
"""
input employee_roles_min_order_by {
  created_at: order_by
  employee_id: order_by
  id: order_by
  role_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "employee_roles"
"""
type employee_roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employee_roles!]!
}

"""
on_conflict condition type for table "employee_roles"
"""
input employee_roles_on_conflict {
  constraint: employee_roles_constraint!
  update_columns: [employee_roles_update_column!]! = []
  where: employee_roles_bool_exp
}

"""Ordering options when selecting data from "employee_roles"."""
input employee_roles_order_by {
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  role: roles_order_by
  role_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: employee_roles"""
input employee_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_roles"
"""
enum employee_roles_select_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "employee_roles"
"""
input employee_roles_set_input {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "employee_roles"
"""
input employee_roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employee_roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employee_roles_stream_cursor_value_input {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "employee_roles"
"""
enum employee_roles_update_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  updated_at
}

input employee_roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employee_roles_set_input

  """filter the rows which have to be updated"""
  where: employee_roles_bool_exp!
}

"""
columns and relationships of "employee_shifts"
"""
type employee_shifts {
  """An object relationship"""
  employee: employees
  employee_id: uuid
  id: uuid!

  """An object relationship"""
  shift: shifts
  shift_id: uuid
}

"""
aggregated selection of "employee_shifts"
"""
type employee_shifts_aggregate {
  aggregate: employee_shifts_aggregate_fields
  nodes: [employee_shifts!]!
}

input employee_shifts_aggregate_bool_exp {
  count: employee_shifts_aggregate_bool_exp_count
}

input employee_shifts_aggregate_bool_exp_count {
  arguments: [employee_shifts_select_column!]
  distinct: Boolean
  filter: employee_shifts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employee_shifts"
"""
type employee_shifts_aggregate_fields {
  count(columns: [employee_shifts_select_column!], distinct: Boolean): Int!
  max: employee_shifts_max_fields
  min: employee_shifts_min_fields
}

"""
order by aggregate values of table "employee_shifts"
"""
input employee_shifts_aggregate_order_by {
  count: order_by
  max: employee_shifts_max_order_by
  min: employee_shifts_min_order_by
}

"""
input type for inserting array relation for remote table "employee_shifts"
"""
input employee_shifts_arr_rel_insert_input {
  data: [employee_shifts_insert_input!]!

  """upsert condition"""
  on_conflict: employee_shifts_on_conflict
}

"""
Boolean expression to filter rows from the table "employee_shifts". All fields are combined with a logical 'AND'.
"""
input employee_shifts_bool_exp {
  _and: [employee_shifts_bool_exp!]
  _not: employee_shifts_bool_exp
  _or: [employee_shifts_bool_exp!]
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  shift: shifts_bool_exp
  shift_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "employee_shifts"
"""
enum employee_shifts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employee_shifts_pkey
}

"""
input type for inserting data into table "employee_shifts"
"""
input employee_shifts_insert_input {
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  shift: shifts_obj_rel_insert_input
  shift_id: uuid
}

"""aggregate max on columns"""
type employee_shifts_max_fields {
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
order by max() on columns of table "employee_shifts"
"""
input employee_shifts_max_order_by {
  employee_id: order_by
  id: order_by
  shift_id: order_by
}

"""aggregate min on columns"""
type employee_shifts_min_fields {
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
order by min() on columns of table "employee_shifts"
"""
input employee_shifts_min_order_by {
  employee_id: order_by
  id: order_by
  shift_id: order_by
}

"""
response of any mutation on the table "employee_shifts"
"""
type employee_shifts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employee_shifts!]!
}

"""
on_conflict condition type for table "employee_shifts"
"""
input employee_shifts_on_conflict {
  constraint: employee_shifts_constraint!
  update_columns: [employee_shifts_update_column!]! = []
  where: employee_shifts_bool_exp
}

"""Ordering options when selecting data from "employee_shifts"."""
input employee_shifts_order_by {
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  shift: shifts_order_by
  shift_id: order_by
}

"""primary key columns input for table: employee_shifts"""
input employee_shifts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_shifts"
"""
enum employee_shifts_select_column {
  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  shift_id
}

"""
input type for updating data in table "employee_shifts"
"""
input employee_shifts_set_input {
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
Streaming cursor of the table "employee_shifts"
"""
input employee_shifts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employee_shifts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employee_shifts_stream_cursor_value_input {
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
update columns of table "employee_shifts"
"""
enum employee_shifts_update_column {
  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  shift_id
}

input employee_shifts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employee_shifts_set_input

  """filter the rows which have to be updated"""
  where: employee_shifts_bool_exp!
}

input EmployeeAppointmentId {
  id: UUID!
}

type EmployeeAttendatceType {
  firstname: String!
  id: UUID!
  lastname: String!
}

type EmployeeCreationType {
  firstname: String!
  id: UUID!
  lastname: String!
  phoneNumber: String!
}

input EmployeeId {
  id: UUID!
}

scalar employeenotificationtype

"""
Boolean expression to compare columns of type "employeenotificationtype". All fields are combined with logical 'AND'.
"""
input employeenotificationtype_comparison_exp {
  _eq: employeenotificationtype
  _gt: employeenotificationtype
  _gte: employeenotificationtype
  _in: [employeenotificationtype!]
  _is_null: Boolean
  _lt: employeenotificationtype
  _lte: employeenotificationtype
  _neq: employeenotificationtype
  _nin: [employeenotificationtype!]
}

type EmployeeOnLeave {
  total: Int!
}

type EmployeeRole {
  createdAt: DateTime
  employeeId: UUID
  id: UUID
  role: RoleType!
  roleId: UUID
  updatedAt: DateTime
}

"""
columns and relationships of "employees"
"""
type employees {
  address: String

  """An object relationship"""
  agency: agencies
  agency_id: uuid

  """An array relationship"""
  alarms(
    """distinct select on columns"""
    distinct_on: [alarms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alarms_order_by!]

    """filter the rows returned"""
    where: alarms_bool_exp
  ): [alarms!]!

  """An aggregate relationship"""
  alarms_aggregate(
    """distinct select on columns"""
    distinct_on: [alarms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alarms_order_by!]

    """filter the rows returned"""
    where: alarms_bool_exp
  ): alarms_aggregate!

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!

  """An object relationship"""
  attendance: attendance

  """An object relationship"""
  company: companies!
  company_id: uuid!
  created_at: timestamptz

  """An object relationship"""
  department: departments!
  department_id: uuid!

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!
  email: String

  """An object relationship"""
  employee: employees

  """An array relationship"""
  employee_conversations(
    """distinct select on columns"""
    distinct_on: [employee_conversation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_conversation_order_by!]

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): [employee_conversation!]!

  """An aggregate relationship"""
  employee_conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_conversation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_conversation_order_by!]

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): employee_conversation_aggregate!

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!

  """An array relationship"""
  employee_roles(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An aggregate relationship"""
  employee_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): employee_roles_aggregate!

  """An array relationship"""
  employee_shifts(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An aggregate relationship"""
  employee_shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): employee_shifts_aggregate!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """An array relationship"""
  event_notifications(
    """distinct select on columns"""
    distinct_on: [event_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_notification_order_by!]

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): [event_notification!]!

  """An aggregate relationship"""
  event_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [event_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_notification_order_by!]

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): event_notification_aggregate!

  """An array relationship"""
  event_participants(
    """distinct select on columns"""
    distinct_on: [event_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_participants_order_by!]

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): [event_participants!]!

  """An aggregate relationship"""
  event_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [event_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_participants_order_by!]

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): event_participants_aggregate!

  """An array relationship"""
  events(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """An aggregate relationship"""
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): events_aggregate!

  """An object relationship"""
  file: files
  firebase_token: String
  firstname: String!
  function: String!

  """An array relationship"""
  group_members(
    """distinct select on columns"""
    distinct_on: [group_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_members_order_by!]

    """filter the rows returned"""
    where: group_members_bool_exp
  ): [group_members!]!

  """An aggregate relationship"""
  group_members_aggregate(
    """distinct select on columns"""
    distinct_on: [group_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_members_order_by!]

    """filter the rows returned"""
    where: group_members_bool_exp
  ): group_members_aggregate!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!
  id: uuid!
  id_card_number: String
  lastname: String!

  """An array relationship"""
  leave_approvals(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """An aggregate relationship"""
  leave_approvals_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!
  license: String

  """An array relationship"""
  message_statuses(
    """distinct select on columns"""
    distinct_on: [message_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_statuses_order_by!]

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): [message_statuses!]!

  """An aggregate relationship"""
  message_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [message_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_statuses_order_by!]

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): message_statuses_aggregate!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!
  password: String!
  password_change_at: timestamptz
  phone_number: String

  """An object relationship"""
  position: positions
  position_id: uuid
  profile_picture: uuid
  region: String

  """An object relationship"""
  service: services
  service_id: uuid

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  status: status_enum

  """An object relationship"""
  statusByStatus: status
  supervisor_id: uuid

  """An array relationship"""
  task_statuses(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): [task_status!]!

  """An aggregate relationship"""
  task_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): task_status_aggregate!

  """An array relationship"""
  tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """An array relationship"""
  tasksByAssignedTo(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """An aggregate relationship"""
  tasksByAssignedTo_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!

  """An aggregate relationship"""
  tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!

  """An array relationship"""
  typing_statuses(
    """distinct select on columns"""
    distinct_on: [typing_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [typing_statuses_order_by!]

    """filter the rows returned"""
    where: typing_statuses_bool_exp
  ): [typing_statuses!]!

  """An aggregate relationship"""
  typing_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [typing_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [typing_statuses_order_by!]

    """filter the rows returned"""
    where: typing_statuses_bool_exp
  ): typing_statuses_aggregate!
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "employees"
"""
type employees_aggregate {
  aggregate: employees_aggregate_fields
  nodes: [employees!]!
}

input employees_aggregate_bool_exp {
  count: employees_aggregate_bool_exp_count
}

input employees_aggregate_bool_exp_count {
  arguments: [employees_select_column!]
  distinct: Boolean
  filter: employees_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employees"
"""
type employees_aggregate_fields {
  count(columns: [employees_select_column!], distinct: Boolean): Int!
  max: employees_max_fields
  min: employees_min_fields
}

"""
order by aggregate values of table "employees"
"""
input employees_aggregate_order_by {
  count: order_by
  max: employees_max_order_by
  min: employees_min_order_by
}

"""
input type for inserting array relation for remote table "employees"
"""
input employees_arr_rel_insert_input {
  data: [employees_insert_input!]!

  """upsert condition"""
  on_conflict: employees_on_conflict
}

"""
Boolean expression to filter rows from the table "employees". All fields are combined with a logical 'AND'.
"""
input employees_bool_exp {
  _and: [employees_bool_exp!]
  _not: employees_bool_exp
  _or: [employees_bool_exp!]
  address: String_comparison_exp
  agency: agencies_bool_exp
  agency_id: uuid_comparison_exp
  alarms: alarms_bool_exp
  alarms_aggregate: alarms_aggregate_bool_exp
  appointments: appointments_bool_exp
  appointments_aggregate: appointments_aggregate_bool_exp
  attendance: attendance_bool_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  department: departments_bool_exp
  department_id: uuid_comparison_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  email: String_comparison_exp
  employee: employees_bool_exp
  employee_conversations: employee_conversation_bool_exp
  employee_conversations_aggregate: employee_conversation_aggregate_bool_exp
  employee_notifications: employee_notifications_bool_exp
  employee_notifications_aggregate: employee_notifications_aggregate_bool_exp
  employee_roles: employee_roles_bool_exp
  employee_roles_aggregate: employee_roles_aggregate_bool_exp
  employee_shifts: employee_shifts_bool_exp
  employee_shifts_aggregate: employee_shifts_aggregate_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  event_notifications: event_notification_bool_exp
  event_notifications_aggregate: event_notification_aggregate_bool_exp
  event_participants: event_participants_bool_exp
  event_participants_aggregate: event_participants_aggregate_bool_exp
  events: events_bool_exp
  events_aggregate: events_aggregate_bool_exp
  file: files_bool_exp
  firebase_token: String_comparison_exp
  firstname: String_comparison_exp
  function: String_comparison_exp
  group_members: group_members_bool_exp
  group_members_aggregate: group_members_aggregate_bool_exp
  groups: groups_bool_exp
  groups_aggregate: groups_aggregate_bool_exp
  id: uuid_comparison_exp
  id_card_number: String_comparison_exp
  lastname: String_comparison_exp
  leave_approvals: leave_approval_bool_exp
  leave_approvals_aggregate: leave_approval_aggregate_bool_exp
  leaves: leaves_bool_exp
  leaves_aggregate: leaves_aggregate_bool_exp
  license: String_comparison_exp
  message_statuses: message_statuses_bool_exp
  message_statuses_aggregate: message_statuses_aggregate_bool_exp
  messages: messages_bool_exp
  messages_aggregate: messages_aggregate_bool_exp
  password: String_comparison_exp
  password_change_at: timestamptz_comparison_exp
  phone_number: String_comparison_exp
  position: positions_bool_exp
  position_id: uuid_comparison_exp
  profile_picture: uuid_comparison_exp
  region: String_comparison_exp
  service: services_bool_exp
  service_id: uuid_comparison_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  status: status_enum_comparison_exp
  statusByStatus: status_bool_exp
  supervisor_id: uuid_comparison_exp
  task_statuses: task_status_bool_exp
  task_statuses_aggregate: task_status_aggregate_bool_exp
  tasks: tasks_bool_exp
  tasksByAssignedTo: tasks_bool_exp
  tasksByAssignedTo_aggregate: tasks_aggregate_bool_exp
  tasks_aggregate: tasks_aggregate_bool_exp
  typing_statuses: typing_statuses_bool_exp
  typing_statuses_aggregate: typing_statuses_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "employees"
"""
enum employees_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  employees_email_key

  """
  unique or primary key constraint on columns "id"
  """
  employees_pkey
}

"""
input type for inserting data into table "employees"
"""
input employees_insert_input {
  address: String
  agency: agencies_obj_rel_insert_input
  agency_id: uuid
  alarms: alarms_arr_rel_insert_input
  appointments: appointments_arr_rel_insert_input
  attendance: attendance_obj_rel_insert_input
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  department: departments_obj_rel_insert_input
  department_id: uuid
  departments: departments_arr_rel_insert_input
  email: String
  employee: employees_obj_rel_insert_input
  employee_conversations: employee_conversation_arr_rel_insert_input
  employee_notifications: employee_notifications_arr_rel_insert_input
  employee_roles: employee_roles_arr_rel_insert_input
  employee_shifts: employee_shifts_arr_rel_insert_input
  employees: employees_arr_rel_insert_input
  event_notifications: event_notification_arr_rel_insert_input
  event_participants: event_participants_arr_rel_insert_input
  events: events_arr_rel_insert_input
  file: files_obj_rel_insert_input
  firebase_token: String
  firstname: String
  function: String
  group_members: group_members_arr_rel_insert_input
  groups: groups_arr_rel_insert_input
  id: uuid
  id_card_number: String
  lastname: String
  leave_approvals: leave_approval_arr_rel_insert_input
  leaves: leaves_arr_rel_insert_input
  license: String
  message_statuses: message_statuses_arr_rel_insert_input
  messages: messages_arr_rel_insert_input
  password: String
  password_change_at: timestamptz
  phone_number: String
  position: positions_obj_rel_insert_input
  position_id: uuid
  profile_picture: uuid
  region: String
  service: services_obj_rel_insert_input
  service_id: uuid
  services: services_arr_rel_insert_input
  status: status_enum
  statusByStatus: status_obj_rel_insert_input
  supervisor_id: uuid
  task_statuses: task_status_arr_rel_insert_input
  tasks: tasks_arr_rel_insert_input
  tasksByAssignedTo: tasks_arr_rel_insert_input
  typing_statuses: typing_statuses_arr_rel_insert_input
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type employees_max_fields {
  address: String
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  email: String
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  license: String
  password: String
  password_change_at: timestamptz
  phone_number: String
  position_id: uuid
  profile_picture: uuid
  region: String
  service_id: uuid
  supervisor_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "employees"
"""
input employees_max_order_by {
  address: order_by
  agency_id: order_by
  company_id: order_by
  created_at: order_by
  department_id: order_by
  email: order_by
  firebase_token: order_by
  firstname: order_by
  function: order_by
  id: order_by
  id_card_number: order_by
  lastname: order_by
  license: order_by
  password: order_by
  password_change_at: order_by
  phone_number: order_by
  position_id: order_by
  profile_picture: order_by
  region: order_by
  service_id: order_by
  supervisor_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type employees_min_fields {
  address: String
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  email: String
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  license: String
  password: String
  password_change_at: timestamptz
  phone_number: String
  position_id: uuid
  profile_picture: uuid
  region: String
  service_id: uuid
  supervisor_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "employees"
"""
input employees_min_order_by {
  address: order_by
  agency_id: order_by
  company_id: order_by
  created_at: order_by
  department_id: order_by
  email: order_by
  firebase_token: order_by
  firstname: order_by
  function: order_by
  id: order_by
  id_card_number: order_by
  lastname: order_by
  license: order_by
  password: order_by
  password_change_at: order_by
  phone_number: order_by
  position_id: order_by
  profile_picture: order_by
  region: order_by
  service_id: order_by
  supervisor_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "employees"
"""
type employees_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employees!]!
}

"""
input type for inserting object relation for remote table "employees"
"""
input employees_obj_rel_insert_input {
  data: employees_insert_input!

  """upsert condition"""
  on_conflict: employees_on_conflict
}

"""
on_conflict condition type for table "employees"
"""
input employees_on_conflict {
  constraint: employees_constraint!
  update_columns: [employees_update_column!]! = []
  where: employees_bool_exp
}

"""Ordering options when selecting data from "employees"."""
input employees_order_by {
  address: order_by
  agency: agencies_order_by
  agency_id: order_by
  alarms_aggregate: alarms_aggregate_order_by
  appointments_aggregate: appointments_aggregate_order_by
  attendance: attendance_order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  department: departments_order_by
  department_id: order_by
  departments_aggregate: departments_aggregate_order_by
  email: order_by
  employee: employees_order_by
  employee_conversations_aggregate: employee_conversation_aggregate_order_by
  employee_notifications_aggregate: employee_notifications_aggregate_order_by
  employee_roles_aggregate: employee_roles_aggregate_order_by
  employee_shifts_aggregate: employee_shifts_aggregate_order_by
  employees_aggregate: employees_aggregate_order_by
  event_notifications_aggregate: event_notification_aggregate_order_by
  event_participants_aggregate: event_participants_aggregate_order_by
  events_aggregate: events_aggregate_order_by
  file: files_order_by
  firebase_token: order_by
  firstname: order_by
  function: order_by
  group_members_aggregate: group_members_aggregate_order_by
  groups_aggregate: groups_aggregate_order_by
  id: order_by
  id_card_number: order_by
  lastname: order_by
  leave_approvals_aggregate: leave_approval_aggregate_order_by
  leaves_aggregate: leaves_aggregate_order_by
  license: order_by
  message_statuses_aggregate: message_statuses_aggregate_order_by
  messages_aggregate: messages_aggregate_order_by
  password: order_by
  password_change_at: order_by
  phone_number: order_by
  position: positions_order_by
  position_id: order_by
  profile_picture: order_by
  region: order_by
  service: services_order_by
  service_id: order_by
  services_aggregate: services_aggregate_order_by
  status: order_by
  statusByStatus: status_order_by
  supervisor_id: order_by
  task_statuses_aggregate: task_status_aggregate_order_by
  tasksByAssignedTo_aggregate: tasks_aggregate_order_by
  tasks_aggregate: tasks_aggregate_order_by
  typing_statuses_aggregate: typing_statuses_aggregate_order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: employees"""
input employees_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employees"
"""
enum employees_select_column {
  """column name"""
  address

  """column name"""
  agency_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  department_id

  """column name"""
  email

  """column name"""
  firebase_token

  """column name"""
  firstname

  """column name"""
  function

  """column name"""
  id

  """column name"""
  id_card_number

  """column name"""
  lastname

  """column name"""
  license

  """column name"""
  password

  """column name"""
  password_change_at

  """column name"""
  phone_number

  """column name"""
  position_id

  """column name"""
  profile_picture

  """column name"""
  region

  """column name"""
  service_id

  """column name"""
  status

  """column name"""
  supervisor_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "employees"
"""
input employees_set_input {
  address: String
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  email: String
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  license: String
  password: String
  password_change_at: timestamptz
  phone_number: String
  position_id: uuid
  profile_picture: uuid
  region: String
  service_id: uuid
  status: status_enum
  supervisor_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "employees"
"""
input employees_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employees_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employees_stream_cursor_value_input {
  address: String
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  email: String
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  license: String
  password: String
  password_change_at: timestamptz
  phone_number: String
  position_id: uuid
  profile_picture: uuid
  region: String
  service_id: uuid
  status: status_enum
  supervisor_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "employees"
"""
enum employees_update_column {
  """column name"""
  address

  """column name"""
  agency_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  department_id

  """column name"""
  email

  """column name"""
  firebase_token

  """column name"""
  firstname

  """column name"""
  function

  """column name"""
  id

  """column name"""
  id_card_number

  """column name"""
  lastname

  """column name"""
  license

  """column name"""
  password

  """column name"""
  password_change_at

  """column name"""
  phone_number

  """column name"""
  position_id

  """column name"""
  profile_picture

  """column name"""
  region

  """column name"""
  service_id

  """column name"""
  status

  """column name"""
  supervisor_id

  """column name"""
  updated_at
}

input employees_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employees_set_input

  """filter the rows which have to be updated"""
  where: employees_bool_exp!
}

type EmployeeType {
  agencyId: UUID
  companyId: UUID
  createdAt: DateTime
  departmentId: UUID
  email: String
  firstname: String
  function: String
  id: UUID!
  lastname: String
  password: String
  phoneNumber: String
  position: PositionType
  positionId: UUID
  profilePicture: UUID
  roles: [EmployeeRole!]
  serviceId: UUID
  supervisorId: UUID
  updatedAt: DateTime
}

type EmployeeUpdateType {
  address: String
  firstname: String
  id: UUID
  lastname: String
  phoneNumber: String
}

"""
columns and relationships of "event_notification"
"""
type event_notification {
  created_at: timestamptz

  """An object relationship"""
  employee: employees!
  employee_id: uuid!

  """An object relationship"""
  event: events!
  event_id: uuid!
  id: uuid!
  message: String
  read: Boolean
  updated_at: timestamptz
}

"""
aggregated selection of "event_notification"
"""
type event_notification_aggregate {
  aggregate: event_notification_aggregate_fields
  nodes: [event_notification!]!
}

input event_notification_aggregate_bool_exp {
  bool_and: event_notification_aggregate_bool_exp_bool_and
  bool_or: event_notification_aggregate_bool_exp_bool_or
  count: event_notification_aggregate_bool_exp_count
}

input event_notification_aggregate_bool_exp_bool_and {
  arguments: event_notification_select_column_event_notification_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: event_notification_bool_exp
  predicate: Boolean_comparison_exp!
}

input event_notification_aggregate_bool_exp_bool_or {
  arguments: event_notification_select_column_event_notification_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: event_notification_bool_exp
  predicate: Boolean_comparison_exp!
}

input event_notification_aggregate_bool_exp_count {
  arguments: [event_notification_select_column!]
  distinct: Boolean
  filter: event_notification_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "event_notification"
"""
type event_notification_aggregate_fields {
  count(columns: [event_notification_select_column!], distinct: Boolean): Int!
  max: event_notification_max_fields
  min: event_notification_min_fields
}

"""
order by aggregate values of table "event_notification"
"""
input event_notification_aggregate_order_by {
  count: order_by
  max: event_notification_max_order_by
  min: event_notification_min_order_by
}

"""
input type for inserting array relation for remote table "event_notification"
"""
input event_notification_arr_rel_insert_input {
  data: [event_notification_insert_input!]!

  """upsert condition"""
  on_conflict: event_notification_on_conflict
}

"""
Boolean expression to filter rows from the table "event_notification". All fields are combined with a logical 'AND'.
"""
input event_notification_bool_exp {
  _and: [event_notification_bool_exp!]
  _not: event_notification_bool_exp
  _or: [event_notification_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  event: events_bool_exp
  event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  message: String_comparison_exp
  read: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "event_notification"
"""
enum event_notification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_notification_pkey
}

"""
input type for inserting data into table "event_notification"
"""
input event_notification_insert_input {
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  event: events_obj_rel_insert_input
  event_id: uuid
  id: uuid
  message: String
  read: Boolean
  updated_at: timestamptz
}

"""aggregate max on columns"""
type event_notification_max_fields {
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  message: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "event_notification"
"""
input event_notification_max_order_by {
  created_at: order_by
  employee_id: order_by
  event_id: order_by
  id: order_by
  message: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type event_notification_min_fields {
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  message: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "event_notification"
"""
input event_notification_min_order_by {
  created_at: order_by
  employee_id: order_by
  event_id: order_by
  id: order_by
  message: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "event_notification"
"""
type event_notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [event_notification!]!
}

"""
on_conflict condition type for table "event_notification"
"""
input event_notification_on_conflict {
  constraint: event_notification_constraint!
  update_columns: [event_notification_update_column!]! = []
  where: event_notification_bool_exp
}

"""Ordering options when selecting data from "event_notification"."""
input event_notification_order_by {
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  event: events_order_by
  event_id: order_by
  id: order_by
  message: order_by
  read: order_by
  updated_at: order_by
}

"""primary key columns input for table: event_notification"""
input event_notification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "event_notification"
"""
enum event_notification_select_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  message

  """column name"""
  read

  """column name"""
  updated_at
}

"""
select "event_notification_aggregate_bool_exp_bool_and_arguments_columns" columns of table "event_notification"
"""
enum event_notification_select_column_event_notification_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  read
}

"""
select "event_notification_aggregate_bool_exp_bool_or_arguments_columns" columns of table "event_notification"
"""
enum event_notification_select_column_event_notification_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  read
}

"""
input type for updating data in table "event_notification"
"""
input event_notification_set_input {
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  message: String
  read: Boolean
  updated_at: timestamptz
}

"""
Streaming cursor of the table "event_notification"
"""
input event_notification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: event_notification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input event_notification_stream_cursor_value_input {
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  message: String
  read: Boolean
  updated_at: timestamptz
}

"""
update columns of table "event_notification"
"""
enum event_notification_update_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  message

  """column name"""
  read

  """column name"""
  updated_at
}

input event_notification_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: event_notification_set_input

  """filter the rows which have to be updated"""
  where: event_notification_bool_exp!
}

"""
columns and relationships of "event_participants"
"""
type event_participants {
  created_at: timestamptz

  """An object relationship"""
  employee: employees!
  employee_id: uuid!

  """An object relationship"""
  event: events!
  event_id: uuid!
  id: uuid!
  status: participantstatus
  updated_at: timestamptz
}

"""
aggregated selection of "event_participants"
"""
type event_participants_aggregate {
  aggregate: event_participants_aggregate_fields
  nodes: [event_participants!]!
}

input event_participants_aggregate_bool_exp {
  count: event_participants_aggregate_bool_exp_count
}

input event_participants_aggregate_bool_exp_count {
  arguments: [event_participants_select_column!]
  distinct: Boolean
  filter: event_participants_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "event_participants"
"""
type event_participants_aggregate_fields {
  count(columns: [event_participants_select_column!], distinct: Boolean): Int!
  max: event_participants_max_fields
  min: event_participants_min_fields
}

"""
order by aggregate values of table "event_participants"
"""
input event_participants_aggregate_order_by {
  count: order_by
  max: event_participants_max_order_by
  min: event_participants_min_order_by
}

"""
input type for inserting array relation for remote table "event_participants"
"""
input event_participants_arr_rel_insert_input {
  data: [event_participants_insert_input!]!

  """upsert condition"""
  on_conflict: event_participants_on_conflict
}

"""
Boolean expression to filter rows from the table "event_participants". All fields are combined with a logical 'AND'.
"""
input event_participants_bool_exp {
  _and: [event_participants_bool_exp!]
  _not: event_participants_bool_exp
  _or: [event_participants_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  event: events_bool_exp
  event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  status: participantstatus_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "event_participants"
"""
enum event_participants_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_participants_pkey
}

"""
input type for inserting data into table "event_participants"
"""
input event_participants_insert_input {
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  event: events_obj_rel_insert_input
  event_id: uuid
  id: uuid
  status: participantstatus
  updated_at: timestamptz
}

"""aggregate max on columns"""
type event_participants_max_fields {
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  status: participantstatus
  updated_at: timestamptz
}

"""
order by max() on columns of table "event_participants"
"""
input event_participants_max_order_by {
  created_at: order_by
  employee_id: order_by
  event_id: order_by
  id: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type event_participants_min_fields {
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  status: participantstatus
  updated_at: timestamptz
}

"""
order by min() on columns of table "event_participants"
"""
input event_participants_min_order_by {
  created_at: order_by
  employee_id: order_by
  event_id: order_by
  id: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "event_participants"
"""
type event_participants_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [event_participants!]!
}

"""
on_conflict condition type for table "event_participants"
"""
input event_participants_on_conflict {
  constraint: event_participants_constraint!
  update_columns: [event_participants_update_column!]! = []
  where: event_participants_bool_exp
}

"""Ordering options when selecting data from "event_participants"."""
input event_participants_order_by {
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  event: events_order_by
  event_id: order_by
  id: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: event_participants"""
input event_participants_pk_columns_input {
  id: uuid!
}

"""
select columns of table "event_participants"
"""
enum event_participants_select_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "event_participants"
"""
input event_participants_set_input {
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  status: participantstatus
  updated_at: timestamptz
}

"""
Streaming cursor of the table "event_participants"
"""
input event_participants_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: event_participants_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input event_participants_stream_cursor_value_input {
  created_at: timestamptz
  employee_id: uuid
  event_id: uuid
  id: uuid
  status: participantstatus
  updated_at: timestamptz
}

"""
update columns of table "event_participants"
"""
enum event_participants_update_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  status

  """column name"""
  updated_at
}

input event_participants_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: event_participants_set_input

  """filter the rows which have to be updated"""
  where: event_participants_bool_exp!
}

input EventByUserInput {
  date: Date!
  employeeId: UUID!
}

"""
columns and relationships of "events"
"""
type events {
  """An array relationship"""
  alarms(
    """distinct select on columns"""
    distinct_on: [alarms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alarms_order_by!]

    """filter the rows returned"""
    where: alarms_bool_exp
  ): [alarms!]!

  """An aggregate relationship"""
  alarms_aggregate(
    """distinct select on columns"""
    distinct_on: [alarms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alarms_order_by!]

    """filter the rows returned"""
    where: alarms_bool_exp
  ): alarms_aggregate!
  created_at: timestamptz
  description: String

  """An object relationship"""
  employee: employees!

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!
  end_date: date
  end_time: time

  """An array relationship"""
  event_notifications(
    """distinct select on columns"""
    distinct_on: [event_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_notification_order_by!]

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): [event_notification!]!

  """An aggregate relationship"""
  event_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [event_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_notification_order_by!]

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): event_notification_aggregate!

  """An array relationship"""
  event_participants(
    """distinct select on columns"""
    distinct_on: [event_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_participants_order_by!]

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): [event_participants!]!

  """An aggregate relationship"""
  event_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [event_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_participants_order_by!]

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): event_participants_aggregate!
  id: uuid!
  orgenizer_id: uuid!
  start_date: date
  start_time: time

  """An array relationship"""
  tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """An aggregate relationship"""
  tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!
  title: String!
  updated_at: timestamptz
}

"""
aggregated selection of "events"
"""
type events_aggregate {
  aggregate: events_aggregate_fields
  nodes: [events!]!
}

input events_aggregate_bool_exp {
  count: events_aggregate_bool_exp_count
}

input events_aggregate_bool_exp_count {
  arguments: [events_select_column!]
  distinct: Boolean
  filter: events_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "events"
"""
type events_aggregate_fields {
  count(columns: [events_select_column!], distinct: Boolean): Int!
  max: events_max_fields
  min: events_min_fields
}

"""
order by aggregate values of table "events"
"""
input events_aggregate_order_by {
  count: order_by
  max: events_max_order_by
  min: events_min_order_by
}

"""
input type for inserting array relation for remote table "events"
"""
input events_arr_rel_insert_input {
  data: [events_insert_input!]!

  """upsert condition"""
  on_conflict: events_on_conflict
}

"""
Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'.
"""
input events_bool_exp {
  _and: [events_bool_exp!]
  _not: events_bool_exp
  _or: [events_bool_exp!]
  alarms: alarms_bool_exp
  alarms_aggregate: alarms_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  employee: employees_bool_exp
  employee_notifications: employee_notifications_bool_exp
  employee_notifications_aggregate: employee_notifications_aggregate_bool_exp
  end_date: date_comparison_exp
  end_time: time_comparison_exp
  event_notifications: event_notification_bool_exp
  event_notifications_aggregate: event_notification_aggregate_bool_exp
  event_participants: event_participants_bool_exp
  event_participants_aggregate: event_participants_aggregate_bool_exp
  id: uuid_comparison_exp
  orgenizer_id: uuid_comparison_exp
  start_date: date_comparison_exp
  start_time: time_comparison_exp
  tasks: tasks_bool_exp
  tasks_aggregate: tasks_aggregate_bool_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "events"
"""
enum events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  events_pkey
}

"""
input type for inserting data into table "events"
"""
input events_insert_input {
  alarms: alarms_arr_rel_insert_input
  created_at: timestamptz
  description: String
  employee: employees_obj_rel_insert_input
  employee_notifications: employee_notifications_arr_rel_insert_input
  end_date: date
  end_time: time
  event_notifications: event_notification_arr_rel_insert_input
  event_participants: event_participants_arr_rel_insert_input
  id: uuid
  orgenizer_id: uuid
  start_date: date
  start_time: time
  tasks: tasks_arr_rel_insert_input
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type events_max_fields {
  created_at: timestamptz
  description: String
  end_date: date
  id: uuid
  orgenizer_id: uuid
  start_date: date
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "events"
"""
input events_max_order_by {
  created_at: order_by
  description: order_by
  end_date: order_by
  id: order_by
  orgenizer_id: order_by
  start_date: order_by
  title: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type events_min_fields {
  created_at: timestamptz
  description: String
  end_date: date
  id: uuid
  orgenizer_id: uuid
  start_date: date
  title: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "events"
"""
input events_min_order_by {
  created_at: order_by
  description: order_by
  end_date: order_by
  id: order_by
  orgenizer_id: order_by
  start_date: order_by
  title: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "events"
"""
type events_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [events!]!
}

"""
input type for inserting object relation for remote table "events"
"""
input events_obj_rel_insert_input {
  data: events_insert_input!

  """upsert condition"""
  on_conflict: events_on_conflict
}

"""
on_conflict condition type for table "events"
"""
input events_on_conflict {
  constraint: events_constraint!
  update_columns: [events_update_column!]! = []
  where: events_bool_exp
}

"""Ordering options when selecting data from "events"."""
input events_order_by {
  alarms_aggregate: alarms_aggregate_order_by
  created_at: order_by
  description: order_by
  employee: employees_order_by
  employee_notifications_aggregate: employee_notifications_aggregate_order_by
  end_date: order_by
  end_time: order_by
  event_notifications_aggregate: event_notification_aggregate_order_by
  event_participants_aggregate: event_participants_aggregate_order_by
  id: order_by
  orgenizer_id: order_by
  start_date: order_by
  start_time: order_by
  tasks_aggregate: tasks_aggregate_order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: events"""
input events_pk_columns_input {
  id: uuid!
}

"""
select columns of table "events"
"""
enum events_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  orgenizer_id

  """column name"""
  start_date

  """column name"""
  start_time

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "events"
"""
input events_set_input {
  created_at: timestamptz
  description: String
  end_date: date
  end_time: time
  id: uuid
  orgenizer_id: uuid
  start_date: date
  start_time: time
  title: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "events"
"""
input events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input events_stream_cursor_value_input {
  created_at: timestamptz
  description: String
  end_date: date
  end_time: time
  id: uuid
  orgenizer_id: uuid
  start_date: date
  start_time: time
  title: String
  updated_at: timestamptz
}

"""
update columns of table "events"
"""
enum events_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  orgenizer_id

  """column name"""
  start_date

  """column name"""
  start_time

  """column name"""
  title

  """column name"""
  updated_at
}

input events_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: events_set_input

  """filter the rows which have to be updated"""
  where: events_bool_exp!
}

type EventType {
  date: String!
  description: String!
  endTime: String!
  startTime: String!
  title: String!
}

type EventWithUserParticipant {
  event: EventType!
  participant: [ParticipantType!]!
}

"""
columns and relationships of "files"
"""
type files {
  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  file_name: String
  file_size: float8
  file_url: String
  id: uuid!
  mime_type: String

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An array relationship"""
  visitorsByFrontId(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitorsByFrontId_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!

  """An array relationship"""
  visitorsByPhoto(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitorsByPhoto_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!
}

"""
aggregated selection of "files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

"""
aggregate fields of "files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""aggregate avg on columns"""
type files_avg_fields {
  file_size: Float
}

"""
Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  file_name: String_comparison_exp
  file_size: float8_comparison_exp
  file_url: String_comparison_exp
  id: uuid_comparison_exp
  mime_type: String_comparison_exp
  visitors: visitors_bool_exp
  visitorsByFrontId: visitors_bool_exp
  visitorsByFrontId_aggregate: visitors_aggregate_bool_exp
  visitorsByPhoto: visitors_bool_exp
  visitorsByPhoto_aggregate: visitors_aggregate_bool_exp
  visitors_aggregate: visitors_aggregate_bool_exp
}

"""
unique or primary key constraints on table "files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
input type for incrementing numeric columns in table "files"
"""
input files_inc_input {
  file_size: float8
}

"""
input type for inserting data into table "files"
"""
input files_insert_input {
  employees: employees_arr_rel_insert_input
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
  visitors: visitors_arr_rel_insert_input
  visitorsByFrontId: visitors_arr_rel_insert_input
  visitorsByPhoto: visitors_arr_rel_insert_input
}

"""aggregate max on columns"""
type files_max_fields {
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
}

"""aggregate min on columns"""
type files_min_fields {
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
}

"""
response of any mutation on the table "files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
input type for inserting object relation for remote table "files"
"""
input files_obj_rel_insert_input {
  data: files_insert_input!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""
on_conflict condition type for table "files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "files"."""
input files_order_by {
  employees_aggregate: employees_aggregate_order_by
  file_name: order_by
  file_size: order_by
  file_url: order_by
  id: order_by
  mime_type: order_by
  visitorsByFrontId_aggregate: visitors_aggregate_order_by
  visitorsByPhoto_aggregate: visitors_aggregate_order_by
  visitors_aggregate: visitors_aggregate_order_by
}

"""primary key columns input for table: files"""
input files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "files"
"""
enum files_select_column {
  """column name"""
  file_name

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  mime_type
}

"""
input type for updating data in table "files"
"""
input files_set_input {
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  file_size: Float
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  file_size: Float
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  file_size: Float
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
}

"""aggregate sum on columns"""
type files_sum_fields {
  file_size: float8
}

"""
update columns of table "files"
"""
enum files_update_column {
  """column name"""
  file_name

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  mime_type
}

input files_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input

  """filter the rows which have to be updated"""
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  file_size: Float
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  file_size: Float
}

"""aggregate variance on columns"""
type files_variance_fields {
  file_size: Float
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
columns and relationships of "gender"
"""
type gender {
  gender: String!

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!
}

"""
aggregated selection of "gender"
"""
type gender_aggregate {
  aggregate: gender_aggregate_fields
  nodes: [gender!]!
}

"""
aggregate fields of "gender"
"""
type gender_aggregate_fields {
  count(columns: [gender_select_column!], distinct: Boolean): Int!
  max: gender_max_fields
  min: gender_min_fields
}

"""
Boolean expression to filter rows from the table "gender". All fields are combined with a logical 'AND'.
"""
input gender_bool_exp {
  _and: [gender_bool_exp!]
  _not: gender_bool_exp
  _or: [gender_bool_exp!]
  gender: String_comparison_exp
  visitors: visitors_bool_exp
  visitors_aggregate: visitors_aggregate_bool_exp
}

"""
unique or primary key constraints on table "gender"
"""
enum gender_constraint {
  """
  unique or primary key constraint on columns "gender"
  """
  gender_pkey
}

enum gender_enum {
  FEMALE
  MALE
}

"""
Boolean expression to compare columns of type "gender_enum". All fields are combined with logical 'AND'.
"""
input gender_enum_comparison_exp {
  _eq: gender_enum
  _in: [gender_enum!]
  _is_null: Boolean
  _neq: gender_enum
  _nin: [gender_enum!]
}

"""
input type for inserting data into table "gender"
"""
input gender_insert_input {
  gender: String
  visitors: visitors_arr_rel_insert_input
}

"""aggregate max on columns"""
type gender_max_fields {
  gender: String
}

"""aggregate min on columns"""
type gender_min_fields {
  gender: String
}

"""
response of any mutation on the table "gender"
"""
type gender_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [gender!]!
}

"""
input type for inserting object relation for remote table "gender"
"""
input gender_obj_rel_insert_input {
  data: gender_insert_input!

  """upsert condition"""
  on_conflict: gender_on_conflict
}

"""
on_conflict condition type for table "gender"
"""
input gender_on_conflict {
  constraint: gender_constraint!
  update_columns: [gender_update_column!]! = []
  where: gender_bool_exp
}

"""Ordering options when selecting data from "gender"."""
input gender_order_by {
  gender: order_by
  visitors_aggregate: visitors_aggregate_order_by
}

"""primary key columns input for table: gender"""
input gender_pk_columns_input {
  gender: String!
}

"""
select columns of table "gender"
"""
enum gender_select_column {
  """column name"""
  gender
}

"""
input type for updating data in table "gender"
"""
input gender_set_input {
  gender: String
}

"""
Streaming cursor of the table "gender"
"""
input gender_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: gender_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input gender_stream_cursor_value_input {
  gender: String
}

"""
update columns of table "gender"
"""
enum gender_update_column {
  """column name"""
  gender
}

input gender_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: gender_set_input

  """filter the rows which have to be updated"""
  where: gender_bool_exp!
}

scalar geography

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"""
columns and relationships of "geography_columns"
"""
type geography_columns {
  coord_dimension: Int
  f_geography_column: name
  f_table_catalog: name
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""
aggregated selection of "geography_columns"
"""
type geography_columns_aggregate {
  aggregate: geography_columns_aggregate_fields
  nodes: [geography_columns!]!
}

"""
aggregate fields of "geography_columns"
"""
type geography_columns_aggregate_fields {
  avg: geography_columns_avg_fields
  count(columns: [geography_columns_select_column!], distinct: Boolean): Int!
  max: geography_columns_max_fields
  min: geography_columns_min_fields
  stddev: geography_columns_stddev_fields
  stddev_pop: geography_columns_stddev_pop_fields
  stddev_samp: geography_columns_stddev_samp_fields
  sum: geography_columns_sum_fields
  var_pop: geography_columns_var_pop_fields
  var_samp: geography_columns_var_samp_fields
  variance: geography_columns_variance_fields
}

"""aggregate avg on columns"""
type geography_columns_avg_fields {
  coord_dimension: Float
  srid: Float
}

"""
Boolean expression to filter rows from the table "geography_columns". All fields are combined with a logical 'AND'.
"""
input geography_columns_bool_exp {
  _and: [geography_columns_bool_exp!]
  _not: geography_columns_bool_exp
  _or: [geography_columns_bool_exp!]
  coord_dimension: Int_comparison_exp
  f_geography_column: name_comparison_exp
  f_table_catalog: name_comparison_exp
  f_table_name: name_comparison_exp
  f_table_schema: name_comparison_exp
  srid: Int_comparison_exp
  type: String_comparison_exp
}

"""aggregate max on columns"""
type geography_columns_max_fields {
  coord_dimension: Int
  srid: Int
  type: String
}

"""aggregate min on columns"""
type geography_columns_min_fields {
  coord_dimension: Int
  srid: Int
  type: String
}

"""Ordering options when selecting data from "geography_columns"."""
input geography_columns_order_by {
  coord_dimension: order_by
  f_geography_column: order_by
  f_table_catalog: order_by
  f_table_name: order_by
  f_table_schema: order_by
  srid: order_by
  type: order_by
}

"""
select columns of table "geography_columns"
"""
enum geography_columns_select_column {
  """column name"""
  coord_dimension

  """column name"""
  f_geography_column

  """column name"""
  f_table_catalog

  """column name"""
  f_table_name

  """column name"""
  f_table_schema

  """column name"""
  srid

  """column name"""
  type
}

"""aggregate stddev on columns"""
type geography_columns_stddev_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate stddev_pop on columns"""
type geography_columns_stddev_pop_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate stddev_samp on columns"""
type geography_columns_stddev_samp_fields {
  coord_dimension: Float
  srid: Float
}

"""
Streaming cursor of the table "geography_columns"
"""
input geography_columns_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: geography_columns_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input geography_columns_stream_cursor_value_input {
  coord_dimension: Int
  f_geography_column: name
  f_table_catalog: name
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""aggregate sum on columns"""
type geography_columns_sum_fields {
  coord_dimension: Int
  srid: Int
}

"""aggregate var_pop on columns"""
type geography_columns_var_pop_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate var_samp on columns"""
type geography_columns_var_samp_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate variance on columns"""
type geography_columns_variance_fields {
  coord_dimension: Float
  srid: Float
}

"""
Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'.
"""
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  """is the column within a given distance from the given geography value"""
  _st_d_within: st_d_within_geography_input

  """does the column spatially intersect the given geography value"""
  _st_intersects: geography
}

scalar geometry

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"""
columns and relationships of "geometry_columns"
"""
type geometry_columns {
  coord_dimension: Int
  f_geometry_column: name
  f_table_catalog: String
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""
aggregated selection of "geometry_columns"
"""
type geometry_columns_aggregate {
  aggregate: geometry_columns_aggregate_fields
  nodes: [geometry_columns!]!
}

"""
aggregate fields of "geometry_columns"
"""
type geometry_columns_aggregate_fields {
  avg: geometry_columns_avg_fields
  count(columns: [geometry_columns_select_column!], distinct: Boolean): Int!
  max: geometry_columns_max_fields
  min: geometry_columns_min_fields
  stddev: geometry_columns_stddev_fields
  stddev_pop: geometry_columns_stddev_pop_fields
  stddev_samp: geometry_columns_stddev_samp_fields
  sum: geometry_columns_sum_fields
  var_pop: geometry_columns_var_pop_fields
  var_samp: geometry_columns_var_samp_fields
  variance: geometry_columns_variance_fields
}

"""aggregate avg on columns"""
type geometry_columns_avg_fields {
  coord_dimension: Float
  srid: Float
}

"""
Boolean expression to filter rows from the table "geometry_columns". All fields are combined with a logical 'AND'.
"""
input geometry_columns_bool_exp {
  _and: [geometry_columns_bool_exp!]
  _not: geometry_columns_bool_exp
  _or: [geometry_columns_bool_exp!]
  coord_dimension: Int_comparison_exp
  f_geometry_column: name_comparison_exp
  f_table_catalog: String_comparison_exp
  f_table_name: name_comparison_exp
  f_table_schema: name_comparison_exp
  srid: Int_comparison_exp
  type: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "geometry_columns"
"""
input geometry_columns_inc_input {
  coord_dimension: Int
  srid: Int
}

"""
input type for inserting data into table "geometry_columns"
"""
input geometry_columns_insert_input {
  coord_dimension: Int
  f_geometry_column: name
  f_table_catalog: String
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""aggregate max on columns"""
type geometry_columns_max_fields {
  coord_dimension: Int
  f_table_catalog: String
  srid: Int
  type: String
}

"""aggregate min on columns"""
type geometry_columns_min_fields {
  coord_dimension: Int
  f_table_catalog: String
  srid: Int
  type: String
}

"""
response of any mutation on the table "geometry_columns"
"""
type geometry_columns_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [geometry_columns!]!
}

"""Ordering options when selecting data from "geometry_columns"."""
input geometry_columns_order_by {
  coord_dimension: order_by
  f_geometry_column: order_by
  f_table_catalog: order_by
  f_table_name: order_by
  f_table_schema: order_by
  srid: order_by
  type: order_by
}

"""
select columns of table "geometry_columns"
"""
enum geometry_columns_select_column {
  """column name"""
  coord_dimension

  """column name"""
  f_geometry_column

  """column name"""
  f_table_catalog

  """column name"""
  f_table_name

  """column name"""
  f_table_schema

  """column name"""
  srid

  """column name"""
  type
}

"""
input type for updating data in table "geometry_columns"
"""
input geometry_columns_set_input {
  coord_dimension: Int
  f_geometry_column: name
  f_table_catalog: String
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""aggregate stddev on columns"""
type geometry_columns_stddev_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate stddev_pop on columns"""
type geometry_columns_stddev_pop_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate stddev_samp on columns"""
type geometry_columns_stddev_samp_fields {
  coord_dimension: Float
  srid: Float
}

"""
Streaming cursor of the table "geometry_columns"
"""
input geometry_columns_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: geometry_columns_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input geometry_columns_stream_cursor_value_input {
  coord_dimension: Int
  f_geometry_column: name
  f_table_catalog: String
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""aggregate sum on columns"""
type geometry_columns_sum_fields {
  coord_dimension: Int
  srid: Int
}

input geometry_columns_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: geometry_columns_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: geometry_columns_set_input

  """filter the rows which have to be updated"""
  where: geometry_columns_bool_exp!
}

"""aggregate var_pop on columns"""
type geometry_columns_var_pop_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate var_samp on columns"""
type geometry_columns_var_samp_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate variance on columns"""
type geometry_columns_variance_fields {
  coord_dimension: Float
  srid: Float
}

"""
Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'.
"""
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  """is the column within a given 3D distance from the given geometry value"""
  _st_3d_d_within: st_d_within_input

  """does the column spatially intersect the given geometry value in 3D"""
  _st_3d_intersects: geometry

  """does the column contain the given geometry value"""
  _st_contains: geometry

  """does the column cross the given geometry value"""
  _st_crosses: geometry

  """is the column within a given distance from the given geometry value"""
  _st_d_within: st_d_within_input

  """
  is the column equal to given geometry value (directionality is ignored)
  """
  _st_equals: geometry

  """does the column spatially intersect the given geometry value"""
  _st_intersects: geometry

  """
  does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  """
  _st_overlaps: geometry

  """
  does the column have atleast one point in common with the given geometry value
  """
  _st_touches: geometry

  """is the column contained in the given geometry value"""
  _st_within: geometry
}

"""
columns and relationships of "group_members"
"""
type group_members {
  created_at: timestamptz

  """An object relationship"""
  employee: employees!

  """An object relationship"""
  group: groups!
  group_id: uuid!
  id: uuid!
  is_admin: Boolean
  member_id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "group_members"
"""
type group_members_aggregate {
  aggregate: group_members_aggregate_fields
  nodes: [group_members!]!
}

input group_members_aggregate_bool_exp {
  bool_and: group_members_aggregate_bool_exp_bool_and
  bool_or: group_members_aggregate_bool_exp_bool_or
  count: group_members_aggregate_bool_exp_count
}

input group_members_aggregate_bool_exp_bool_and {
  arguments: group_members_select_column_group_members_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: group_members_bool_exp
  predicate: Boolean_comparison_exp!
}

input group_members_aggregate_bool_exp_bool_or {
  arguments: group_members_select_column_group_members_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: group_members_bool_exp
  predicate: Boolean_comparison_exp!
}

input group_members_aggregate_bool_exp_count {
  arguments: [group_members_select_column!]
  distinct: Boolean
  filter: group_members_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "group_members"
"""
type group_members_aggregate_fields {
  count(columns: [group_members_select_column!], distinct: Boolean): Int!
  max: group_members_max_fields
  min: group_members_min_fields
}

"""
order by aggregate values of table "group_members"
"""
input group_members_aggregate_order_by {
  count: order_by
  max: group_members_max_order_by
  min: group_members_min_order_by
}

"""
input type for inserting array relation for remote table "group_members"
"""
input group_members_arr_rel_insert_input {
  data: [group_members_insert_input!]!

  """upsert condition"""
  on_conflict: group_members_on_conflict
}

"""
Boolean expression to filter rows from the table "group_members". All fields are combined with a logical 'AND'.
"""
input group_members_bool_exp {
  _and: [group_members_bool_exp!]
  _not: group_members_bool_exp
  _or: [group_members_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  group: groups_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_admin: Boolean_comparison_exp
  member_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "group_members"
"""
enum group_members_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  group_members_pkey
}

"""
input type for inserting data into table "group_members"
"""
input group_members_insert_input {
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  group: groups_obj_rel_insert_input
  group_id: uuid
  id: uuid
  is_admin: Boolean
  member_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type group_members_max_fields {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  member_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "group_members"
"""
input group_members_max_order_by {
  created_at: order_by
  group_id: order_by
  id: order_by
  member_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type group_members_min_fields {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  member_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "group_members"
"""
input group_members_min_order_by {
  created_at: order_by
  group_id: order_by
  id: order_by
  member_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "group_members"
"""
type group_members_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [group_members!]!
}

"""
on_conflict condition type for table "group_members"
"""
input group_members_on_conflict {
  constraint: group_members_constraint!
  update_columns: [group_members_update_column!]! = []
  where: group_members_bool_exp
}

"""Ordering options when selecting data from "group_members"."""
input group_members_order_by {
  created_at: order_by
  employee: employees_order_by
  group: groups_order_by
  group_id: order_by
  id: order_by
  is_admin: order_by
  member_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: group_members"""
input group_members_pk_columns_input {
  id: uuid!
}

"""
select columns of table "group_members"
"""
enum group_members_select_column {
  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  is_admin

  """column name"""
  member_id

  """column name"""
  updated_at
}

"""
select "group_members_aggregate_bool_exp_bool_and_arguments_columns" columns of table "group_members"
"""
enum group_members_select_column_group_members_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_admin
}

"""
select "group_members_aggregate_bool_exp_bool_or_arguments_columns" columns of table "group_members"
"""
enum group_members_select_column_group_members_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_admin
}

"""
input type for updating data in table "group_members"
"""
input group_members_set_input {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  is_admin: Boolean
  member_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "group_members"
"""
input group_members_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: group_members_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input group_members_stream_cursor_value_input {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  is_admin: Boolean
  member_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "group_members"
"""
enum group_members_update_column {
  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  is_admin

  """column name"""
  member_id

  """column name"""
  updated_at
}

input group_members_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: group_members_set_input

  """filter the rows which have to be updated"""
  where: group_members_bool_exp!
}

"""
columns and relationships of "group_messages"
"""
type group_messages {
  attachment: uuid!

  """An object relationship"""
  attachmentByAttachment: attachments!
  content: String
  created_at: timestamptz

  """An object relationship"""
  group: groups!
  group_id: uuid!
  id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "group_messages"
"""
type group_messages_aggregate {
  aggregate: group_messages_aggregate_fields
  nodes: [group_messages!]!
}

input group_messages_aggregate_bool_exp {
  count: group_messages_aggregate_bool_exp_count
}

input group_messages_aggregate_bool_exp_count {
  arguments: [group_messages_select_column!]
  distinct: Boolean
  filter: group_messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "group_messages"
"""
type group_messages_aggregate_fields {
  count(columns: [group_messages_select_column!], distinct: Boolean): Int!
  max: group_messages_max_fields
  min: group_messages_min_fields
}

"""
order by aggregate values of table "group_messages"
"""
input group_messages_aggregate_order_by {
  count: order_by
  max: group_messages_max_order_by
  min: group_messages_min_order_by
}

"""
input type for inserting array relation for remote table "group_messages"
"""
input group_messages_arr_rel_insert_input {
  data: [group_messages_insert_input!]!

  """upsert condition"""
  on_conflict: group_messages_on_conflict
}

"""
Boolean expression to filter rows from the table "group_messages". All fields are combined with a logical 'AND'.
"""
input group_messages_bool_exp {
  _and: [group_messages_bool_exp!]
  _not: group_messages_bool_exp
  _or: [group_messages_bool_exp!]
  attachment: uuid_comparison_exp
  attachmentByAttachment: attachments_bool_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  group: groups_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "group_messages"
"""
enum group_messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  group_messages_pkey
}

"""
input type for inserting data into table "group_messages"
"""
input group_messages_insert_input {
  attachment: uuid
  attachmentByAttachment: attachments_obj_rel_insert_input
  content: String
  created_at: timestamptz
  group: groups_obj_rel_insert_input
  group_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type group_messages_max_fields {
  attachment: uuid
  content: String
  created_at: timestamptz
  group_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "group_messages"
"""
input group_messages_max_order_by {
  attachment: order_by
  content: order_by
  created_at: order_by
  group_id: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type group_messages_min_fields {
  attachment: uuid
  content: String
  created_at: timestamptz
  group_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "group_messages"
"""
input group_messages_min_order_by {
  attachment: order_by
  content: order_by
  created_at: order_by
  group_id: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "group_messages"
"""
type group_messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [group_messages!]!
}

"""
on_conflict condition type for table "group_messages"
"""
input group_messages_on_conflict {
  constraint: group_messages_constraint!
  update_columns: [group_messages_update_column!]! = []
  where: group_messages_bool_exp
}

"""Ordering options when selecting data from "group_messages"."""
input group_messages_order_by {
  attachment: order_by
  attachmentByAttachment: attachments_order_by
  content: order_by
  created_at: order_by
  group: groups_order_by
  group_id: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: group_messages"""
input group_messages_pk_columns_input {
  id: uuid!
}

"""
select columns of table "group_messages"
"""
enum group_messages_select_column {
  """column name"""
  attachment

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "group_messages"
"""
input group_messages_set_input {
  attachment: uuid
  content: String
  created_at: timestamptz
  group_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "group_messages"
"""
input group_messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: group_messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input group_messages_stream_cursor_value_input {
  attachment: uuid
  content: String
  created_at: timestamptz
  group_id: uuid
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "group_messages"
"""
enum group_messages_update_column {
  """column name"""
  attachment

  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  updated_at
}

input group_messages_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: group_messages_set_input

  """filter the rows which have to be updated"""
  where: group_messages_bool_exp!
}

"""
columns and relationships of "groups"
"""
type groups {
  created_at: timestamptz
  creator_id: uuid!

  """An object relationship"""
  employee: employees!
  group_description: String

  """An array relationship"""
  group_members(
    """distinct select on columns"""
    distinct_on: [group_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_members_order_by!]

    """filter the rows returned"""
    where: group_members_bool_exp
  ): [group_members!]!

  """An aggregate relationship"""
  group_members_aggregate(
    """distinct select on columns"""
    distinct_on: [group_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_members_order_by!]

    """filter the rows returned"""
    where: group_members_bool_exp
  ): group_members_aggregate!

  """An array relationship"""
  group_messages(
    """distinct select on columns"""
    distinct_on: [group_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_messages_order_by!]

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): [group_messages!]!

  """An aggregate relationship"""
  group_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [group_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_messages_order_by!]

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): group_messages_aggregate!
  id: uuid!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "groups"
"""
type groups_aggregate {
  aggregate: groups_aggregate_fields
  nodes: [groups!]!
}

input groups_aggregate_bool_exp {
  count: groups_aggregate_bool_exp_count
}

input groups_aggregate_bool_exp_count {
  arguments: [groups_select_column!]
  distinct: Boolean
  filter: groups_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "groups"
"""
type groups_aggregate_fields {
  count(columns: [groups_select_column!], distinct: Boolean): Int!
  max: groups_max_fields
  min: groups_min_fields
}

"""
order by aggregate values of table "groups"
"""
input groups_aggregate_order_by {
  count: order_by
  max: groups_max_order_by
  min: groups_min_order_by
}

"""
input type for inserting array relation for remote table "groups"
"""
input groups_arr_rel_insert_input {
  data: [groups_insert_input!]!

  """upsert condition"""
  on_conflict: groups_on_conflict
}

"""
Boolean expression to filter rows from the table "groups". All fields are combined with a logical 'AND'.
"""
input groups_bool_exp {
  _and: [groups_bool_exp!]
  _not: groups_bool_exp
  _or: [groups_bool_exp!]
  created_at: timestamptz_comparison_exp
  creator_id: uuid_comparison_exp
  employee: employees_bool_exp
  group_description: String_comparison_exp
  group_members: group_members_bool_exp
  group_members_aggregate: group_members_aggregate_bool_exp
  group_messages: group_messages_bool_exp
  group_messages_aggregate: group_messages_aggregate_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "groups"
"""
enum groups_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  groups_pkey
}

"""
input type for inserting data into table "groups"
"""
input groups_insert_input {
  created_at: timestamptz
  creator_id: uuid
  employee: employees_obj_rel_insert_input
  group_description: String
  group_members: group_members_arr_rel_insert_input
  group_messages: group_messages_arr_rel_insert_input
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type groups_max_fields {
  created_at: timestamptz
  creator_id: uuid
  group_description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "groups"
"""
input groups_max_order_by {
  created_at: order_by
  creator_id: order_by
  group_description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type groups_min_fields {
  created_at: timestamptz
  creator_id: uuid
  group_description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "groups"
"""
input groups_min_order_by {
  created_at: order_by
  creator_id: order_by
  group_description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "groups"
"""
type groups_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [groups!]!
}

"""
input type for inserting object relation for remote table "groups"
"""
input groups_obj_rel_insert_input {
  data: groups_insert_input!

  """upsert condition"""
  on_conflict: groups_on_conflict
}

"""
on_conflict condition type for table "groups"
"""
input groups_on_conflict {
  constraint: groups_constraint!
  update_columns: [groups_update_column!]! = []
  where: groups_bool_exp
}

"""Ordering options when selecting data from "groups"."""
input groups_order_by {
  created_at: order_by
  creator_id: order_by
  employee: employees_order_by
  group_description: order_by
  group_members_aggregate: group_members_aggregate_order_by
  group_messages_aggregate: group_messages_aggregate_order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: groups"""
input groups_pk_columns_input {
  id: uuid!
}

"""
select columns of table "groups"
"""
enum groups_select_column {
  """column name"""
  created_at

  """column name"""
  creator_id

  """column name"""
  group_description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "groups"
"""
input groups_set_input {
  created_at: timestamptz
  creator_id: uuid
  group_description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "groups"
"""
input groups_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: groups_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input groups_stream_cursor_value_input {
  created_at: timestamptz
  creator_id: uuid
  group_description: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "groups"
"""
enum groups_update_column {
  """column name"""
  created_at

  """column name"""
  creator_id

  """column name"""
  group_description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input groups_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: groups_set_input

  """filter the rows which have to be updated"""
  where: groups_bool_exp!
}

type InsertMesaageOuput {
  id: UUID!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [Int!]

  """does the array contain the given value"""
  _contains: [Int!]
  _eq: [Int!]
  _gt: [Int!]
  _gte: [Int!]
  _in: [[Int!]!]
  _is_null: Boolean
  _lt: [Int!]
  _lte: [Int!]
  _neq: [Int!]
  _nin: [[Int!]!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar interval

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input interval_comparison_exp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _is_null: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

"""
columns and relationships of "leave_approval"
"""
type leave_approval {
  approval_status: leave_status_enum
  approver_id: uuid
  comments: String
  created_at: timestamptz

  """An object relationship"""
  employee: employees
  id: uuid!

  """An object relationship"""
  leave: leaves
  leave_id: uuid

  """An object relationship"""
  leave_status: leave_status
  updated_at: timestamptz
}

"""
aggregated selection of "leave_approval"
"""
type leave_approval_aggregate {
  aggregate: leave_approval_aggregate_fields
  nodes: [leave_approval!]!
}

input leave_approval_aggregate_bool_exp {
  count: leave_approval_aggregate_bool_exp_count
}

input leave_approval_aggregate_bool_exp_count {
  arguments: [leave_approval_select_column!]
  distinct: Boolean
  filter: leave_approval_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "leave_approval"
"""
type leave_approval_aggregate_fields {
  count(columns: [leave_approval_select_column!], distinct: Boolean): Int!
  max: leave_approval_max_fields
  min: leave_approval_min_fields
}

"""
order by aggregate values of table "leave_approval"
"""
input leave_approval_aggregate_order_by {
  count: order_by
  max: leave_approval_max_order_by
  min: leave_approval_min_order_by
}

"""
input type for inserting array relation for remote table "leave_approval"
"""
input leave_approval_arr_rel_insert_input {
  data: [leave_approval_insert_input!]!

  """upsert condition"""
  on_conflict: leave_approval_on_conflict
}

"""
Boolean expression to filter rows from the table "leave_approval". All fields are combined with a logical 'AND'.
"""
input leave_approval_bool_exp {
  _and: [leave_approval_bool_exp!]
  _not: leave_approval_bool_exp
  _or: [leave_approval_bool_exp!]
  approval_status: leave_status_enum_comparison_exp
  approver_id: uuid_comparison_exp
  comments: String_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  id: uuid_comparison_exp
  leave: leaves_bool_exp
  leave_id: uuid_comparison_exp
  leave_status: leave_status_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "leave_approval"
"""
enum leave_approval_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_approval_pkey
}

"""
input type for inserting data into table "leave_approval"
"""
input leave_approval_insert_input {
  approval_status: leave_status_enum
  approver_id: uuid
  comments: String
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  id: uuid
  leave: leaves_obj_rel_insert_input
  leave_id: uuid
  leave_status: leave_status_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type leave_approval_max_fields {
  approver_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  leave_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "leave_approval"
"""
input leave_approval_max_order_by {
  approver_id: order_by
  comments: order_by
  created_at: order_by
  id: order_by
  leave_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type leave_approval_min_fields {
  approver_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  leave_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "leave_approval"
"""
input leave_approval_min_order_by {
  approver_id: order_by
  comments: order_by
  created_at: order_by
  id: order_by
  leave_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "leave_approval"
"""
type leave_approval_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave_approval!]!
}

"""
on_conflict condition type for table "leave_approval"
"""
input leave_approval_on_conflict {
  constraint: leave_approval_constraint!
  update_columns: [leave_approval_update_column!]! = []
  where: leave_approval_bool_exp
}

"""Ordering options when selecting data from "leave_approval"."""
input leave_approval_order_by {
  approval_status: order_by
  approver_id: order_by
  comments: order_by
  created_at: order_by
  employee: employees_order_by
  id: order_by
  leave: leaves_order_by
  leave_id: order_by
  leave_status: leave_status_order_by
  updated_at: order_by
}

"""primary key columns input for table: leave_approval"""
input leave_approval_pk_columns_input {
  id: uuid!
}

"""
select columns of table "leave_approval"
"""
enum leave_approval_select_column {
  """column name"""
  approval_status

  """column name"""
  approver_id

  """column name"""
  comments

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  leave_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "leave_approval"
"""
input leave_approval_set_input {
  approval_status: leave_status_enum
  approver_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  leave_id: uuid
  updated_at: timestamptz
}

"""
columns and relationships of "leave_approval_status"
"""
type leave_approval_status {
  id: uuid!

  """An object relationship"""
  leave: leaves

  """An object relationship"""
  leaveStatusByLeaveStatus: leave_status
  leave_id: uuid
  leave_status: leave_status_enum
  reason: String
}

"""
aggregated selection of "leave_approval_status"
"""
type leave_approval_status_aggregate {
  aggregate: leave_approval_status_aggregate_fields
  nodes: [leave_approval_status!]!
}

input leave_approval_status_aggregate_bool_exp {
  count: leave_approval_status_aggregate_bool_exp_count
}

input leave_approval_status_aggregate_bool_exp_count {
  arguments: [leave_approval_status_select_column!]
  distinct: Boolean
  filter: leave_approval_status_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "leave_approval_status"
"""
type leave_approval_status_aggregate_fields {
  count(columns: [leave_approval_status_select_column!], distinct: Boolean): Int!
  max: leave_approval_status_max_fields
  min: leave_approval_status_min_fields
}

"""
order by aggregate values of table "leave_approval_status"
"""
input leave_approval_status_aggregate_order_by {
  count: order_by
  max: leave_approval_status_max_order_by
  min: leave_approval_status_min_order_by
}

"""
input type for inserting array relation for remote table "leave_approval_status"
"""
input leave_approval_status_arr_rel_insert_input {
  data: [leave_approval_status_insert_input!]!

  """upsert condition"""
  on_conflict: leave_approval_status_on_conflict
}

"""
Boolean expression to filter rows from the table "leave_approval_status". All fields are combined with a logical 'AND'.
"""
input leave_approval_status_bool_exp {
  _and: [leave_approval_status_bool_exp!]
  _not: leave_approval_status_bool_exp
  _or: [leave_approval_status_bool_exp!]
  id: uuid_comparison_exp
  leave: leaves_bool_exp
  leaveStatusByLeaveStatus: leave_status_bool_exp
  leave_id: uuid_comparison_exp
  leave_status: leave_status_enum_comparison_exp
  reason: String_comparison_exp
}

"""
unique or primary key constraints on table "leave_approval_status"
"""
enum leave_approval_status_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_approval_status_pkey
}

"""
input type for inserting data into table "leave_approval_status"
"""
input leave_approval_status_insert_input {
  id: uuid
  leave: leaves_obj_rel_insert_input
  leaveStatusByLeaveStatus: leave_status_obj_rel_insert_input
  leave_id: uuid
  leave_status: leave_status_enum
  reason: String
}

"""aggregate max on columns"""
type leave_approval_status_max_fields {
  id: uuid
  leave_id: uuid
  reason: String
}

"""
order by max() on columns of table "leave_approval_status"
"""
input leave_approval_status_max_order_by {
  id: order_by
  leave_id: order_by
  reason: order_by
}

"""aggregate min on columns"""
type leave_approval_status_min_fields {
  id: uuid
  leave_id: uuid
  reason: String
}

"""
order by min() on columns of table "leave_approval_status"
"""
input leave_approval_status_min_order_by {
  id: order_by
  leave_id: order_by
  reason: order_by
}

"""
response of any mutation on the table "leave_approval_status"
"""
type leave_approval_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave_approval_status!]!
}

"""
on_conflict condition type for table "leave_approval_status"
"""
input leave_approval_status_on_conflict {
  constraint: leave_approval_status_constraint!
  update_columns: [leave_approval_status_update_column!]! = []
  where: leave_approval_status_bool_exp
}

"""Ordering options when selecting data from "leave_approval_status"."""
input leave_approval_status_order_by {
  id: order_by
  leave: leaves_order_by
  leaveStatusByLeaveStatus: leave_status_order_by
  leave_id: order_by
  leave_status: order_by
  reason: order_by
}

"""primary key columns input for table: leave_approval_status"""
input leave_approval_status_pk_columns_input {
  id: uuid!
}

"""
select columns of table "leave_approval_status"
"""
enum leave_approval_status_select_column {
  """column name"""
  id

  """column name"""
  leave_id

  """column name"""
  leave_status

  """column name"""
  reason
}

"""
input type for updating data in table "leave_approval_status"
"""
input leave_approval_status_set_input {
  id: uuid
  leave_id: uuid
  leave_status: leave_status_enum
  reason: String
}

"""
Streaming cursor of the table "leave_approval_status"
"""
input leave_approval_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_approval_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_approval_status_stream_cursor_value_input {
  id: uuid
  leave_id: uuid
  leave_status: leave_status_enum
  reason: String
}

"""
update columns of table "leave_approval_status"
"""
enum leave_approval_status_update_column {
  """column name"""
  id

  """column name"""
  leave_id

  """column name"""
  leave_status

  """column name"""
  reason
}

input leave_approval_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_approval_status_set_input

  """filter the rows which have to be updated"""
  where: leave_approval_status_bool_exp!
}

"""
Streaming cursor of the table "leave_approval"
"""
input leave_approval_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_approval_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_approval_stream_cursor_value_input {
  approval_status: leave_status_enum
  approver_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  leave_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "leave_approval"
"""
enum leave_approval_update_column {
  """column name"""
  approval_status

  """column name"""
  approver_id

  """column name"""
  comments

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  leave_id

  """column name"""
  updated_at
}

input leave_approval_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_approval_set_input

  """filter the rows which have to be updated"""
  where: leave_approval_bool_exp!
}

"""
columns and relationships of "leave_status"
"""
type leave_status {
  """An array relationship"""
  leave_approval_statuses(
    """distinct select on columns"""
    distinct_on: [leave_approval_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_status_order_by!]

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): [leave_approval_status!]!

  """An aggregate relationship"""
  leave_approval_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_status_order_by!]

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): leave_approval_status_aggregate!

  """An array relationship"""
  leave_approvals(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """An aggregate relationship"""
  leave_approvals_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!
  status: String!
}

"""
aggregated selection of "leave_status"
"""
type leave_status_aggregate {
  aggregate: leave_status_aggregate_fields
  nodes: [leave_status!]!
}

"""
aggregate fields of "leave_status"
"""
type leave_status_aggregate_fields {
  count(columns: [leave_status_select_column!], distinct: Boolean): Int!
  max: leave_status_max_fields
  min: leave_status_min_fields
}

"""
Boolean expression to filter rows from the table "leave_status". All fields are combined with a logical 'AND'.
"""
input leave_status_bool_exp {
  _and: [leave_status_bool_exp!]
  _not: leave_status_bool_exp
  _or: [leave_status_bool_exp!]
  leave_approval_statuses: leave_approval_status_bool_exp
  leave_approval_statuses_aggregate: leave_approval_status_aggregate_bool_exp
  leave_approvals: leave_approval_bool_exp
  leave_approvals_aggregate: leave_approval_aggregate_bool_exp
  leaves: leaves_bool_exp
  leaves_aggregate: leaves_aggregate_bool_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "leave_status"
"""
enum leave_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  leave_status_pkey
}

enum leave_status_enum {
  ACCEPTED
  PENDING
  REJECTED
}

"""
Boolean expression to compare columns of type "leave_status_enum". All fields are combined with logical 'AND'.
"""
input leave_status_enum_comparison_exp {
  _eq: leave_status_enum
  _in: [leave_status_enum!]
  _is_null: Boolean
  _neq: leave_status_enum
  _nin: [leave_status_enum!]
}

"""
input type for inserting data into table "leave_status"
"""
input leave_status_insert_input {
  leave_approval_statuses: leave_approval_status_arr_rel_insert_input
  leave_approvals: leave_approval_arr_rel_insert_input
  leaves: leaves_arr_rel_insert_input
  status: String
}

"""aggregate max on columns"""
type leave_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type leave_status_min_fields {
  status: String
}

"""
response of any mutation on the table "leave_status"
"""
type leave_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave_status!]!
}

"""
input type for inserting object relation for remote table "leave_status"
"""
input leave_status_obj_rel_insert_input {
  data: leave_status_insert_input!

  """upsert condition"""
  on_conflict: leave_status_on_conflict
}

"""
on_conflict condition type for table "leave_status"
"""
input leave_status_on_conflict {
  constraint: leave_status_constraint!
  update_columns: [leave_status_update_column!]! = []
  where: leave_status_bool_exp
}

"""Ordering options when selecting data from "leave_status"."""
input leave_status_order_by {
  leave_approval_statuses_aggregate: leave_approval_status_aggregate_order_by
  leave_approvals_aggregate: leave_approval_aggregate_order_by
  leaves_aggregate: leaves_aggregate_order_by
  status: order_by
}

"""primary key columns input for table: leave_status"""
input leave_status_pk_columns_input {
  status: String!
}

"""
select columns of table "leave_status"
"""
enum leave_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "leave_status"
"""
input leave_status_set_input {
  status: String
}

"""
Streaming cursor of the table "leave_status"
"""
input leave_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "leave_status"
"""
enum leave_status_update_column {
  """column name"""
  status
}

input leave_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_status_set_input

  """filter the rows which have to be updated"""
  where: leave_status_bool_exp!
}

"""
columns and relationships of "leave_type"
"""
type leave_type {
  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!
  type: String!
}

"""
aggregated selection of "leave_type"
"""
type leave_type_aggregate {
  aggregate: leave_type_aggregate_fields
  nodes: [leave_type!]!
}

"""
aggregate fields of "leave_type"
"""
type leave_type_aggregate_fields {
  count(columns: [leave_type_select_column!], distinct: Boolean): Int!
  max: leave_type_max_fields
  min: leave_type_min_fields
}

"""
Boolean expression to filter rows from the table "leave_type". All fields are combined with a logical 'AND'.
"""
input leave_type_bool_exp {
  _and: [leave_type_bool_exp!]
  _not: leave_type_bool_exp
  _or: [leave_type_bool_exp!]
  leaves: leaves_bool_exp
  leaves_aggregate: leaves_aggregate_bool_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "leave_type"
"""
enum leave_type_constraint {
  """
  unique or primary key constraint on columns "type"
  """
  leave_type_pkey
}

enum leave_type_enum {
  BEREAVE
  MATERNITY
  OTHER
  SICK
}

"""
Boolean expression to compare columns of type "leave_type_enum". All fields are combined with logical 'AND'.
"""
input leave_type_enum_comparison_exp {
  _eq: leave_type_enum
  _in: [leave_type_enum!]
  _is_null: Boolean
  _neq: leave_type_enum
  _nin: [leave_type_enum!]
}

"""
input type for inserting data into table "leave_type"
"""
input leave_type_insert_input {
  leaves: leaves_arr_rel_insert_input
  type: String
}

"""aggregate max on columns"""
type leave_type_max_fields {
  type: String
}

"""aggregate min on columns"""
type leave_type_min_fields {
  type: String
}

"""
response of any mutation on the table "leave_type"
"""
type leave_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave_type!]!
}

"""
input type for inserting object relation for remote table "leave_type"
"""
input leave_type_obj_rel_insert_input {
  data: leave_type_insert_input!

  """upsert condition"""
  on_conflict: leave_type_on_conflict
}

"""
on_conflict condition type for table "leave_type"
"""
input leave_type_on_conflict {
  constraint: leave_type_constraint!
  update_columns: [leave_type_update_column!]! = []
  where: leave_type_bool_exp
}

"""Ordering options when selecting data from "leave_type"."""
input leave_type_order_by {
  leaves_aggregate: leaves_aggregate_order_by
  type: order_by
}

"""primary key columns input for table: leave_type"""
input leave_type_pk_columns_input {
  type: String!
}

"""
select columns of table "leave_type"
"""
enum leave_type_select_column {
  """column name"""
  type
}

"""
input type for updating data in table "leave_type"
"""
input leave_type_set_input {
  type: String
}

"""
Streaming cursor of the table "leave_type"
"""
input leave_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_type_stream_cursor_value_input {
  type: String
}

"""
update columns of table "leave_type"
"""
enum leave_type_update_column {
  """column name"""
  type
}

input leave_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_type_set_input

  """filter the rows which have to be updated"""
  where: leave_type_bool_exp!
}

"""
columns and relationships of "leave_types"
"""
type leave_types {
  created_at: timestamptz
  id: uuid!

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!
  types: String
  updated_at: timestamptz
}

"""
aggregated selection of "leave_types"
"""
type leave_types_aggregate {
  aggregate: leave_types_aggregate_fields
  nodes: [leave_types!]!
}

"""
aggregate fields of "leave_types"
"""
type leave_types_aggregate_fields {
  count(columns: [leave_types_select_column!], distinct: Boolean): Int!
  max: leave_types_max_fields
  min: leave_types_min_fields
}

"""
Boolean expression to filter rows from the table "leave_types". All fields are combined with a logical 'AND'.
"""
input leave_types_bool_exp {
  _and: [leave_types_bool_exp!]
  _not: leave_types_bool_exp
  _or: [leave_types_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  leaves: leaves_bool_exp
  leaves_aggregate: leaves_aggregate_bool_exp
  types: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "leave_types"
"""
enum leave_types_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_types_pkey
}

"""
input type for inserting data into table "leave_types"
"""
input leave_types_insert_input {
  created_at: timestamptz
  id: uuid
  leaves: leaves_arr_rel_insert_input
  types: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type leave_types_max_fields {
  created_at: timestamptz
  id: uuid
  types: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type leave_types_min_fields {
  created_at: timestamptz
  id: uuid
  types: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "leave_types"
"""
type leave_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave_types!]!
}

"""
input type for inserting object relation for remote table "leave_types"
"""
input leave_types_obj_rel_insert_input {
  data: leave_types_insert_input!

  """upsert condition"""
  on_conflict: leave_types_on_conflict
}

"""
on_conflict condition type for table "leave_types"
"""
input leave_types_on_conflict {
  constraint: leave_types_constraint!
  update_columns: [leave_types_update_column!]! = []
  where: leave_types_bool_exp
}

"""Ordering options when selecting data from "leave_types"."""
input leave_types_order_by {
  created_at: order_by
  id: order_by
  leaves_aggregate: leaves_aggregate_order_by
  types: order_by
  updated_at: order_by
}

"""primary key columns input for table: leave_types"""
input leave_types_pk_columns_input {
  id: uuid!
}

"""
select columns of table "leave_types"
"""
enum leave_types_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  types

  """column name"""
  updated_at
}

"""
input type for updating data in table "leave_types"
"""
input leave_types_set_input {
  created_at: timestamptz
  id: uuid
  types: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "leave_types"
"""
input leave_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_types_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  types: String
  updated_at: timestamptz
}

"""
update columns of table "leave_types"
"""
enum leave_types_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  types

  """column name"""
  updated_at
}

input leave_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_types_set_input

  """filter the rows which have to be updated"""
  where: leave_types_bool_exp!
}

"""
columns and relationships of "leaves"
"""
type leaves {
  comment: String
  created_at: timestamptz

  """An object relationship"""
  employee: employees
  employee_id: uuid
  end_date: date!
  end_time: time
  file: String
  id: uuid!

  """An object relationship"""
  leaveTypeByLeaveType: leave_type

  """An object relationship"""
  leaveTypeByTypes: leave_types

  """An array relationship"""
  leave_approval_statuses(
    """distinct select on columns"""
    distinct_on: [leave_approval_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_status_order_by!]

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): [leave_approval_status!]!

  """An aggregate relationship"""
  leave_approval_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_status_order_by!]

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): leave_approval_status_aggregate!

  """An array relationship"""
  leave_approvals(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """An aggregate relationship"""
  leave_approvals_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """An object relationship"""
  leave_status: leave_status
  leave_type: leave_type_enum
  other_description: String
  start_date: date!
  start_time: time
  status: leave_status_enum
  types: uuid
  updated_at: timestamptz
}

"""
aggregated selection of "leaves"
"""
type leaves_aggregate {
  aggregate: leaves_aggregate_fields
  nodes: [leaves!]!
}

input leaves_aggregate_bool_exp {
  count: leaves_aggregate_bool_exp_count
}

input leaves_aggregate_bool_exp_count {
  arguments: [leaves_select_column!]
  distinct: Boolean
  filter: leaves_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "leaves"
"""
type leaves_aggregate_fields {
  count(columns: [leaves_select_column!], distinct: Boolean): Int!
  max: leaves_max_fields
  min: leaves_min_fields
}

"""
order by aggregate values of table "leaves"
"""
input leaves_aggregate_order_by {
  count: order_by
  max: leaves_max_order_by
  min: leaves_min_order_by
}

"""
input type for inserting array relation for remote table "leaves"
"""
input leaves_arr_rel_insert_input {
  data: [leaves_insert_input!]!

  """upsert condition"""
  on_conflict: leaves_on_conflict
}

"""
Boolean expression to filter rows from the table "leaves". All fields are combined with a logical 'AND'.
"""
input leaves_bool_exp {
  _and: [leaves_bool_exp!]
  _not: leaves_bool_exp
  _or: [leaves_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  end_date: date_comparison_exp
  end_time: time_comparison_exp
  file: String_comparison_exp
  id: uuid_comparison_exp
  leaveTypeByLeaveType: leave_type_bool_exp
  leaveTypeByTypes: leave_types_bool_exp
  leave_approval_statuses: leave_approval_status_bool_exp
  leave_approval_statuses_aggregate: leave_approval_status_aggregate_bool_exp
  leave_approvals: leave_approval_bool_exp
  leave_approvals_aggregate: leave_approval_aggregate_bool_exp
  leave_status: leave_status_bool_exp
  leave_type: leave_type_enum_comparison_exp
  other_description: String_comparison_exp
  start_date: date_comparison_exp
  start_time: time_comparison_exp
  status: leave_status_enum_comparison_exp
  types: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "leaves"
"""
enum leaves_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leaves_pkey
}

"""
input type for inserting data into table "leaves"
"""
input leaves_insert_input {
  comment: String
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  end_date: date
  end_time: time
  file: String
  id: uuid
  leaveTypeByLeaveType: leave_type_obj_rel_insert_input
  leaveTypeByTypes: leave_types_obj_rel_insert_input
  leave_approval_statuses: leave_approval_status_arr_rel_insert_input
  leave_approvals: leave_approval_arr_rel_insert_input
  leave_status: leave_status_obj_rel_insert_input
  leave_type: leave_type_enum
  other_description: String
  start_date: date
  start_time: time
  status: leave_status_enum
  types: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type leaves_max_fields {
  comment: String
  created_at: timestamptz
  employee_id: uuid
  end_date: date
  file: String
  id: uuid
  other_description: String
  start_date: date
  types: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "leaves"
"""
input leaves_max_order_by {
  comment: order_by
  created_at: order_by
  employee_id: order_by
  end_date: order_by
  file: order_by
  id: order_by
  other_description: order_by
  start_date: order_by
  types: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type leaves_min_fields {
  comment: String
  created_at: timestamptz
  employee_id: uuid
  end_date: date
  file: String
  id: uuid
  other_description: String
  start_date: date
  types: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "leaves"
"""
input leaves_min_order_by {
  comment: order_by
  created_at: order_by
  employee_id: order_by
  end_date: order_by
  file: order_by
  id: order_by
  other_description: order_by
  start_date: order_by
  types: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "leaves"
"""
type leaves_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leaves!]!
}

"""
input type for inserting object relation for remote table "leaves"
"""
input leaves_obj_rel_insert_input {
  data: leaves_insert_input!

  """upsert condition"""
  on_conflict: leaves_on_conflict
}

"""
on_conflict condition type for table "leaves"
"""
input leaves_on_conflict {
  constraint: leaves_constraint!
  update_columns: [leaves_update_column!]! = []
  where: leaves_bool_exp
}

"""Ordering options when selecting data from "leaves"."""
input leaves_order_by {
  comment: order_by
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  end_date: order_by
  end_time: order_by
  file: order_by
  id: order_by
  leaveTypeByLeaveType: leave_type_order_by
  leaveTypeByTypes: leave_types_order_by
  leave_approval_statuses_aggregate: leave_approval_status_aggregate_order_by
  leave_approvals_aggregate: leave_approval_aggregate_order_by
  leave_status: leave_status_order_by
  leave_type: order_by
  other_description: order_by
  start_date: order_by
  start_time: order_by
  status: order_by
  types: order_by
  updated_at: order_by
}

"""primary key columns input for table: leaves"""
input leaves_pk_columns_input {
  id: uuid!
}

"""
select columns of table "leaves"
"""
enum leaves_select_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  end_date

  """column name"""
  end_time

  """column name"""
  file

  """column name"""
  id

  """column name"""
  leave_type

  """column name"""
  other_description

  """column name"""
  start_date

  """column name"""
  start_time

  """column name"""
  status

  """column name"""
  types

  """column name"""
  updated_at
}

"""
input type for updating data in table "leaves"
"""
input leaves_set_input {
  comment: String
  created_at: timestamptz
  employee_id: uuid
  end_date: date
  end_time: time
  file: String
  id: uuid
  leave_type: leave_type_enum
  other_description: String
  start_date: date
  start_time: time
  status: leave_status_enum
  types: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "leaves"
"""
input leaves_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leaves_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leaves_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  employee_id: uuid
  end_date: date
  end_time: time
  file: String
  id: uuid
  leave_type: leave_type_enum
  other_description: String
  start_date: date
  start_time: time
  status: leave_status_enum
  types: uuid
  updated_at: timestamptz
}

"""
update columns of table "leaves"
"""
enum leaves_update_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  end_date

  """column name"""
  end_time

  """column name"""
  file

  """column name"""
  id

  """column name"""
  leave_type

  """column name"""
  other_description

  """column name"""
  start_date

  """column name"""
  start_time

  """column name"""
  status

  """column name"""
  types

  """column name"""
  updated_at
}

input leaves_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leaves_set_input

  """filter the rows which have to be updated"""
  where: leaves_bool_exp!
}

"""
columns and relationships of "locations"
"""
type locations {
  buidling_id: uuid
  created_at: timestamptz
  id: uuid!
  location: geometry
  updated_at: timestamptz
}

"""
aggregated selection of "locations"
"""
type locations_aggregate {
  aggregate: locations_aggregate_fields
  nodes: [locations!]!
}

"""
aggregate fields of "locations"
"""
type locations_aggregate_fields {
  count(columns: [locations_select_column!], distinct: Boolean): Int!
  max: locations_max_fields
  min: locations_min_fields
}

"""
Boolean expression to filter rows from the table "locations". All fields are combined with a logical 'AND'.
"""
input locations_bool_exp {
  _and: [locations_bool_exp!]
  _not: locations_bool_exp
  _or: [locations_bool_exp!]
  buidling_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "locations"
"""
enum locations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  locations_pkey
}

"""
input type for inserting data into table "locations"
"""
input locations_insert_input {
  buidling_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  updated_at: timestamptz
}

"""aggregate max on columns"""
type locations_max_fields {
  buidling_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type locations_min_fields {
  buidling_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "locations"
"""
type locations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [locations!]!
}

"""
on_conflict condition type for table "locations"
"""
input locations_on_conflict {
  constraint: locations_constraint!
  update_columns: [locations_update_column!]! = []
  where: locations_bool_exp
}

"""Ordering options when selecting data from "locations"."""
input locations_order_by {
  buidling_id: order_by
  created_at: order_by
  id: order_by
  location: order_by
  updated_at: order_by
}

"""primary key columns input for table: locations"""
input locations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "locations"
"""
enum locations_select_column {
  """column name"""
  buidling_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  updated_at
}

"""
input type for updating data in table "locations"
"""
input locations_set_input {
  buidling_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  updated_at: timestamptz
}

"""
Streaming cursor of the table "locations"
"""
input locations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: locations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input locations_stream_cursor_value_input {
  buidling_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  updated_at: timestamptz
}

"""
update columns of table "locations"
"""
enum locations_update_column {
  """column name"""
  buidling_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  updated_at
}

input locations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: locations_set_input

  """filter the rows which have to be updated"""
  where: locations_bool_exp!
}

type LoginReturnType {
  employee: EmployeeType!
  token: String!
}

"""
columns and relationships of "message_statuses"
"""
type message_statuses {
  created_at: timestamptz

  """An object relationship"""
  employee: employees!
  employee_id: uuid!
  id: uuid!

  """An object relationship"""
  message: messages!
  message_id: uuid!
  status: messagestatuses
  updated_at: timestamptz
}

"""
aggregated selection of "message_statuses"
"""
type message_statuses_aggregate {
  aggregate: message_statuses_aggregate_fields
  nodes: [message_statuses!]!
}

input message_statuses_aggregate_bool_exp {
  count: message_statuses_aggregate_bool_exp_count
}

input message_statuses_aggregate_bool_exp_count {
  arguments: [message_statuses_select_column!]
  distinct: Boolean
  filter: message_statuses_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "message_statuses"
"""
type message_statuses_aggregate_fields {
  count(columns: [message_statuses_select_column!], distinct: Boolean): Int!
  max: message_statuses_max_fields
  min: message_statuses_min_fields
}

"""
order by aggregate values of table "message_statuses"
"""
input message_statuses_aggregate_order_by {
  count: order_by
  max: message_statuses_max_order_by
  min: message_statuses_min_order_by
}

"""
input type for inserting array relation for remote table "message_statuses"
"""
input message_statuses_arr_rel_insert_input {
  data: [message_statuses_insert_input!]!

  """upsert condition"""
  on_conflict: message_statuses_on_conflict
}

"""
Boolean expression to filter rows from the table "message_statuses". All fields are combined with a logical 'AND'.
"""
input message_statuses_bool_exp {
  _and: [message_statuses_bool_exp!]
  _not: message_statuses_bool_exp
  _or: [message_statuses_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  message: messages_bool_exp
  message_id: uuid_comparison_exp
  status: messagestatuses_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "message_statuses"
"""
enum message_statuses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  message_statuses_pkey
}

"""
input type for inserting data into table "message_statuses"
"""
input message_statuses_insert_input {
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  message: messages_obj_rel_insert_input
  message_id: uuid
  status: messagestatuses
  updated_at: timestamptz
}

"""aggregate max on columns"""
type message_statuses_max_fields {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  message_id: uuid
  status: messagestatuses
  updated_at: timestamptz
}

"""
order by max() on columns of table "message_statuses"
"""
input message_statuses_max_order_by {
  created_at: order_by
  employee_id: order_by
  id: order_by
  message_id: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type message_statuses_min_fields {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  message_id: uuid
  status: messagestatuses
  updated_at: timestamptz
}

"""
order by min() on columns of table "message_statuses"
"""
input message_statuses_min_order_by {
  created_at: order_by
  employee_id: order_by
  id: order_by
  message_id: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "message_statuses"
"""
type message_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [message_statuses!]!
}

"""
on_conflict condition type for table "message_statuses"
"""
input message_statuses_on_conflict {
  constraint: message_statuses_constraint!
  update_columns: [message_statuses_update_column!]! = []
  where: message_statuses_bool_exp
}

"""Ordering options when selecting data from "message_statuses"."""
input message_statuses_order_by {
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  message: messages_order_by
  message_id: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: message_statuses"""
input message_statuses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "message_statuses"
"""
enum message_statuses_select_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  message_id

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "message_statuses"
"""
input message_statuses_set_input {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  message_id: uuid
  status: messagestatuses
  updated_at: timestamptz
}

"""
Streaming cursor of the table "message_statuses"
"""
input message_statuses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: message_statuses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input message_statuses_stream_cursor_value_input {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  message_id: uuid
  status: messagestatuses
  updated_at: timestamptz
}

"""
update columns of table "message_statuses"
"""
enum message_statuses_update_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  message_id

  """column name"""
  status

  """column name"""
  updated_at
}

input message_statuses_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: message_statuses_set_input

  """filter the rows which have to be updated"""
  where: message_statuses_bool_exp!
}

input MessageInput {
  content: String!
  conversationId: UUID!
  employeeId: UUID!
}

"""
columns and relationships of "messages"
"""
type messages {
  """An array relationship"""
  attachments(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """An aggregate relationship"""
  attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): attachments_aggregate!
  content: String

  """An object relationship"""
  conversation: conversations!
  conversation_id: uuid!
  created_at: timestamptz

  """An object relationship"""
  employee: employees!

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!
  id: uuid!
  is_read: Boolean
  message_mobile_id: String

  """An array relationship"""
  message_statuses(
    """distinct select on columns"""
    distinct_on: [message_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_statuses_order_by!]

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): [message_statuses!]!

  """An aggregate relationship"""
  message_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [message_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_statuses_order_by!]

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): message_statuses_aggregate!
  sender_id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "messages"
"""
type messages_aggregate {
  aggregate: messages_aggregate_fields
  nodes: [messages!]!
}

input messages_aggregate_bool_exp {
  bool_and: messages_aggregate_bool_exp_bool_and
  bool_or: messages_aggregate_bool_exp_bool_or
  count: messages_aggregate_bool_exp_count
}

input messages_aggregate_bool_exp_bool_and {
  arguments: messages_select_column_messages_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Boolean_comparison_exp!
}

input messages_aggregate_bool_exp_bool_or {
  arguments: messages_select_column_messages_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Boolean_comparison_exp!
}

input messages_aggregate_bool_exp_count {
  arguments: [messages_select_column!]
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "messages"
"""
type messages_aggregate_fields {
  count(columns: [messages_select_column!], distinct: Boolean): Int!
  max: messages_max_fields
  min: messages_min_fields
}

"""
order by aggregate values of table "messages"
"""
input messages_aggregate_order_by {
  count: order_by
  max: messages_max_order_by
  min: messages_min_order_by
}

"""
input type for inserting array relation for remote table "messages"
"""
input messages_arr_rel_insert_input {
  data: [messages_insert_input!]!

  """upsert condition"""
  on_conflict: messages_on_conflict
}

"""
Boolean expression to filter rows from the table "messages". All fields are combined with a logical 'AND'.
"""
input messages_bool_exp {
  _and: [messages_bool_exp!]
  _not: messages_bool_exp
  _or: [messages_bool_exp!]
  attachments: attachments_bool_exp
  attachments_aggregate: attachments_aggregate_bool_exp
  content: String_comparison_exp
  conversation: conversations_bool_exp
  conversation_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_notifications: employee_notifications_bool_exp
  employee_notifications_aggregate: employee_notifications_aggregate_bool_exp
  id: uuid_comparison_exp
  is_read: Boolean_comparison_exp
  message_mobile_id: String_comparison_exp
  message_statuses: message_statuses_bool_exp
  message_statuses_aggregate: message_statuses_aggregate_bool_exp
  sender_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "messages"
"""
enum messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  messages_pkey
}

"""
input type for inserting data into table "messages"
"""
input messages_insert_input {
  attachments: attachments_arr_rel_insert_input
  content: String
  conversation: conversations_obj_rel_insert_input
  conversation_id: uuid
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_notifications: employee_notifications_arr_rel_insert_input
  id: uuid
  is_read: Boolean
  message_mobile_id: String
  message_statuses: message_statuses_arr_rel_insert_input
  sender_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type messages_max_fields {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  message_mobile_id: String
  sender_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "messages"
"""
input messages_max_order_by {
  content: order_by
  conversation_id: order_by
  created_at: order_by
  id: order_by
  message_mobile_id: order_by
  sender_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type messages_min_fields {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  message_mobile_id: String
  sender_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "messages"
"""
input messages_min_order_by {
  content: order_by
  conversation_id: order_by
  created_at: order_by
  id: order_by
  message_mobile_id: order_by
  sender_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "messages"
"""
type messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [messages!]!
}

"""
input type for inserting object relation for remote table "messages"
"""
input messages_obj_rel_insert_input {
  data: messages_insert_input!

  """upsert condition"""
  on_conflict: messages_on_conflict
}

"""
on_conflict condition type for table "messages"
"""
input messages_on_conflict {
  constraint: messages_constraint!
  update_columns: [messages_update_column!]! = []
  where: messages_bool_exp
}

"""Ordering options when selecting data from "messages"."""
input messages_order_by {
  attachments_aggregate: attachments_aggregate_order_by
  content: order_by
  conversation: conversations_order_by
  conversation_id: order_by
  created_at: order_by
  employee: employees_order_by
  employee_notifications_aggregate: employee_notifications_aggregate_order_by
  id: order_by
  is_read: order_by
  message_mobile_id: order_by
  message_statuses_aggregate: message_statuses_aggregate_order_by
  sender_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: messages"""
input messages_pk_columns_input {
  id: uuid!
}

"""
select columns of table "messages"
"""
enum messages_select_column {
  """column name"""
  content

  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_read

  """column name"""
  message_mobile_id

  """column name"""
  sender_id

  """column name"""
  updated_at
}

"""
select "messages_aggregate_bool_exp_bool_and_arguments_columns" columns of table "messages"
"""
enum messages_select_column_messages_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_read
}

"""
select "messages_aggregate_bool_exp_bool_or_arguments_columns" columns of table "messages"
"""
enum messages_select_column_messages_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_read
}

"""
input type for updating data in table "messages"
"""
input messages_set_input {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  is_read: Boolean
  message_mobile_id: String
  sender_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "messages"
"""
input messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input messages_stream_cursor_value_input {
  content: String
  conversation_id: uuid
  created_at: timestamptz
  id: uuid
  is_read: Boolean
  message_mobile_id: String
  sender_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "messages"
"""
enum messages_update_column {
  """column name"""
  content

  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_read

  """column name"""
  message_mobile_id

  """column name"""
  sender_id

  """column name"""
  updated_at
}

input messages_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: messages_set_input

  """filter the rows which have to be updated"""
  where: messages_bool_exp!
}

scalar messagestatuses

"""
Boolean expression to compare columns of type "messagestatuses". All fields are combined with logical 'AND'.
"""
input messagestatuses_comparison_exp {
  _eq: messagestatuses
  _gt: messagestatuses
  _gte: messagestatuses
  _in: [messagestatuses!]
  _is_null: Boolean
  _lt: messagestatuses
  _lte: messagestatuses
  _neq: messagestatuses
  _nin: [messagestatuses!]
}

input MessageStatusInput {
  id: [UUID!]!
  status: String!
}

type MessageStatusOutput {
  state: String!
}

"""mutation root"""
type mutation_root {
  acceptParticipateEvents(participant: ParticipantInput!): AcceptParcipateEvent!
  addMessage(inputs: MessageInput!): InsertMesaageOuput!
  createConversation(conversation: CreateConvInput!): CreateConvOutput!
  createEmployee(employee: CreateEmployeeInput!): EmployeeCreationType!
  createVisitor(visitor: AddVisitorBrowserInputType!): CreateVisitorType!
  declineParticipateEvents(participant: ParticipantInput!): DenyParcipateEvent!

  """
  delete data from the table: "agencies"
  """
  delete_agencies(
    """filter the rows which have to be deleted"""
    where: agencies_bool_exp!
  ): agencies_mutation_response

  """
  delete single row from the table: "agencies"
  """
  delete_agencies_by_pk(id: uuid!): agencies

  """
  delete data from the table: "alarms"
  """
  delete_alarms(
    """filter the rows which have to be deleted"""
    where: alarms_bool_exp!
  ): alarms_mutation_response

  """
  delete single row from the table: "alarms"
  """
  delete_alarms_by_pk(id: uuid!): alarms

  """
  delete data from the table: "app_versions"
  """
  delete_app_versions(
    """filter the rows which have to be deleted"""
    where: app_versions_bool_exp!
  ): app_versions_mutation_response

  """
  delete single row from the table: "app_versions"
  """
  delete_app_versions_by_pk(version: String!): app_versions

  """
  delete data from the table: "appointment_status"
  """
  delete_appointment_status(
    """filter the rows which have to be deleted"""
    where: appointment_status_bool_exp!
  ): appointment_status_mutation_response

  """
  delete single row from the table: "appointment_status"
  """
  delete_appointment_status_by_pk(status: String!): appointment_status

  """
  delete data from the table: "appointments"
  """
  delete_appointments(
    """filter the rows which have to be deleted"""
    where: appointments_bool_exp!
  ): appointments_mutation_response

  """
  delete single row from the table: "appointments"
  """
  delete_appointments_by_pk(id: uuid!): appointments

  """
  delete data from the table: "attachments"
  """
  delete_attachments(
    """filter the rows which have to be deleted"""
    where: attachments_bool_exp!
  ): attachments_mutation_response

  """
  delete single row from the table: "attachments"
  """
  delete_attachments_by_pk(id: uuid!): attachments

  """
  delete data from the table: "attendance"
  """
  delete_attendance(
    """filter the rows which have to be deleted"""
    where: attendance_bool_exp!
  ): attendance_mutation_response

  """
  delete single row from the table: "attendance"
  """
  delete_attendance_by_pk(id: uuid!): attendance

  """
  delete data from the table: "attendance_state"
  """
  delete_attendance_state(
    """filter the rows which have to be deleted"""
    where: attendance_state_bool_exp!
  ): attendance_state_mutation_response

  """
  delete single row from the table: "attendance_state"
  """
  delete_attendance_state_by_pk(id: uuid!): attendance_state

  """
  delete data from the table: "companies"
  """
  delete_companies(
    """filter the rows which have to be deleted"""
    where: companies_bool_exp!
  ): companies_mutation_response

  """
  delete single row from the table: "companies"
  """
  delete_companies_by_pk(id: uuid!): companies

  """
  delete data from the table: "company_settings"
  """
  delete_company_settings(
    """filter the rows which have to be deleted"""
    where: company_settings_bool_exp!
  ): company_settings_mutation_response

  """
  delete single row from the table: "company_settings"
  """
  delete_company_settings_by_pk(id: uuid!): company_settings

  """
  delete data from the table: "conversations"
  """
  delete_conversations(
    """filter the rows which have to be deleted"""
    where: conversations_bool_exp!
  ): conversations_mutation_response

  """
  delete single row from the table: "conversations"
  """
  delete_conversations_by_pk(id: uuid!): conversations

  """
  delete data from the table: "departments"
  """
  delete_departments(
    """filter the rows which have to be deleted"""
    where: departments_bool_exp!
  ): departments_mutation_response

  """
  delete single row from the table: "departments"
  """
  delete_departments_by_pk(id: uuid!): departments

  """
  delete data from the table: "employee_conversation"
  """
  delete_employee_conversation(
    """filter the rows which have to be deleted"""
    where: employee_conversation_bool_exp!
  ): employee_conversation_mutation_response

  """
  delete single row from the table: "employee_conversation"
  """
  delete_employee_conversation_by_pk(id: uuid!): employee_conversation

  """
  delete data from the table: "employee_notifications"
  """
  delete_employee_notifications(
    """filter the rows which have to be deleted"""
    where: employee_notifications_bool_exp!
  ): employee_notifications_mutation_response

  """
  delete single row from the table: "employee_notifications"
  """
  delete_employee_notifications_by_pk(id: uuid!): employee_notifications

  """
  delete data from the table: "employee_roles"
  """
  delete_employee_roles(
    """filter the rows which have to be deleted"""
    where: employee_roles_bool_exp!
  ): employee_roles_mutation_response

  """
  delete single row from the table: "employee_roles"
  """
  delete_employee_roles_by_pk(id: uuid!): employee_roles

  """
  delete data from the table: "employee_shifts"
  """
  delete_employee_shifts(
    """filter the rows which have to be deleted"""
    where: employee_shifts_bool_exp!
  ): employee_shifts_mutation_response

  """
  delete single row from the table: "employee_shifts"
  """
  delete_employee_shifts_by_pk(id: uuid!): employee_shifts

  """
  delete data from the table: "employees"
  """
  delete_employees(
    """filter the rows which have to be deleted"""
    where: employees_bool_exp!
  ): employees_mutation_response

  """
  delete single row from the table: "employees"
  """
  delete_employees_by_pk(id: uuid!): employees

  """
  delete data from the table: "event_notification"
  """
  delete_event_notification(
    """filter the rows which have to be deleted"""
    where: event_notification_bool_exp!
  ): event_notification_mutation_response

  """
  delete single row from the table: "event_notification"
  """
  delete_event_notification_by_pk(id: uuid!): event_notification

  """
  delete data from the table: "event_participants"
  """
  delete_event_participants(
    """filter the rows which have to be deleted"""
    where: event_participants_bool_exp!
  ): event_participants_mutation_response

  """
  delete single row from the table: "event_participants"
  """
  delete_event_participants_by_pk(id: uuid!): event_participants

  """
  delete data from the table: "events"
  """
  delete_events(
    """filter the rows which have to be deleted"""
    where: events_bool_exp!
  ): events_mutation_response

  """
  delete single row from the table: "events"
  """
  delete_events_by_pk(id: uuid!): events

  """
  delete data from the table: "files"
  """
  delete_files(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "files"
  """
  delete_files_by_pk(id: uuid!): files

  """
  delete data from the table: "gender"
  """
  delete_gender(
    """filter the rows which have to be deleted"""
    where: gender_bool_exp!
  ): gender_mutation_response

  """
  delete single row from the table: "gender"
  """
  delete_gender_by_pk(gender: String!): gender

  """
  delete data from the table: "geometry_columns"
  """
  delete_geometry_columns(
    """filter the rows which have to be deleted"""
    where: geometry_columns_bool_exp!
  ): geometry_columns_mutation_response

  """
  delete data from the table: "group_members"
  """
  delete_group_members(
    """filter the rows which have to be deleted"""
    where: group_members_bool_exp!
  ): group_members_mutation_response

  """
  delete single row from the table: "group_members"
  """
  delete_group_members_by_pk(id: uuid!): group_members

  """
  delete data from the table: "group_messages"
  """
  delete_group_messages(
    """filter the rows which have to be deleted"""
    where: group_messages_bool_exp!
  ): group_messages_mutation_response

  """
  delete single row from the table: "group_messages"
  """
  delete_group_messages_by_pk(id: uuid!): group_messages

  """
  delete data from the table: "groups"
  """
  delete_groups(
    """filter the rows which have to be deleted"""
    where: groups_bool_exp!
  ): groups_mutation_response

  """
  delete single row from the table: "groups"
  """
  delete_groups_by_pk(id: uuid!): groups

  """
  delete data from the table: "leave_approval"
  """
  delete_leave_approval(
    """filter the rows which have to be deleted"""
    where: leave_approval_bool_exp!
  ): leave_approval_mutation_response

  """
  delete single row from the table: "leave_approval"
  """
  delete_leave_approval_by_pk(id: uuid!): leave_approval

  """
  delete data from the table: "leave_approval_status"
  """
  delete_leave_approval_status(
    """filter the rows which have to be deleted"""
    where: leave_approval_status_bool_exp!
  ): leave_approval_status_mutation_response

  """
  delete single row from the table: "leave_approval_status"
  """
  delete_leave_approval_status_by_pk(id: uuid!): leave_approval_status

  """
  delete data from the table: "leave_status"
  """
  delete_leave_status(
    """filter the rows which have to be deleted"""
    where: leave_status_bool_exp!
  ): leave_status_mutation_response

  """
  delete single row from the table: "leave_status"
  """
  delete_leave_status_by_pk(status: String!): leave_status

  """
  delete data from the table: "leave_type"
  """
  delete_leave_type(
    """filter the rows which have to be deleted"""
    where: leave_type_bool_exp!
  ): leave_type_mutation_response

  """
  delete single row from the table: "leave_type"
  """
  delete_leave_type_by_pk(type: String!): leave_type

  """
  delete data from the table: "leave_types"
  """
  delete_leave_types(
    """filter the rows which have to be deleted"""
    where: leave_types_bool_exp!
  ): leave_types_mutation_response

  """
  delete single row from the table: "leave_types"
  """
  delete_leave_types_by_pk(id: uuid!): leave_types

  """
  delete data from the table: "leaves"
  """
  delete_leaves(
    """filter the rows which have to be deleted"""
    where: leaves_bool_exp!
  ): leaves_mutation_response

  """
  delete single row from the table: "leaves"
  """
  delete_leaves_by_pk(id: uuid!): leaves

  """
  delete data from the table: "locations"
  """
  delete_locations(
    """filter the rows which have to be deleted"""
    where: locations_bool_exp!
  ): locations_mutation_response

  """
  delete single row from the table: "locations"
  """
  delete_locations_by_pk(id: uuid!): locations

  """
  delete data from the table: "message_statuses"
  """
  delete_message_statuses(
    """filter the rows which have to be deleted"""
    where: message_statuses_bool_exp!
  ): message_statuses_mutation_response

  """
  delete single row from the table: "message_statuses"
  """
  delete_message_statuses_by_pk(id: uuid!): message_statuses

  """
  delete data from the table: "messages"
  """
  delete_messages(
    """filter the rows which have to be deleted"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  delete single row from the table: "messages"
  """
  delete_messages_by_pk(id: uuid!): messages

  """
  delete data from the table: "positions"
  """
  delete_positions(
    """filter the rows which have to be deleted"""
    where: positions_bool_exp!
  ): positions_mutation_response

  """
  delete single row from the table: "positions"
  """
  delete_positions_by_pk(id: uuid!): positions

  """
  delete data from the table: "reports"
  """
  delete_reports(
    """filter the rows which have to be deleted"""
    where: reports_bool_exp!
  ): reports_mutation_response

  """
  delete single row from the table: "reports"
  """
  delete_reports_by_pk(id: uuid!): reports

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(id: uuid!): roles

  """
  delete data from the table: "services"
  """
  delete_services(
    """filter the rows which have to be deleted"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  delete single row from the table: "services"
  """
  delete_services_by_pk(id: uuid!): services

  """
  delete data from the table: "shifts"
  """
  delete_shifts(
    """filter the rows which have to be deleted"""
    where: shifts_bool_exp!
  ): shifts_mutation_response

  """
  delete single row from the table: "shifts"
  """
  delete_shifts_by_pk(id: uuid!): shifts

  """
  delete data from the table: "spatial_ref_sys"
  """
  delete_spatial_ref_sys(
    """filter the rows which have to be deleted"""
    where: spatial_ref_sys_bool_exp!
  ): spatial_ref_sys_mutation_response

  """
  delete single row from the table: "spatial_ref_sys"
  """
  delete_spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  """
  delete data from the table: "status"
  """
  delete_status(
    """filter the rows which have to be deleted"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  delete single row from the table: "status"
  """
  delete_status_by_pk(status: String!): status

  """
  delete data from the table: "task_status"
  """
  delete_task_status(
    """filter the rows which have to be deleted"""
    where: task_status_bool_exp!
  ): task_status_mutation_response

  """
  delete single row from the table: "task_status"
  """
  delete_task_status_by_pk(id: uuid!): task_status

  """
  delete data from the table: "tasks"
  """
  delete_tasks(
    """filter the rows which have to be deleted"""
    where: tasks_bool_exp!
  ): tasks_mutation_response

  """
  delete single row from the table: "tasks"
  """
  delete_tasks_by_pk(id: uuid!): tasks

  """
  delete data from the table: "text_content"
  """
  delete_text_content(
    """filter the rows which have to be deleted"""
    where: text_content_bool_exp!
  ): text_content_mutation_response

  """
  delete single row from the table: "text_content"
  """
  delete_text_content_by_pk(id: uuid!): text_content

  """
  delete data from the table: "topology.layer"
  """
  delete_topology_layer(
    """filter the rows which have to be deleted"""
    where: topology_layer_bool_exp!
  ): topology_layer_mutation_response

  """
  delete single row from the table: "topology.layer"
  """
  delete_topology_layer_by_pk(layer_id: Int!, topology_id: Int!): topology_layer

  """
  delete data from the table: "topology.topology"
  """
  delete_topology_topology(
    """filter the rows which have to be deleted"""
    where: topology_topology_bool_exp!
  ): topology_topology_mutation_response

  """
  delete single row from the table: "topology.topology"
  """
  delete_topology_topology_by_pk(id: Int!): topology_topology

  """
  delete data from the table: "translations"
  """
  delete_translations(
    """filter the rows which have to be deleted"""
    where: translations_bool_exp!
  ): translations_mutation_response

  """
  delete single row from the table: "translations"
  """
  delete_translations_by_pk(id: uuid!): translations

  """
  delete data from the table: "typing_statuses"
  """
  delete_typing_statuses(
    """filter the rows which have to be deleted"""
    where: typing_statuses_bool_exp!
  ): typing_statuses_mutation_response

  """
  delete single row from the table: "typing_statuses"
  """
  delete_typing_statuses_by_pk(id: uuid!): typing_statuses

  """
  delete data from the table: "vehicles"
  """
  delete_vehicles(
    """filter the rows which have to be deleted"""
    where: vehicles_bool_exp!
  ): vehicles_mutation_response

  """
  delete single row from the table: "vehicles"
  """
  delete_vehicles_by_pk(id: uuid!): vehicles

  """
  delete data from the table: "visit_status"
  """
  delete_visit_status(
    """filter the rows which have to be deleted"""
    where: visit_status_bool_exp!
  ): visit_status_mutation_response

  """
  delete single row from the table: "visit_status"
  """
  delete_visit_status_by_pk(status: String!): visit_status

  """
  delete data from the table: "visitors"
  """
  delete_visitors(
    """filter the rows which have to be deleted"""
    where: visitors_bool_exp!
  ): visitors_mutation_response

  """
  delete single row from the table: "visitors"
  """
  delete_visitors_by_pk(id: uuid!): visitors

  """
  delete data from the table: "visits"
  """
  delete_visits(
    """filter the rows which have to be deleted"""
    where: visits_bool_exp!
  ): visits_mutation_response

  """
  delete single row from the table: "visits"
  """
  delete_visits_by_pk(id: uuid!): visits

  """
  insert data into the table: "agencies"
  """
  insert_agencies(
    """the rows to be inserted"""
    objects: [agencies_insert_input!]!

    """upsert condition"""
    on_conflict: agencies_on_conflict
  ): agencies_mutation_response

  """
  insert a single row into the table: "agencies"
  """
  insert_agencies_one(
    """the row to be inserted"""
    object: agencies_insert_input!

    """upsert condition"""
    on_conflict: agencies_on_conflict
  ): agencies

  """
  insert data into the table: "alarms"
  """
  insert_alarms(
    """the rows to be inserted"""
    objects: [alarms_insert_input!]!

    """upsert condition"""
    on_conflict: alarms_on_conflict
  ): alarms_mutation_response

  """
  insert a single row into the table: "alarms"
  """
  insert_alarms_one(
    """the row to be inserted"""
    object: alarms_insert_input!

    """upsert condition"""
    on_conflict: alarms_on_conflict
  ): alarms

  """
  insert data into the table: "app_versions"
  """
  insert_app_versions(
    """the rows to be inserted"""
    objects: [app_versions_insert_input!]!

    """upsert condition"""
    on_conflict: app_versions_on_conflict
  ): app_versions_mutation_response

  """
  insert a single row into the table: "app_versions"
  """
  insert_app_versions_one(
    """the row to be inserted"""
    object: app_versions_insert_input!

    """upsert condition"""
    on_conflict: app_versions_on_conflict
  ): app_versions

  """
  insert data into the table: "appointment_status"
  """
  insert_appointment_status(
    """the rows to be inserted"""
    objects: [appointment_status_insert_input!]!

    """upsert condition"""
    on_conflict: appointment_status_on_conflict
  ): appointment_status_mutation_response

  """
  insert a single row into the table: "appointment_status"
  """
  insert_appointment_status_one(
    """the row to be inserted"""
    object: appointment_status_insert_input!

    """upsert condition"""
    on_conflict: appointment_status_on_conflict
  ): appointment_status

  """
  insert data into the table: "appointments"
  """
  insert_appointments(
    """the rows to be inserted"""
    objects: [appointments_insert_input!]!

    """upsert condition"""
    on_conflict: appointments_on_conflict
  ): appointments_mutation_response

  """
  insert a single row into the table: "appointments"
  """
  insert_appointments_one(
    """the row to be inserted"""
    object: appointments_insert_input!

    """upsert condition"""
    on_conflict: appointments_on_conflict
  ): appointments

  """
  insert data into the table: "attachments"
  """
  insert_attachments(
    """the rows to be inserted"""
    objects: [attachments_insert_input!]!

    """upsert condition"""
    on_conflict: attachments_on_conflict
  ): attachments_mutation_response

  """
  insert a single row into the table: "attachments"
  """
  insert_attachments_one(
    """the row to be inserted"""
    object: attachments_insert_input!

    """upsert condition"""
    on_conflict: attachments_on_conflict
  ): attachments

  """
  insert data into the table: "attendance"
  """
  insert_attendance(
    """the rows to be inserted"""
    objects: [attendance_insert_input!]!

    """upsert condition"""
    on_conflict: attendance_on_conflict
  ): attendance_mutation_response

  """
  insert a single row into the table: "attendance"
  """
  insert_attendance_one(
    """the row to be inserted"""
    object: attendance_insert_input!

    """upsert condition"""
    on_conflict: attendance_on_conflict
  ): attendance

  """
  insert data into the table: "attendance_state"
  """
  insert_attendance_state(
    """the rows to be inserted"""
    objects: [attendance_state_insert_input!]!

    """upsert condition"""
    on_conflict: attendance_state_on_conflict
  ): attendance_state_mutation_response

  """
  insert a single row into the table: "attendance_state"
  """
  insert_attendance_state_one(
    """the row to be inserted"""
    object: attendance_state_insert_input!

    """upsert condition"""
    on_conflict: attendance_state_on_conflict
  ): attendance_state

  """
  insert data into the table: "companies"
  """
  insert_companies(
    """the rows to be inserted"""
    objects: [companies_insert_input!]!

    """upsert condition"""
    on_conflict: companies_on_conflict
  ): companies_mutation_response

  """
  insert a single row into the table: "companies"
  """
  insert_companies_one(
    """the row to be inserted"""
    object: companies_insert_input!

    """upsert condition"""
    on_conflict: companies_on_conflict
  ): companies

  """
  insert data into the table: "company_settings"
  """
  insert_company_settings(
    """the rows to be inserted"""
    objects: [company_settings_insert_input!]!

    """upsert condition"""
    on_conflict: company_settings_on_conflict
  ): company_settings_mutation_response

  """
  insert a single row into the table: "company_settings"
  """
  insert_company_settings_one(
    """the row to be inserted"""
    object: company_settings_insert_input!

    """upsert condition"""
    on_conflict: company_settings_on_conflict
  ): company_settings

  """
  insert data into the table: "conversations"
  """
  insert_conversations(
    """the rows to be inserted"""
    objects: [conversations_insert_input!]!

    """upsert condition"""
    on_conflict: conversations_on_conflict
  ): conversations_mutation_response

  """
  insert a single row into the table: "conversations"
  """
  insert_conversations_one(
    """the row to be inserted"""
    object: conversations_insert_input!

    """upsert condition"""
    on_conflict: conversations_on_conflict
  ): conversations

  """
  insert data into the table: "departments"
  """
  insert_departments(
    """the rows to be inserted"""
    objects: [departments_insert_input!]!

    """upsert condition"""
    on_conflict: departments_on_conflict
  ): departments_mutation_response

  """
  insert a single row into the table: "departments"
  """
  insert_departments_one(
    """the row to be inserted"""
    object: departments_insert_input!

    """upsert condition"""
    on_conflict: departments_on_conflict
  ): departments

  """
  insert data into the table: "employee_conversation"
  """
  insert_employee_conversation(
    """the rows to be inserted"""
    objects: [employee_conversation_insert_input!]!

    """upsert condition"""
    on_conflict: employee_conversation_on_conflict
  ): employee_conversation_mutation_response

  """
  insert a single row into the table: "employee_conversation"
  """
  insert_employee_conversation_one(
    """the row to be inserted"""
    object: employee_conversation_insert_input!

    """upsert condition"""
    on_conflict: employee_conversation_on_conflict
  ): employee_conversation

  """
  insert data into the table: "employee_notifications"
  """
  insert_employee_notifications(
    """the rows to be inserted"""
    objects: [employee_notifications_insert_input!]!

    """upsert condition"""
    on_conflict: employee_notifications_on_conflict
  ): employee_notifications_mutation_response

  """
  insert a single row into the table: "employee_notifications"
  """
  insert_employee_notifications_one(
    """the row to be inserted"""
    object: employee_notifications_insert_input!

    """upsert condition"""
    on_conflict: employee_notifications_on_conflict
  ): employee_notifications

  """
  insert data into the table: "employee_roles"
  """
  insert_employee_roles(
    """the rows to be inserted"""
    objects: [employee_roles_insert_input!]!

    """upsert condition"""
    on_conflict: employee_roles_on_conflict
  ): employee_roles_mutation_response

  """
  insert a single row into the table: "employee_roles"
  """
  insert_employee_roles_one(
    """the row to be inserted"""
    object: employee_roles_insert_input!

    """upsert condition"""
    on_conflict: employee_roles_on_conflict
  ): employee_roles

  """
  insert data into the table: "employee_shifts"
  """
  insert_employee_shifts(
    """the rows to be inserted"""
    objects: [employee_shifts_insert_input!]!

    """upsert condition"""
    on_conflict: employee_shifts_on_conflict
  ): employee_shifts_mutation_response

  """
  insert a single row into the table: "employee_shifts"
  """
  insert_employee_shifts_one(
    """the row to be inserted"""
    object: employee_shifts_insert_input!

    """upsert condition"""
    on_conflict: employee_shifts_on_conflict
  ): employee_shifts

  """
  insert data into the table: "employees"
  """
  insert_employees(
    """the rows to be inserted"""
    objects: [employees_insert_input!]!

    """upsert condition"""
    on_conflict: employees_on_conflict
  ): employees_mutation_response

  """
  insert a single row into the table: "employees"
  """
  insert_employees_one(
    """the row to be inserted"""
    object: employees_insert_input!

    """upsert condition"""
    on_conflict: employees_on_conflict
  ): employees

  """
  insert data into the table: "event_notification"
  """
  insert_event_notification(
    """the rows to be inserted"""
    objects: [event_notification_insert_input!]!

    """upsert condition"""
    on_conflict: event_notification_on_conflict
  ): event_notification_mutation_response

  """
  insert a single row into the table: "event_notification"
  """
  insert_event_notification_one(
    """the row to be inserted"""
    object: event_notification_insert_input!

    """upsert condition"""
    on_conflict: event_notification_on_conflict
  ): event_notification

  """
  insert data into the table: "event_participants"
  """
  insert_event_participants(
    """the rows to be inserted"""
    objects: [event_participants_insert_input!]!

    """upsert condition"""
    on_conflict: event_participants_on_conflict
  ): event_participants_mutation_response

  """
  insert a single row into the table: "event_participants"
  """
  insert_event_participants_one(
    """the row to be inserted"""
    object: event_participants_insert_input!

    """upsert condition"""
    on_conflict: event_participants_on_conflict
  ): event_participants

  """
  insert data into the table: "events"
  """
  insert_events(
    """the rows to be inserted"""
    objects: [events_insert_input!]!

    """upsert condition"""
    on_conflict: events_on_conflict
  ): events_mutation_response

  """
  insert a single row into the table: "events"
  """
  insert_events_one(
    """the row to be inserted"""
    object: events_insert_input!

    """upsert condition"""
    on_conflict: events_on_conflict
  ): events

  """
  insert data into the table: "files"
  """
  insert_files(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "files"
  """
  insert_files_one(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "gender"
  """
  insert_gender(
    """the rows to be inserted"""
    objects: [gender_insert_input!]!

    """upsert condition"""
    on_conflict: gender_on_conflict
  ): gender_mutation_response

  """
  insert a single row into the table: "gender"
  """
  insert_gender_one(
    """the row to be inserted"""
    object: gender_insert_input!

    """upsert condition"""
    on_conflict: gender_on_conflict
  ): gender

  """
  insert data into the table: "geometry_columns"
  """
  insert_geometry_columns(
    """the rows to be inserted"""
    objects: [geometry_columns_insert_input!]!
  ): geometry_columns_mutation_response

  """
  insert a single row into the table: "geometry_columns"
  """
  insert_geometry_columns_one(
    """the row to be inserted"""
    object: geometry_columns_insert_input!
  ): geometry_columns

  """
  insert data into the table: "group_members"
  """
  insert_group_members(
    """the rows to be inserted"""
    objects: [group_members_insert_input!]!

    """upsert condition"""
    on_conflict: group_members_on_conflict
  ): group_members_mutation_response

  """
  insert a single row into the table: "group_members"
  """
  insert_group_members_one(
    """the row to be inserted"""
    object: group_members_insert_input!

    """upsert condition"""
    on_conflict: group_members_on_conflict
  ): group_members

  """
  insert data into the table: "group_messages"
  """
  insert_group_messages(
    """the rows to be inserted"""
    objects: [group_messages_insert_input!]!

    """upsert condition"""
    on_conflict: group_messages_on_conflict
  ): group_messages_mutation_response

  """
  insert a single row into the table: "group_messages"
  """
  insert_group_messages_one(
    """the row to be inserted"""
    object: group_messages_insert_input!

    """upsert condition"""
    on_conflict: group_messages_on_conflict
  ): group_messages

  """
  insert data into the table: "groups"
  """
  insert_groups(
    """the rows to be inserted"""
    objects: [groups_insert_input!]!

    """upsert condition"""
    on_conflict: groups_on_conflict
  ): groups_mutation_response

  """
  insert a single row into the table: "groups"
  """
  insert_groups_one(
    """the row to be inserted"""
    object: groups_insert_input!

    """upsert condition"""
    on_conflict: groups_on_conflict
  ): groups

  """
  insert data into the table: "leave_approval"
  """
  insert_leave_approval(
    """the rows to be inserted"""
    objects: [leave_approval_insert_input!]!

    """upsert condition"""
    on_conflict: leave_approval_on_conflict
  ): leave_approval_mutation_response

  """
  insert a single row into the table: "leave_approval"
  """
  insert_leave_approval_one(
    """the row to be inserted"""
    object: leave_approval_insert_input!

    """upsert condition"""
    on_conflict: leave_approval_on_conflict
  ): leave_approval

  """
  insert data into the table: "leave_approval_status"
  """
  insert_leave_approval_status(
    """the rows to be inserted"""
    objects: [leave_approval_status_insert_input!]!

    """upsert condition"""
    on_conflict: leave_approval_status_on_conflict
  ): leave_approval_status_mutation_response

  """
  insert a single row into the table: "leave_approval_status"
  """
  insert_leave_approval_status_one(
    """the row to be inserted"""
    object: leave_approval_status_insert_input!

    """upsert condition"""
    on_conflict: leave_approval_status_on_conflict
  ): leave_approval_status

  """
  insert data into the table: "leave_status"
  """
  insert_leave_status(
    """the rows to be inserted"""
    objects: [leave_status_insert_input!]!

    """upsert condition"""
    on_conflict: leave_status_on_conflict
  ): leave_status_mutation_response

  """
  insert a single row into the table: "leave_status"
  """
  insert_leave_status_one(
    """the row to be inserted"""
    object: leave_status_insert_input!

    """upsert condition"""
    on_conflict: leave_status_on_conflict
  ): leave_status

  """
  insert data into the table: "leave_type"
  """
  insert_leave_type(
    """the rows to be inserted"""
    objects: [leave_type_insert_input!]!

    """upsert condition"""
    on_conflict: leave_type_on_conflict
  ): leave_type_mutation_response

  """
  insert a single row into the table: "leave_type"
  """
  insert_leave_type_one(
    """the row to be inserted"""
    object: leave_type_insert_input!

    """upsert condition"""
    on_conflict: leave_type_on_conflict
  ): leave_type

  """
  insert data into the table: "leave_types"
  """
  insert_leave_types(
    """the rows to be inserted"""
    objects: [leave_types_insert_input!]!

    """upsert condition"""
    on_conflict: leave_types_on_conflict
  ): leave_types_mutation_response

  """
  insert a single row into the table: "leave_types"
  """
  insert_leave_types_one(
    """the row to be inserted"""
    object: leave_types_insert_input!

    """upsert condition"""
    on_conflict: leave_types_on_conflict
  ): leave_types

  """
  insert data into the table: "leaves"
  """
  insert_leaves(
    """the rows to be inserted"""
    objects: [leaves_insert_input!]!

    """upsert condition"""
    on_conflict: leaves_on_conflict
  ): leaves_mutation_response

  """
  insert a single row into the table: "leaves"
  """
  insert_leaves_one(
    """the row to be inserted"""
    object: leaves_insert_input!

    """upsert condition"""
    on_conflict: leaves_on_conflict
  ): leaves

  """
  insert data into the table: "locations"
  """
  insert_locations(
    """the rows to be inserted"""
    objects: [locations_insert_input!]!

    """upsert condition"""
    on_conflict: locations_on_conflict
  ): locations_mutation_response

  """
  insert a single row into the table: "locations"
  """
  insert_locations_one(
    """the row to be inserted"""
    object: locations_insert_input!

    """upsert condition"""
    on_conflict: locations_on_conflict
  ): locations

  """
  insert data into the table: "message_statuses"
  """
  insert_message_statuses(
    """the rows to be inserted"""
    objects: [message_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: message_statuses_on_conflict
  ): message_statuses_mutation_response

  """
  insert a single row into the table: "message_statuses"
  """
  insert_message_statuses_one(
    """the row to be inserted"""
    object: message_statuses_insert_input!

    """upsert condition"""
    on_conflict: message_statuses_on_conflict
  ): message_statuses

  """
  insert data into the table: "messages"
  """
  insert_messages(
    """the rows to be inserted"""
    objects: [messages_insert_input!]!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages_mutation_response

  """
  insert a single row into the table: "messages"
  """
  insert_messages_one(
    """the row to be inserted"""
    object: messages_insert_input!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages

  """
  insert data into the table: "positions"
  """
  insert_positions(
    """the rows to be inserted"""
    objects: [positions_insert_input!]!

    """upsert condition"""
    on_conflict: positions_on_conflict
  ): positions_mutation_response

  """
  insert a single row into the table: "positions"
  """
  insert_positions_one(
    """the row to be inserted"""
    object: positions_insert_input!

    """upsert condition"""
    on_conflict: positions_on_conflict
  ): positions

  """
  insert data into the table: "reports"
  """
  insert_reports(
    """the rows to be inserted"""
    objects: [reports_insert_input!]!

    """upsert condition"""
    on_conflict: reports_on_conflict
  ): reports_mutation_response

  """
  insert a single row into the table: "reports"
  """
  insert_reports_one(
    """the row to be inserted"""
    object: reports_insert_input!

    """upsert condition"""
    on_conflict: reports_on_conflict
  ): reports

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "services"
  """
  insert_services(
    """the rows to be inserted"""
    objects: [services_insert_input!]!

    """upsert condition"""
    on_conflict: services_on_conflict
  ): services_mutation_response

  """
  insert a single row into the table: "services"
  """
  insert_services_one(
    """the row to be inserted"""
    object: services_insert_input!

    """upsert condition"""
    on_conflict: services_on_conflict
  ): services

  """
  insert data into the table: "shifts"
  """
  insert_shifts(
    """the rows to be inserted"""
    objects: [shifts_insert_input!]!

    """upsert condition"""
    on_conflict: shifts_on_conflict
  ): shifts_mutation_response

  """
  insert a single row into the table: "shifts"
  """
  insert_shifts_one(
    """the row to be inserted"""
    object: shifts_insert_input!

    """upsert condition"""
    on_conflict: shifts_on_conflict
  ): shifts

  """
  insert data into the table: "spatial_ref_sys"
  """
  insert_spatial_ref_sys(
    """the rows to be inserted"""
    objects: [spatial_ref_sys_insert_input!]!

    """upsert condition"""
    on_conflict: spatial_ref_sys_on_conflict
  ): spatial_ref_sys_mutation_response

  """
  insert a single row into the table: "spatial_ref_sys"
  """
  insert_spatial_ref_sys_one(
    """the row to be inserted"""
    object: spatial_ref_sys_insert_input!

    """upsert condition"""
    on_conflict: spatial_ref_sys_on_conflict
  ): spatial_ref_sys

  """
  insert data into the table: "status"
  """
  insert_status(
    """the rows to be inserted"""
    objects: [status_insert_input!]!

    """upsert condition"""
    on_conflict: status_on_conflict
  ): status_mutation_response

  """
  insert a single row into the table: "status"
  """
  insert_status_one(
    """the row to be inserted"""
    object: status_insert_input!

    """upsert condition"""
    on_conflict: status_on_conflict
  ): status

  """
  insert data into the table: "task_status"
  """
  insert_task_status(
    """the rows to be inserted"""
    objects: [task_status_insert_input!]!

    """upsert condition"""
    on_conflict: task_status_on_conflict
  ): task_status_mutation_response

  """
  insert a single row into the table: "task_status"
  """
  insert_task_status_one(
    """the row to be inserted"""
    object: task_status_insert_input!

    """upsert condition"""
    on_conflict: task_status_on_conflict
  ): task_status

  """
  insert data into the table: "tasks"
  """
  insert_tasks(
    """the rows to be inserted"""
    objects: [tasks_insert_input!]!

    """upsert condition"""
    on_conflict: tasks_on_conflict
  ): tasks_mutation_response

  """
  insert a single row into the table: "tasks"
  """
  insert_tasks_one(
    """the row to be inserted"""
    object: tasks_insert_input!

    """upsert condition"""
    on_conflict: tasks_on_conflict
  ): tasks

  """
  insert data into the table: "text_content"
  """
  insert_text_content(
    """the rows to be inserted"""
    objects: [text_content_insert_input!]!

    """upsert condition"""
    on_conflict: text_content_on_conflict
  ): text_content_mutation_response

  """
  insert a single row into the table: "text_content"
  """
  insert_text_content_one(
    """the row to be inserted"""
    object: text_content_insert_input!

    """upsert condition"""
    on_conflict: text_content_on_conflict
  ): text_content

  """
  insert data into the table: "topology.layer"
  """
  insert_topology_layer(
    """the rows to be inserted"""
    objects: [topology_layer_insert_input!]!

    """upsert condition"""
    on_conflict: topology_layer_on_conflict
  ): topology_layer_mutation_response

  """
  insert a single row into the table: "topology.layer"
  """
  insert_topology_layer_one(
    """the row to be inserted"""
    object: topology_layer_insert_input!

    """upsert condition"""
    on_conflict: topology_layer_on_conflict
  ): topology_layer

  """
  insert data into the table: "topology.topology"
  """
  insert_topology_topology(
    """the rows to be inserted"""
    objects: [topology_topology_insert_input!]!

    """upsert condition"""
    on_conflict: topology_topology_on_conflict
  ): topology_topology_mutation_response

  """
  insert a single row into the table: "topology.topology"
  """
  insert_topology_topology_one(
    """the row to be inserted"""
    object: topology_topology_insert_input!

    """upsert condition"""
    on_conflict: topology_topology_on_conflict
  ): topology_topology

  """
  insert data into the table: "translations"
  """
  insert_translations(
    """the rows to be inserted"""
    objects: [translations_insert_input!]!

    """upsert condition"""
    on_conflict: translations_on_conflict
  ): translations_mutation_response

  """
  insert a single row into the table: "translations"
  """
  insert_translations_one(
    """the row to be inserted"""
    object: translations_insert_input!

    """upsert condition"""
    on_conflict: translations_on_conflict
  ): translations

  """
  insert data into the table: "typing_statuses"
  """
  insert_typing_statuses(
    """the rows to be inserted"""
    objects: [typing_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: typing_statuses_on_conflict
  ): typing_statuses_mutation_response

  """
  insert a single row into the table: "typing_statuses"
  """
  insert_typing_statuses_one(
    """the row to be inserted"""
    object: typing_statuses_insert_input!

    """upsert condition"""
    on_conflict: typing_statuses_on_conflict
  ): typing_statuses

  """
  insert data into the table: "vehicles"
  """
  insert_vehicles(
    """the rows to be inserted"""
    objects: [vehicles_insert_input!]!

    """upsert condition"""
    on_conflict: vehicles_on_conflict
  ): vehicles_mutation_response

  """
  insert a single row into the table: "vehicles"
  """
  insert_vehicles_one(
    """the row to be inserted"""
    object: vehicles_insert_input!

    """upsert condition"""
    on_conflict: vehicles_on_conflict
  ): vehicles

  """
  insert data into the table: "visit_status"
  """
  insert_visit_status(
    """the rows to be inserted"""
    objects: [visit_status_insert_input!]!

    """upsert condition"""
    on_conflict: visit_status_on_conflict
  ): visit_status_mutation_response

  """
  insert a single row into the table: "visit_status"
  """
  insert_visit_status_one(
    """the row to be inserted"""
    object: visit_status_insert_input!

    """upsert condition"""
    on_conflict: visit_status_on_conflict
  ): visit_status

  """
  insert data into the table: "visitors"
  """
  insert_visitors(
    """the rows to be inserted"""
    objects: [visitors_insert_input!]!

    """upsert condition"""
    on_conflict: visitors_on_conflict
  ): visitors_mutation_response

  """
  insert a single row into the table: "visitors"
  """
  insert_visitors_one(
    """the row to be inserted"""
    object: visitors_insert_input!

    """upsert condition"""
    on_conflict: visitors_on_conflict
  ): visitors

  """
  insert data into the table: "visits"
  """
  insert_visits(
    """the rows to be inserted"""
    objects: [visits_insert_input!]!

    """upsert condition"""
    on_conflict: visits_on_conflict
  ): visits_mutation_response

  """
  insert a single row into the table: "visits"
  """
  insert_visits_one(
    """the row to be inserted"""
    object: visits_insert_input!

    """upsert condition"""
    on_conflict: visits_on_conflict
  ): visits
  updateEmployeePassword(employeeInfo: UpdatePasswordInputType!): UpdatePasswordOutputType!
  updateMessageStatus(messageIds: MessageStatusInput!): MessageStatusOutput!
  updateUserInfo(employee: UpdateEmployeeInput!): EmployeeUpdateType!

  """
  update data of the table: "agencies"
  """
  update_agencies(
    """sets the columns of the filtered rows to the given values"""
    _set: agencies_set_input

    """filter the rows which have to be updated"""
    where: agencies_bool_exp!
  ): agencies_mutation_response

  """
  update single row of the table: "agencies"
  """
  update_agencies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: agencies_set_input
    pk_columns: agencies_pk_columns_input!
  ): agencies

  """
  update multiples rows of table: "agencies"
  """
  update_agencies_many(
    """updates to execute, in order"""
    updates: [agencies_updates!]!
  ): [agencies_mutation_response]

  """
  update data of the table: "alarms"
  """
  update_alarms(
    """sets the columns of the filtered rows to the given values"""
    _set: alarms_set_input

    """filter the rows which have to be updated"""
    where: alarms_bool_exp!
  ): alarms_mutation_response

  """
  update single row of the table: "alarms"
  """
  update_alarms_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: alarms_set_input
    pk_columns: alarms_pk_columns_input!
  ): alarms

  """
  update multiples rows of table: "alarms"
  """
  update_alarms_many(
    """updates to execute, in order"""
    updates: [alarms_updates!]!
  ): [alarms_mutation_response]

  """
  update data of the table: "app_versions"
  """
  update_app_versions(
    """sets the columns of the filtered rows to the given values"""
    _set: app_versions_set_input

    """filter the rows which have to be updated"""
    where: app_versions_bool_exp!
  ): app_versions_mutation_response

  """
  update single row of the table: "app_versions"
  """
  update_app_versions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: app_versions_set_input
    pk_columns: app_versions_pk_columns_input!
  ): app_versions

  """
  update multiples rows of table: "app_versions"
  """
  update_app_versions_many(
    """updates to execute, in order"""
    updates: [app_versions_updates!]!
  ): [app_versions_mutation_response]

  """
  update data of the table: "appointment_status"
  """
  update_appointment_status(
    """sets the columns of the filtered rows to the given values"""
    _set: appointment_status_set_input

    """filter the rows which have to be updated"""
    where: appointment_status_bool_exp!
  ): appointment_status_mutation_response

  """
  update single row of the table: "appointment_status"
  """
  update_appointment_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: appointment_status_set_input
    pk_columns: appointment_status_pk_columns_input!
  ): appointment_status

  """
  update multiples rows of table: "appointment_status"
  """
  update_appointment_status_many(
    """updates to execute, in order"""
    updates: [appointment_status_updates!]!
  ): [appointment_status_mutation_response]

  """
  update data of the table: "appointments"
  """
  update_appointments(
    """sets the columns of the filtered rows to the given values"""
    _set: appointments_set_input

    """filter the rows which have to be updated"""
    where: appointments_bool_exp!
  ): appointments_mutation_response

  """
  update single row of the table: "appointments"
  """
  update_appointments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: appointments_set_input
    pk_columns: appointments_pk_columns_input!
  ): appointments

  """
  update multiples rows of table: "appointments"
  """
  update_appointments_many(
    """updates to execute, in order"""
    updates: [appointments_updates!]!
  ): [appointments_mutation_response]

  """
  update data of the table: "attachments"
  """
  update_attachments(
    """sets the columns of the filtered rows to the given values"""
    _set: attachments_set_input

    """filter the rows which have to be updated"""
    where: attachments_bool_exp!
  ): attachments_mutation_response

  """
  update single row of the table: "attachments"
  """
  update_attachments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attachments_set_input
    pk_columns: attachments_pk_columns_input!
  ): attachments

  """
  update multiples rows of table: "attachments"
  """
  update_attachments_many(
    """updates to execute, in order"""
    updates: [attachments_updates!]!
  ): [attachments_mutation_response]

  """
  update data of the table: "attendance"
  """
  update_attendance(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_set_input

    """filter the rows which have to be updated"""
    where: attendance_bool_exp!
  ): attendance_mutation_response

  """
  update single row of the table: "attendance"
  """
  update_attendance_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_set_input
    pk_columns: attendance_pk_columns_input!
  ): attendance

  """
  update multiples rows of table: "attendance"
  """
  update_attendance_many(
    """updates to execute, in order"""
    updates: [attendance_updates!]!
  ): [attendance_mutation_response]

  """
  update data of the table: "attendance_state"
  """
  update_attendance_state(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_state_set_input

    """filter the rows which have to be updated"""
    where: attendance_state_bool_exp!
  ): attendance_state_mutation_response

  """
  update single row of the table: "attendance_state"
  """
  update_attendance_state_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_state_set_input
    pk_columns: attendance_state_pk_columns_input!
  ): attendance_state

  """
  update multiples rows of table: "attendance_state"
  """
  update_attendance_state_many(
    """updates to execute, in order"""
    updates: [attendance_state_updates!]!
  ): [attendance_state_mutation_response]

  """
  update data of the table: "companies"
  """
  update_companies(
    """sets the columns of the filtered rows to the given values"""
    _set: companies_set_input

    """filter the rows which have to be updated"""
    where: companies_bool_exp!
  ): companies_mutation_response

  """
  update single row of the table: "companies"
  """
  update_companies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: companies_set_input
    pk_columns: companies_pk_columns_input!
  ): companies

  """
  update multiples rows of table: "companies"
  """
  update_companies_many(
    """updates to execute, in order"""
    updates: [companies_updates!]!
  ): [companies_mutation_response]

  """
  update data of the table: "company_settings"
  """
  update_company_settings(
    """increments the numeric columns with given value of the filtered values"""
    _inc: company_settings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: company_settings_set_input

    """filter the rows which have to be updated"""
    where: company_settings_bool_exp!
  ): company_settings_mutation_response

  """
  update single row of the table: "company_settings"
  """
  update_company_settings_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: company_settings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: company_settings_set_input
    pk_columns: company_settings_pk_columns_input!
  ): company_settings

  """
  update multiples rows of table: "company_settings"
  """
  update_company_settings_many(
    """updates to execute, in order"""
    updates: [company_settings_updates!]!
  ): [company_settings_mutation_response]

  """
  update data of the table: "conversations"
  """
  update_conversations(
    """sets the columns of the filtered rows to the given values"""
    _set: conversations_set_input

    """filter the rows which have to be updated"""
    where: conversations_bool_exp!
  ): conversations_mutation_response

  """
  update single row of the table: "conversations"
  """
  update_conversations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conversations_set_input
    pk_columns: conversations_pk_columns_input!
  ): conversations

  """
  update multiples rows of table: "conversations"
  """
  update_conversations_many(
    """updates to execute, in order"""
    updates: [conversations_updates!]!
  ): [conversations_mutation_response]

  """
  update data of the table: "departments"
  """
  update_departments(
    """sets the columns of the filtered rows to the given values"""
    _set: departments_set_input

    """filter the rows which have to be updated"""
    where: departments_bool_exp!
  ): departments_mutation_response

  """
  update single row of the table: "departments"
  """
  update_departments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: departments_set_input
    pk_columns: departments_pk_columns_input!
  ): departments

  """
  update multiples rows of table: "departments"
  """
  update_departments_many(
    """updates to execute, in order"""
    updates: [departments_updates!]!
  ): [departments_mutation_response]

  """
  update data of the table: "employee_conversation"
  """
  update_employee_conversation(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_conversation_set_input

    """filter the rows which have to be updated"""
    where: employee_conversation_bool_exp!
  ): employee_conversation_mutation_response

  """
  update single row of the table: "employee_conversation"
  """
  update_employee_conversation_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_conversation_set_input
    pk_columns: employee_conversation_pk_columns_input!
  ): employee_conversation

  """
  update multiples rows of table: "employee_conversation"
  """
  update_employee_conversation_many(
    """updates to execute, in order"""
    updates: [employee_conversation_updates!]!
  ): [employee_conversation_mutation_response]

  """
  update data of the table: "employee_notifications"
  """
  update_employee_notifications(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_notifications_set_input

    """filter the rows which have to be updated"""
    where: employee_notifications_bool_exp!
  ): employee_notifications_mutation_response

  """
  update single row of the table: "employee_notifications"
  """
  update_employee_notifications_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_notifications_set_input
    pk_columns: employee_notifications_pk_columns_input!
  ): employee_notifications

  """
  update multiples rows of table: "employee_notifications"
  """
  update_employee_notifications_many(
    """updates to execute, in order"""
    updates: [employee_notifications_updates!]!
  ): [employee_notifications_mutation_response]

  """
  update data of the table: "employee_roles"
  """
  update_employee_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_roles_set_input

    """filter the rows which have to be updated"""
    where: employee_roles_bool_exp!
  ): employee_roles_mutation_response

  """
  update single row of the table: "employee_roles"
  """
  update_employee_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_roles_set_input
    pk_columns: employee_roles_pk_columns_input!
  ): employee_roles

  """
  update multiples rows of table: "employee_roles"
  """
  update_employee_roles_many(
    """updates to execute, in order"""
    updates: [employee_roles_updates!]!
  ): [employee_roles_mutation_response]

  """
  update data of the table: "employee_shifts"
  """
  update_employee_shifts(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_shifts_set_input

    """filter the rows which have to be updated"""
    where: employee_shifts_bool_exp!
  ): employee_shifts_mutation_response

  """
  update single row of the table: "employee_shifts"
  """
  update_employee_shifts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_shifts_set_input
    pk_columns: employee_shifts_pk_columns_input!
  ): employee_shifts

  """
  update multiples rows of table: "employee_shifts"
  """
  update_employee_shifts_many(
    """updates to execute, in order"""
    updates: [employee_shifts_updates!]!
  ): [employee_shifts_mutation_response]

  """
  update data of the table: "employees"
  """
  update_employees(
    """sets the columns of the filtered rows to the given values"""
    _set: employees_set_input

    """filter the rows which have to be updated"""
    where: employees_bool_exp!
  ): employees_mutation_response

  """
  update single row of the table: "employees"
  """
  update_employees_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employees_set_input
    pk_columns: employees_pk_columns_input!
  ): employees

  """
  update multiples rows of table: "employees"
  """
  update_employees_many(
    """updates to execute, in order"""
    updates: [employees_updates!]!
  ): [employees_mutation_response]

  """
  update data of the table: "event_notification"
  """
  update_event_notification(
    """sets the columns of the filtered rows to the given values"""
    _set: event_notification_set_input

    """filter the rows which have to be updated"""
    where: event_notification_bool_exp!
  ): event_notification_mutation_response

  """
  update single row of the table: "event_notification"
  """
  update_event_notification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: event_notification_set_input
    pk_columns: event_notification_pk_columns_input!
  ): event_notification

  """
  update multiples rows of table: "event_notification"
  """
  update_event_notification_many(
    """updates to execute, in order"""
    updates: [event_notification_updates!]!
  ): [event_notification_mutation_response]

  """
  update data of the table: "event_participants"
  """
  update_event_participants(
    """sets the columns of the filtered rows to the given values"""
    _set: event_participants_set_input

    """filter the rows which have to be updated"""
    where: event_participants_bool_exp!
  ): event_participants_mutation_response

  """
  update single row of the table: "event_participants"
  """
  update_event_participants_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: event_participants_set_input
    pk_columns: event_participants_pk_columns_input!
  ): event_participants

  """
  update multiples rows of table: "event_participants"
  """
  update_event_participants_many(
    """updates to execute, in order"""
    updates: [event_participants_updates!]!
  ): [event_participants_mutation_response]

  """
  update data of the table: "events"
  """
  update_events(
    """sets the columns of the filtered rows to the given values"""
    _set: events_set_input

    """filter the rows which have to be updated"""
    where: events_bool_exp!
  ): events_mutation_response

  """
  update single row of the table: "events"
  """
  update_events_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: events_set_input
    pk_columns: events_pk_columns_input!
  ): events

  """
  update multiples rows of table: "events"
  """
  update_events_many(
    """updates to execute, in order"""
    updates: [events_updates!]!
  ): [events_mutation_response]

  """
  update data of the table: "files"
  """
  update_files(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "files"
  """
  update_files_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update multiples rows of table: "files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "gender"
  """
  update_gender(
    """sets the columns of the filtered rows to the given values"""
    _set: gender_set_input

    """filter the rows which have to be updated"""
    where: gender_bool_exp!
  ): gender_mutation_response

  """
  update single row of the table: "gender"
  """
  update_gender_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: gender_set_input
    pk_columns: gender_pk_columns_input!
  ): gender

  """
  update multiples rows of table: "gender"
  """
  update_gender_many(
    """updates to execute, in order"""
    updates: [gender_updates!]!
  ): [gender_mutation_response]

  """
  update data of the table: "geometry_columns"
  """
  update_geometry_columns(
    """increments the numeric columns with given value of the filtered values"""
    _inc: geometry_columns_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: geometry_columns_set_input

    """filter the rows which have to be updated"""
    where: geometry_columns_bool_exp!
  ): geometry_columns_mutation_response

  """
  update multiples rows of table: "geometry_columns"
  """
  update_geometry_columns_many(
    """updates to execute, in order"""
    updates: [geometry_columns_updates!]!
  ): [geometry_columns_mutation_response]

  """
  update data of the table: "group_members"
  """
  update_group_members(
    """sets the columns of the filtered rows to the given values"""
    _set: group_members_set_input

    """filter the rows which have to be updated"""
    where: group_members_bool_exp!
  ): group_members_mutation_response

  """
  update single row of the table: "group_members"
  """
  update_group_members_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: group_members_set_input
    pk_columns: group_members_pk_columns_input!
  ): group_members

  """
  update multiples rows of table: "group_members"
  """
  update_group_members_many(
    """updates to execute, in order"""
    updates: [group_members_updates!]!
  ): [group_members_mutation_response]

  """
  update data of the table: "group_messages"
  """
  update_group_messages(
    """sets the columns of the filtered rows to the given values"""
    _set: group_messages_set_input

    """filter the rows which have to be updated"""
    where: group_messages_bool_exp!
  ): group_messages_mutation_response

  """
  update single row of the table: "group_messages"
  """
  update_group_messages_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: group_messages_set_input
    pk_columns: group_messages_pk_columns_input!
  ): group_messages

  """
  update multiples rows of table: "group_messages"
  """
  update_group_messages_many(
    """updates to execute, in order"""
    updates: [group_messages_updates!]!
  ): [group_messages_mutation_response]

  """
  update data of the table: "groups"
  """
  update_groups(
    """sets the columns of the filtered rows to the given values"""
    _set: groups_set_input

    """filter the rows which have to be updated"""
    where: groups_bool_exp!
  ): groups_mutation_response

  """
  update single row of the table: "groups"
  """
  update_groups_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: groups_set_input
    pk_columns: groups_pk_columns_input!
  ): groups

  """
  update multiples rows of table: "groups"
  """
  update_groups_many(
    """updates to execute, in order"""
    updates: [groups_updates!]!
  ): [groups_mutation_response]

  """
  update data of the table: "leave_approval"
  """
  update_leave_approval(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_approval_set_input

    """filter the rows which have to be updated"""
    where: leave_approval_bool_exp!
  ): leave_approval_mutation_response

  """
  update single row of the table: "leave_approval"
  """
  update_leave_approval_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_approval_set_input
    pk_columns: leave_approval_pk_columns_input!
  ): leave_approval

  """
  update multiples rows of table: "leave_approval"
  """
  update_leave_approval_many(
    """updates to execute, in order"""
    updates: [leave_approval_updates!]!
  ): [leave_approval_mutation_response]

  """
  update data of the table: "leave_approval_status"
  """
  update_leave_approval_status(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_approval_status_set_input

    """filter the rows which have to be updated"""
    where: leave_approval_status_bool_exp!
  ): leave_approval_status_mutation_response

  """
  update single row of the table: "leave_approval_status"
  """
  update_leave_approval_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_approval_status_set_input
    pk_columns: leave_approval_status_pk_columns_input!
  ): leave_approval_status

  """
  update multiples rows of table: "leave_approval_status"
  """
  update_leave_approval_status_many(
    """updates to execute, in order"""
    updates: [leave_approval_status_updates!]!
  ): [leave_approval_status_mutation_response]

  """
  update data of the table: "leave_status"
  """
  update_leave_status(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_status_set_input

    """filter the rows which have to be updated"""
    where: leave_status_bool_exp!
  ): leave_status_mutation_response

  """
  update single row of the table: "leave_status"
  """
  update_leave_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_status_set_input
    pk_columns: leave_status_pk_columns_input!
  ): leave_status

  """
  update multiples rows of table: "leave_status"
  """
  update_leave_status_many(
    """updates to execute, in order"""
    updates: [leave_status_updates!]!
  ): [leave_status_mutation_response]

  """
  update data of the table: "leave_type"
  """
  update_leave_type(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_type_set_input

    """filter the rows which have to be updated"""
    where: leave_type_bool_exp!
  ): leave_type_mutation_response

  """
  update single row of the table: "leave_type"
  """
  update_leave_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_type_set_input
    pk_columns: leave_type_pk_columns_input!
  ): leave_type

  """
  update multiples rows of table: "leave_type"
  """
  update_leave_type_many(
    """updates to execute, in order"""
    updates: [leave_type_updates!]!
  ): [leave_type_mutation_response]

  """
  update data of the table: "leave_types"
  """
  update_leave_types(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_types_set_input

    """filter the rows which have to be updated"""
    where: leave_types_bool_exp!
  ): leave_types_mutation_response

  """
  update single row of the table: "leave_types"
  """
  update_leave_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_types_set_input
    pk_columns: leave_types_pk_columns_input!
  ): leave_types

  """
  update multiples rows of table: "leave_types"
  """
  update_leave_types_many(
    """updates to execute, in order"""
    updates: [leave_types_updates!]!
  ): [leave_types_mutation_response]

  """
  update data of the table: "leaves"
  """
  update_leaves(
    """sets the columns of the filtered rows to the given values"""
    _set: leaves_set_input

    """filter the rows which have to be updated"""
    where: leaves_bool_exp!
  ): leaves_mutation_response

  """
  update single row of the table: "leaves"
  """
  update_leaves_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leaves_set_input
    pk_columns: leaves_pk_columns_input!
  ): leaves

  """
  update multiples rows of table: "leaves"
  """
  update_leaves_many(
    """updates to execute, in order"""
    updates: [leaves_updates!]!
  ): [leaves_mutation_response]

  """
  update data of the table: "locations"
  """
  update_locations(
    """sets the columns of the filtered rows to the given values"""
    _set: locations_set_input

    """filter the rows which have to be updated"""
    where: locations_bool_exp!
  ): locations_mutation_response

  """
  update single row of the table: "locations"
  """
  update_locations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: locations_set_input
    pk_columns: locations_pk_columns_input!
  ): locations

  """
  update multiples rows of table: "locations"
  """
  update_locations_many(
    """updates to execute, in order"""
    updates: [locations_updates!]!
  ): [locations_mutation_response]

  """
  update data of the table: "message_statuses"
  """
  update_message_statuses(
    """sets the columns of the filtered rows to the given values"""
    _set: message_statuses_set_input

    """filter the rows which have to be updated"""
    where: message_statuses_bool_exp!
  ): message_statuses_mutation_response

  """
  update single row of the table: "message_statuses"
  """
  update_message_statuses_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: message_statuses_set_input
    pk_columns: message_statuses_pk_columns_input!
  ): message_statuses

  """
  update multiples rows of table: "message_statuses"
  """
  update_message_statuses_many(
    """updates to execute, in order"""
    updates: [message_statuses_updates!]!
  ): [message_statuses_mutation_response]

  """
  update data of the table: "messages"
  """
  update_messages(
    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input

    """filter the rows which have to be updated"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  update single row of the table: "messages"
  """
  update_messages_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input
    pk_columns: messages_pk_columns_input!
  ): messages

  """
  update multiples rows of table: "messages"
  """
  update_messages_many(
    """updates to execute, in order"""
    updates: [messages_updates!]!
  ): [messages_mutation_response]

  """
  update data of the table: "positions"
  """
  update_positions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: positions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: positions_set_input

    """filter the rows which have to be updated"""
    where: positions_bool_exp!
  ): positions_mutation_response

  """
  update single row of the table: "positions"
  """
  update_positions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: positions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: positions_set_input
    pk_columns: positions_pk_columns_input!
  ): positions

  """
  update multiples rows of table: "positions"
  """
  update_positions_many(
    """updates to execute, in order"""
    updates: [positions_updates!]!
  ): [positions_mutation_response]

  """
  update data of the table: "reports"
  """
  update_reports(
    """sets the columns of the filtered rows to the given values"""
    _set: reports_set_input

    """filter the rows which have to be updated"""
    where: reports_bool_exp!
  ): reports_mutation_response

  """
  update single row of the table: "reports"
  """
  update_reports_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: reports_set_input
    pk_columns: reports_pk_columns_input!
  ): reports

  """
  update multiples rows of table: "reports"
  """
  update_reports_many(
    """updates to execute, in order"""
    updates: [reports_updates!]!
  ): [reports_mutation_response]

  """
  update data of the table: "roles"
  """
  update_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update multiples rows of table: "roles"
  """
  update_roles_many(
    """updates to execute, in order"""
    updates: [roles_updates!]!
  ): [roles_mutation_response]

  """
  update data of the table: "services"
  """
  update_services(
    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input

    """filter the rows which have to be updated"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  update single row of the table: "services"
  """
  update_services_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input
    pk_columns: services_pk_columns_input!
  ): services

  """
  update multiples rows of table: "services"
  """
  update_services_many(
    """updates to execute, in order"""
    updates: [services_updates!]!
  ): [services_mutation_response]

  """
  update data of the table: "shifts"
  """
  update_shifts(
    """sets the columns of the filtered rows to the given values"""
    _set: shifts_set_input

    """filter the rows which have to be updated"""
    where: shifts_bool_exp!
  ): shifts_mutation_response

  """
  update single row of the table: "shifts"
  """
  update_shifts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: shifts_set_input
    pk_columns: shifts_pk_columns_input!
  ): shifts

  """
  update multiples rows of table: "shifts"
  """
  update_shifts_many(
    """updates to execute, in order"""
    updates: [shifts_updates!]!
  ): [shifts_mutation_response]

  """
  update data of the table: "spatial_ref_sys"
  """
  update_spatial_ref_sys(
    """increments the numeric columns with given value of the filtered values"""
    _inc: spatial_ref_sys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: spatial_ref_sys_set_input

    """filter the rows which have to be updated"""
    where: spatial_ref_sys_bool_exp!
  ): spatial_ref_sys_mutation_response

  """
  update single row of the table: "spatial_ref_sys"
  """
  update_spatial_ref_sys_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: spatial_ref_sys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: spatial_ref_sys_set_input
    pk_columns: spatial_ref_sys_pk_columns_input!
  ): spatial_ref_sys

  """
  update multiples rows of table: "spatial_ref_sys"
  """
  update_spatial_ref_sys_many(
    """updates to execute, in order"""
    updates: [spatial_ref_sys_updates!]!
  ): [spatial_ref_sys_mutation_response]

  """
  update data of the table: "status"
  """
  update_status(
    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input

    """filter the rows which have to be updated"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  update single row of the table: "status"
  """
  update_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input
    pk_columns: status_pk_columns_input!
  ): status

  """
  update multiples rows of table: "status"
  """
  update_status_many(
    """updates to execute, in order"""
    updates: [status_updates!]!
  ): [status_mutation_response]

  """
  update data of the table: "task_status"
  """
  update_task_status(
    """sets the columns of the filtered rows to the given values"""
    _set: task_status_set_input

    """filter the rows which have to be updated"""
    where: task_status_bool_exp!
  ): task_status_mutation_response

  """
  update single row of the table: "task_status"
  """
  update_task_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: task_status_set_input
    pk_columns: task_status_pk_columns_input!
  ): task_status

  """
  update multiples rows of table: "task_status"
  """
  update_task_status_many(
    """updates to execute, in order"""
    updates: [task_status_updates!]!
  ): [task_status_mutation_response]

  """
  update data of the table: "tasks"
  """
  update_tasks(
    """sets the columns of the filtered rows to the given values"""
    _set: tasks_set_input

    """filter the rows which have to be updated"""
    where: tasks_bool_exp!
  ): tasks_mutation_response

  """
  update single row of the table: "tasks"
  """
  update_tasks_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tasks_set_input
    pk_columns: tasks_pk_columns_input!
  ): tasks

  """
  update multiples rows of table: "tasks"
  """
  update_tasks_many(
    """updates to execute, in order"""
    updates: [tasks_updates!]!
  ): [tasks_mutation_response]

  """
  update data of the table: "text_content"
  """
  update_text_content(
    """sets the columns of the filtered rows to the given values"""
    _set: text_content_set_input

    """filter the rows which have to be updated"""
    where: text_content_bool_exp!
  ): text_content_mutation_response

  """
  update single row of the table: "text_content"
  """
  update_text_content_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: text_content_set_input
    pk_columns: text_content_pk_columns_input!
  ): text_content

  """
  update multiples rows of table: "text_content"
  """
  update_text_content_many(
    """updates to execute, in order"""
    updates: [text_content_updates!]!
  ): [text_content_mutation_response]

  """
  update data of the table: "topology.layer"
  """
  update_topology_layer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: topology_layer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: topology_layer_set_input

    """filter the rows which have to be updated"""
    where: topology_layer_bool_exp!
  ): topology_layer_mutation_response

  """
  update single row of the table: "topology.layer"
  """
  update_topology_layer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: topology_layer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: topology_layer_set_input
    pk_columns: topology_layer_pk_columns_input!
  ): topology_layer

  """
  update multiples rows of table: "topology.layer"
  """
  update_topology_layer_many(
    """updates to execute, in order"""
    updates: [topology_layer_updates!]!
  ): [topology_layer_mutation_response]

  """
  update data of the table: "topology.topology"
  """
  update_topology_topology(
    """increments the numeric columns with given value of the filtered values"""
    _inc: topology_topology_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: topology_topology_set_input

    """filter the rows which have to be updated"""
    where: topology_topology_bool_exp!
  ): topology_topology_mutation_response

  """
  update single row of the table: "topology.topology"
  """
  update_topology_topology_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: topology_topology_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: topology_topology_set_input
    pk_columns: topology_topology_pk_columns_input!
  ): topology_topology

  """
  update multiples rows of table: "topology.topology"
  """
  update_topology_topology_many(
    """updates to execute, in order"""
    updates: [topology_topology_updates!]!
  ): [topology_topology_mutation_response]

  """
  update data of the table: "translations"
  """
  update_translations(
    """sets the columns of the filtered rows to the given values"""
    _set: translations_set_input

    """filter the rows which have to be updated"""
    where: translations_bool_exp!
  ): translations_mutation_response

  """
  update single row of the table: "translations"
  """
  update_translations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: translations_set_input
    pk_columns: translations_pk_columns_input!
  ): translations

  """
  update multiples rows of table: "translations"
  """
  update_translations_many(
    """updates to execute, in order"""
    updates: [translations_updates!]!
  ): [translations_mutation_response]

  """
  update data of the table: "typing_statuses"
  """
  update_typing_statuses(
    """sets the columns of the filtered rows to the given values"""
    _set: typing_statuses_set_input

    """filter the rows which have to be updated"""
    where: typing_statuses_bool_exp!
  ): typing_statuses_mutation_response

  """
  update single row of the table: "typing_statuses"
  """
  update_typing_statuses_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: typing_statuses_set_input
    pk_columns: typing_statuses_pk_columns_input!
  ): typing_statuses

  """
  update multiples rows of table: "typing_statuses"
  """
  update_typing_statuses_many(
    """updates to execute, in order"""
    updates: [typing_statuses_updates!]!
  ): [typing_statuses_mutation_response]

  """
  update data of the table: "vehicles"
  """
  update_vehicles(
    """sets the columns of the filtered rows to the given values"""
    _set: vehicles_set_input

    """filter the rows which have to be updated"""
    where: vehicles_bool_exp!
  ): vehicles_mutation_response

  """
  update single row of the table: "vehicles"
  """
  update_vehicles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: vehicles_set_input
    pk_columns: vehicles_pk_columns_input!
  ): vehicles

  """
  update multiples rows of table: "vehicles"
  """
  update_vehicles_many(
    """updates to execute, in order"""
    updates: [vehicles_updates!]!
  ): [vehicles_mutation_response]

  """
  update data of the table: "visit_status"
  """
  update_visit_status(
    """sets the columns of the filtered rows to the given values"""
    _set: visit_status_set_input

    """filter the rows which have to be updated"""
    where: visit_status_bool_exp!
  ): visit_status_mutation_response

  """
  update single row of the table: "visit_status"
  """
  update_visit_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: visit_status_set_input
    pk_columns: visit_status_pk_columns_input!
  ): visit_status

  """
  update multiples rows of table: "visit_status"
  """
  update_visit_status_many(
    """updates to execute, in order"""
    updates: [visit_status_updates!]!
  ): [visit_status_mutation_response]

  """
  update data of the table: "visitors"
  """
  update_visitors(
    """sets the columns of the filtered rows to the given values"""
    _set: visitors_set_input

    """filter the rows which have to be updated"""
    where: visitors_bool_exp!
  ): visitors_mutation_response

  """
  update single row of the table: "visitors"
  """
  update_visitors_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: visitors_set_input
    pk_columns: visitors_pk_columns_input!
  ): visitors

  """
  update multiples rows of table: "visitors"
  """
  update_visitors_many(
    """updates to execute, in order"""
    updates: [visitors_updates!]!
  ): [visitors_mutation_response]

  """
  update data of the table: "visits"
  """
  update_visits(
    """sets the columns of the filtered rows to the given values"""
    _set: visits_set_input

    """filter the rows which have to be updated"""
    where: visits_bool_exp!
  ): visits_mutation_response

  """
  update single row of the table: "visits"
  """
  update_visits_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: visits_set_input
    pk_columns: visits_pk_columns_input!
  ): visits

  """
  update multiples rows of table: "visits"
  """
  update_visits_many(
    """updates to execute, in order"""
    updates: [visits_updates!]!
  ): [visits_mutation_response]
}

scalar name

"""
Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'.
"""
input name_comparison_exp {
  _eq: name
  _gt: name
  _gte: name
  _in: [name!]
  _is_null: Boolean
  _lt: name
  _lte: name
  _neq: name
  _nin: [name!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

input ParticipantInput {
  id: UUID!
}

scalar participantstatus

"""
Boolean expression to compare columns of type "participantstatus". All fields are combined with logical 'AND'.
"""
input participantstatus_comparison_exp {
  _eq: participantstatus
  _gt: participantstatus
  _gte: participantstatus
  _in: [participantstatus!]
  _is_null: Boolean
  _lt: participantstatus
  _lte: participantstatus
  _neq: participantstatus
  _nin: [participantstatus!]
}

type ParticipantType {
  firstname: String!
  lastname: String!
}

"""
columns and relationships of "positions"
"""
type positions {
  """An object relationship"""
  company: companies
  company_id: uuid
  created_at: timestamptz

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  level: Int
  name: uuid

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz
}

"""
aggregated selection of "positions"
"""
type positions_aggregate {
  aggregate: positions_aggregate_fields
  nodes: [positions!]!
}

input positions_aggregate_bool_exp {
  count: positions_aggregate_bool_exp_count
}

input positions_aggregate_bool_exp_count {
  arguments: [positions_select_column!]
  distinct: Boolean
  filter: positions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "positions"
"""
type positions_aggregate_fields {
  avg: positions_avg_fields
  count(columns: [positions_select_column!], distinct: Boolean): Int!
  max: positions_max_fields
  min: positions_min_fields
  stddev: positions_stddev_fields
  stddev_pop: positions_stddev_pop_fields
  stddev_samp: positions_stddev_samp_fields
  sum: positions_sum_fields
  var_pop: positions_var_pop_fields
  var_samp: positions_var_samp_fields
  variance: positions_variance_fields
}

"""
order by aggregate values of table "positions"
"""
input positions_aggregate_order_by {
  avg: positions_avg_order_by
  count: order_by
  max: positions_max_order_by
  min: positions_min_order_by
  stddev: positions_stddev_order_by
  stddev_pop: positions_stddev_pop_order_by
  stddev_samp: positions_stddev_samp_order_by
  sum: positions_sum_order_by
  var_pop: positions_var_pop_order_by
  var_samp: positions_var_samp_order_by
  variance: positions_variance_order_by
}

"""
input type for inserting array relation for remote table "positions"
"""
input positions_arr_rel_insert_input {
  data: [positions_insert_input!]!

  """upsert condition"""
  on_conflict: positions_on_conflict
}

"""aggregate avg on columns"""
type positions_avg_fields {
  level: Float
}

"""
order by avg() on columns of table "positions"
"""
input positions_avg_order_by {
  level: order_by
}

"""
Boolean expression to filter rows from the table "positions". All fields are combined with a logical 'AND'.
"""
input positions_bool_exp {
  _and: [positions_bool_exp!]
  _not: positions_bool_exp
  _or: [positions_bool_exp!]
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  level: Int_comparison_exp
  name: uuid_comparison_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "positions"
"""
enum positions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  positions_pkey
}

"""
input type for incrementing numeric columns in table "positions"
"""
input positions_inc_input {
  level: Int
}

"""
input type for inserting data into table "positions"
"""
input positions_insert_input {
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  employees: employees_arr_rel_insert_input
  id: uuid
  level: Int
  name: uuid
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type positions_max_fields {
  company_id: uuid
  created_at: timestamptz
  id: uuid
  level: Int
  name: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "positions"
"""
input positions_max_order_by {
  company_id: order_by
  created_at: order_by
  id: order_by
  level: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type positions_min_fields {
  company_id: uuid
  created_at: timestamptz
  id: uuid
  level: Int
  name: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "positions"
"""
input positions_min_order_by {
  company_id: order_by
  created_at: order_by
  id: order_by
  level: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "positions"
"""
type positions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [positions!]!
}

"""
input type for inserting object relation for remote table "positions"
"""
input positions_obj_rel_insert_input {
  data: positions_insert_input!

  """upsert condition"""
  on_conflict: positions_on_conflict
}

"""
on_conflict condition type for table "positions"
"""
input positions_on_conflict {
  constraint: positions_constraint!
  update_columns: [positions_update_column!]! = []
  where: positions_bool_exp
}

"""Ordering options when selecting data from "positions"."""
input positions_order_by {
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  level: order_by
  name: order_by
  text_content: text_content_order_by
  updated_at: order_by
}

"""primary key columns input for table: positions"""
input positions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "positions"
"""
enum positions_select_column {
  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  level

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "positions"
"""
input positions_set_input {
  company_id: uuid
  created_at: timestamptz
  id: uuid
  level: Int
  name: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type positions_stddev_fields {
  level: Float
}

"""
order by stddev() on columns of table "positions"
"""
input positions_stddev_order_by {
  level: order_by
}

"""aggregate stddev_pop on columns"""
type positions_stddev_pop_fields {
  level: Float
}

"""
order by stddev_pop() on columns of table "positions"
"""
input positions_stddev_pop_order_by {
  level: order_by
}

"""aggregate stddev_samp on columns"""
type positions_stddev_samp_fields {
  level: Float
}

"""
order by stddev_samp() on columns of table "positions"
"""
input positions_stddev_samp_order_by {
  level: order_by
}

"""
Streaming cursor of the table "positions"
"""
input positions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: positions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input positions_stream_cursor_value_input {
  company_id: uuid
  created_at: timestamptz
  id: uuid
  level: Int
  name: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type positions_sum_fields {
  level: Int
}

"""
order by sum() on columns of table "positions"
"""
input positions_sum_order_by {
  level: order_by
}

"""
update columns of table "positions"
"""
enum positions_update_column {
  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  level

  """column name"""
  name

  """column name"""
  updated_at
}

input positions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: positions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: positions_set_input

  """filter the rows which have to be updated"""
  where: positions_bool_exp!
}

"""aggregate var_pop on columns"""
type positions_var_pop_fields {
  level: Float
}

"""
order by var_pop() on columns of table "positions"
"""
input positions_var_pop_order_by {
  level: order_by
}

"""aggregate var_samp on columns"""
type positions_var_samp_fields {
  level: Float
}

"""
order by var_samp() on columns of table "positions"
"""
input positions_var_samp_order_by {
  level: order_by
}

"""aggregate variance on columns"""
type positions_variance_fields {
  level: Float
}

"""
order by variance() on columns of table "positions"
"""
input positions_variance_order_by {
  level: order_by
}

type PositionType {
  id: UUID!
  level: Int!
}

type query_root {
  """An array relationship"""
  agencies(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An aggregate relationship"""
  agencies_aggregate(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): agencies_aggregate!

  """fetch data from the table: "agencies" using primary key columns"""
  agencies_by_pk(id: uuid!): agencies

  """An array relationship"""
  alarms(
    """distinct select on columns"""
    distinct_on: [alarms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alarms_order_by!]

    """filter the rows returned"""
    where: alarms_bool_exp
  ): [alarms!]!

  """An aggregate relationship"""
  alarms_aggregate(
    """distinct select on columns"""
    distinct_on: [alarms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alarms_order_by!]

    """filter the rows returned"""
    where: alarms_bool_exp
  ): alarms_aggregate!

  """fetch data from the table: "alarms" using primary key columns"""
  alarms_by_pk(id: uuid!): alarms

  """
  fetch data from the table: "app_versions"
  """
  app_versions(
    """distinct select on columns"""
    distinct_on: [app_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_versions_order_by!]

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): [app_versions!]!

  """
  fetch aggregated fields from the table: "app_versions"
  """
  app_versions_aggregate(
    """distinct select on columns"""
    distinct_on: [app_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_versions_order_by!]

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): app_versions_aggregate!

  """fetch data from the table: "app_versions" using primary key columns"""
  app_versions_by_pk(version: String!): app_versions

  """
  fetch data from the table: "appointment_status"
  """
  appointment_status(
    """distinct select on columns"""
    distinct_on: [appointment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_status_order_by!]

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): [appointment_status!]!

  """
  fetch aggregated fields from the table: "appointment_status"
  """
  appointment_status_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_status_order_by!]

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): appointment_status_aggregate!

  """
  fetch data from the table: "appointment_status" using primary key columns
  """
  appointment_status_by_pk(status: String!): appointment_status

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!

  """fetch data from the table: "appointments" using primary key columns"""
  appointments_by_pk(id: uuid!): appointments

  """An array relationship"""
  attachments(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """An aggregate relationship"""
  attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): attachments_aggregate!

  """fetch data from the table: "attachments" using primary key columns"""
  attachments_by_pk(id: uuid!): attachments

  """
  fetch data from the table: "attendance"
  """
  attendance(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """
  fetch aggregated fields from the table: "attendance"
  """
  attendance_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): attendance_aggregate!

  """fetch data from the table: "attendance" using primary key columns"""
  attendance_by_pk(id: uuid!): attendance

  """
  fetch data from the table: "attendance_state"
  """
  attendance_state(
    """distinct select on columns"""
    distinct_on: [attendance_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_state_order_by!]

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): [attendance_state!]!

  """
  fetch aggregated fields from the table: "attendance_state"
  """
  attendance_state_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_state_order_by!]

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): attendance_state_aggregate!

  """
  fetch data from the table: "attendance_state" using primary key columns
  """
  attendance_state_by_pk(id: uuid!): attendance_state

  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An aggregate relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!

  """fetch data from the table: "companies" using primary key columns"""
  companies_by_pk(id: uuid!): companies

  """An array relationship"""
  company_settings(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): [company_settings!]!

  """An aggregate relationship"""
  company_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): company_settings_aggregate!

  """
  fetch data from the table: "company_settings" using primary key columns
  """
  company_settings_by_pk(id: uuid!): company_settings

  """
  fetch data from the table: "conversations"
  """
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """
  fetch aggregated fields from the table: "conversations"
  """
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """fetch data from the table: "conversations" using primary key columns"""
  conversations_by_pk(id: uuid!): conversations

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """fetch data from the table: "departments" using primary key columns"""
  departments_by_pk(id: uuid!): departments

  """
  fetch data from the table: "employee_conversation"
  """
  employee_conversation(
    """distinct select on columns"""
    distinct_on: [employee_conversation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_conversation_order_by!]

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): [employee_conversation!]!

  """
  fetch aggregated fields from the table: "employee_conversation"
  """
  employee_conversation_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_conversation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_conversation_order_by!]

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): employee_conversation_aggregate!

  """
  fetch data from the table: "employee_conversation" using primary key columns
  """
  employee_conversation_by_pk(id: uuid!): employee_conversation

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!

  """
  fetch data from the table: "employee_notifications" using primary key columns
  """
  employee_notifications_by_pk(id: uuid!): employee_notifications

  """An array relationship"""
  employee_roles(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An aggregate relationship"""
  employee_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): employee_roles_aggregate!

  """fetch data from the table: "employee_roles" using primary key columns"""
  employee_roles_by_pk(id: uuid!): employee_roles

  """An array relationship"""
  employee_shifts(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An aggregate relationship"""
  employee_shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): employee_shifts_aggregate!

  """fetch data from the table: "employee_shifts" using primary key columns"""
  employee_shifts_by_pk(id: uuid!): employee_shifts

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """fetch data from the table: "employees" using primary key columns"""
  employees_by_pk(id: uuid!): employees

  """
  fetch data from the table: "event_notification"
  """
  event_notification(
    """distinct select on columns"""
    distinct_on: [event_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_notification_order_by!]

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): [event_notification!]!

  """
  fetch aggregated fields from the table: "event_notification"
  """
  event_notification_aggregate(
    """distinct select on columns"""
    distinct_on: [event_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_notification_order_by!]

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): event_notification_aggregate!

  """
  fetch data from the table: "event_notification" using primary key columns
  """
  event_notification_by_pk(id: uuid!): event_notification

  """An array relationship"""
  event_participants(
    """distinct select on columns"""
    distinct_on: [event_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_participants_order_by!]

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): [event_participants!]!

  """An aggregate relationship"""
  event_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [event_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_participants_order_by!]

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): event_participants_aggregate!

  """
  fetch data from the table: "event_participants" using primary key columns
  """
  event_participants_by_pk(id: uuid!): event_participants

  """An array relationship"""
  events(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """An aggregate relationship"""
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): events_aggregate!

  """fetch data from the table: "events" using primary key columns"""
  events_by_pk(id: uuid!): events

  """
  fetch data from the table: "files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: uuid!): files

  """
  fetch data from the table: "gender"
  """
  gender(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch aggregated fields from the table: "gender"
  """
  gender_aggregate(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): gender_aggregate!

  """fetch data from the table: "gender" using primary key columns"""
  gender_by_pk(gender: String!): gender

  """
  fetch data from the table: "geography_columns"
  """
  geography_columns(
    """distinct select on columns"""
    distinct_on: [geography_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geography_columns_order_by!]

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): [geography_columns!]!

  """
  fetch aggregated fields from the table: "geography_columns"
  """
  geography_columns_aggregate(
    """distinct select on columns"""
    distinct_on: [geography_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geography_columns_order_by!]

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): geography_columns_aggregate!

  """
  fetch data from the table: "geometry_columns"
  """
  geometry_columns(
    """distinct select on columns"""
    distinct_on: [geometry_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geometry_columns_order_by!]

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): [geometry_columns!]!

  """
  fetch aggregated fields from the table: "geometry_columns"
  """
  geometry_columns_aggregate(
    """distinct select on columns"""
    distinct_on: [geometry_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geometry_columns_order_by!]

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): geometry_columns_aggregate!
  getAppointmentTodayPercent(employee: EmployeeAppointmentId!): AppointmentTodayPercentage!
  getAttendanceByDay: [AttendanceCountByWeek!]!
  getAttendancePercentage: AttendnacePercentage!
  getEventsByUser(inputs: EventByUserInput!): [EventWithUserParticipant!]!
  getPercentageTask(id: EmployeeId!): TaskCompletionPercentage!
  getReportAttandance(input: AttendanceInpuType!): [DayAttendanceType!]!
  getTotalEmployeeOnLeave: EmployeeOnLeave!
  getVisitsByDay: [VisitsCountByDay!]!

  """An array relationship"""
  group_members(
    """distinct select on columns"""
    distinct_on: [group_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_members_order_by!]

    """filter the rows returned"""
    where: group_members_bool_exp
  ): [group_members!]!

  """An aggregate relationship"""
  group_members_aggregate(
    """distinct select on columns"""
    distinct_on: [group_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_members_order_by!]

    """filter the rows returned"""
    where: group_members_bool_exp
  ): group_members_aggregate!

  """fetch data from the table: "group_members" using primary key columns"""
  group_members_by_pk(id: uuid!): group_members

  """An array relationship"""
  group_messages(
    """distinct select on columns"""
    distinct_on: [group_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_messages_order_by!]

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): [group_messages!]!

  """An aggregate relationship"""
  group_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [group_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_messages_order_by!]

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): group_messages_aggregate!

  """fetch data from the table: "group_messages" using primary key columns"""
  group_messages_by_pk(id: uuid!): group_messages

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """fetch data from the table: "groups" using primary key columns"""
  groups_by_pk(id: uuid!): groups

  """
  fetch data from the table: "leave_approval"
  """
  leave_approval(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """
  fetch aggregated fields from the table: "leave_approval"
  """
  leave_approval_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """fetch data from the table: "leave_approval" using primary key columns"""
  leave_approval_by_pk(id: uuid!): leave_approval

  """
  fetch data from the table: "leave_approval_status"
  """
  leave_approval_status(
    """distinct select on columns"""
    distinct_on: [leave_approval_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_status_order_by!]

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): [leave_approval_status!]!

  """
  fetch aggregated fields from the table: "leave_approval_status"
  """
  leave_approval_status_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_status_order_by!]

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): leave_approval_status_aggregate!

  """
  fetch data from the table: "leave_approval_status" using primary key columns
  """
  leave_approval_status_by_pk(id: uuid!): leave_approval_status

  """
  fetch data from the table: "leave_status"
  """
  leave_status(
    """distinct select on columns"""
    distinct_on: [leave_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_status_order_by!]

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): [leave_status!]!

  """
  fetch aggregated fields from the table: "leave_status"
  """
  leave_status_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_status_order_by!]

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): leave_status_aggregate!

  """fetch data from the table: "leave_status" using primary key columns"""
  leave_status_by_pk(status: String!): leave_status

  """
  fetch data from the table: "leave_type"
  """
  leave_type(
    """distinct select on columns"""
    distinct_on: [leave_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_type_order_by!]

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): [leave_type!]!

  """
  fetch aggregated fields from the table: "leave_type"
  """
  leave_type_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_type_order_by!]

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): leave_type_aggregate!

  """fetch data from the table: "leave_type" using primary key columns"""
  leave_type_by_pk(type: String!): leave_type

  """
  fetch data from the table: "leave_types"
  """
  leave_types(
    """distinct select on columns"""
    distinct_on: [leave_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_types_order_by!]

    """filter the rows returned"""
    where: leave_types_bool_exp
  ): [leave_types!]!

  """
  fetch aggregated fields from the table: "leave_types"
  """
  leave_types_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_types_order_by!]

    """filter the rows returned"""
    where: leave_types_bool_exp
  ): leave_types_aggregate!

  """fetch data from the table: "leave_types" using primary key columns"""
  leave_types_by_pk(id: uuid!): leave_types

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!

  """fetch data from the table: "leaves" using primary key columns"""
  leaves_by_pk(id: uuid!): leaves

  """
  fetch data from the table: "locations"
  """
  locations(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """
  fetch aggregated fields from the table: "locations"
  """
  locations_aggregate(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): locations_aggregate!

  """fetch data from the table: "locations" using primary key columns"""
  locations_by_pk(id: uuid!): locations
  loginEmployee(firebaseToken: String = null, password: String!, phoneNumber: String!): LoginReturnType

  """An array relationship"""
  message_statuses(
    """distinct select on columns"""
    distinct_on: [message_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_statuses_order_by!]

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): [message_statuses!]!

  """An aggregate relationship"""
  message_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [message_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_statuses_order_by!]

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): message_statuses_aggregate!

  """
  fetch data from the table: "message_statuses" using primary key columns
  """
  message_statuses_by_pk(id: uuid!): message_statuses

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages
  name: String!

  """An array relationship"""
  positions(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """An aggregate relationship"""
  positions_aggregate(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): positions_aggregate!

  """fetch data from the table: "positions" using primary key columns"""
  positions_by_pk(id: uuid!): positions

  """
  fetch data from the table: "reports"
  """
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch aggregated fields from the table: "reports"
  """
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!

  """fetch data from the table: "reports" using primary key columns"""
  reports_by_pk(id: uuid!): reports

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(id: uuid!): services

  """
  fetch data from the table: "shifts"
  """
  shifts(
    """distinct select on columns"""
    distinct_on: [shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shifts_order_by!]

    """filter the rows returned"""
    where: shifts_bool_exp
  ): [shifts!]!

  """
  fetch aggregated fields from the table: "shifts"
  """
  shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shifts_order_by!]

    """filter the rows returned"""
    where: shifts_bool_exp
  ): shifts_aggregate!

  """fetch data from the table: "shifts" using primary key columns"""
  shifts_by_pk(id: uuid!): shifts

  """
  fetch data from the table: "spatial_ref_sys"
  """
  spatial_ref_sys(
    """distinct select on columns"""
    distinct_on: [spatial_ref_sys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [spatial_ref_sys_order_by!]

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): [spatial_ref_sys!]!

  """
  fetch aggregated fields from the table: "spatial_ref_sys"
  """
  spatial_ref_sys_aggregate(
    """distinct select on columns"""
    distinct_on: [spatial_ref_sys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [spatial_ref_sys_order_by!]

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): spatial_ref_sys_aggregate!

  """fetch data from the table: "spatial_ref_sys" using primary key columns"""
  spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(status: String!): status

  """
  fetch data from the table: "task_status"
  """
  task_status(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): [task_status!]!

  """
  fetch aggregated fields from the table: "task_status"
  """
  task_status_aggregate(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): task_status_aggregate!

  """fetch data from the table: "task_status" using primary key columns"""
  task_status_by_pk(id: uuid!): task_status

  """An array relationship"""
  tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """An aggregate relationship"""
  tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!

  """fetch data from the table: "tasks" using primary key columns"""
  tasks_by_pk(id: uuid!): tasks

  """
  fetch data from the table: "text_content"
  """
  text_content(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): [text_content!]!

  """
  fetch aggregated fields from the table: "text_content"
  """
  text_content_aggregate(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): text_content_aggregate!

  """fetch data from the table: "text_content" using primary key columns"""
  text_content_by_pk(id: uuid!): text_content

  """
  fetch data from the table: "topology.layer"
  """
  topology_layer(
    """distinct select on columns"""
    distinct_on: [topology_layer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_layer_order_by!]

    """filter the rows returned"""
    where: topology_layer_bool_exp
  ): [topology_layer!]!

  """
  fetch aggregated fields from the table: "topology.layer"
  """
  topology_layer_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_layer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_layer_order_by!]

    """filter the rows returned"""
    where: topology_layer_bool_exp
  ): topology_layer_aggregate!

  """fetch data from the table: "topology.layer" using primary key columns"""
  topology_layer_by_pk(layer_id: Int!, topology_id: Int!): topology_layer

  """
  fetch data from the table: "topology.topology"
  """
  topology_topology(
    """distinct select on columns"""
    distinct_on: [topology_topology_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_topology_order_by!]

    """filter the rows returned"""
    where: topology_topology_bool_exp
  ): [topology_topology!]!

  """
  fetch aggregated fields from the table: "topology.topology"
  """
  topology_topology_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_topology_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_topology_order_by!]

    """filter the rows returned"""
    where: topology_topology_bool_exp
  ): topology_topology_aggregate!

  """
  fetch data from the table: "topology.topology" using primary key columns
  """
  topology_topology_by_pk(id: Int!): topology_topology

  """
  fetch data from the table: "translations"
  """
  translations(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): [translations!]!

  """
  fetch aggregated fields from the table: "translations"
  """
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): translations_aggregate!

  """fetch data from the table: "translations" using primary key columns"""
  translations_by_pk(id: uuid!): translations

  """An array relationship"""
  typing_statuses(
    """distinct select on columns"""
    distinct_on: [typing_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [typing_statuses_order_by!]

    """filter the rows returned"""
    where: typing_statuses_bool_exp
  ): [typing_statuses!]!

  """An aggregate relationship"""
  typing_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [typing_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [typing_statuses_order_by!]

    """filter the rows returned"""
    where: typing_statuses_bool_exp
  ): typing_statuses_aggregate!

  """fetch data from the table: "typing_statuses" using primary key columns"""
  typing_statuses_by_pk(id: uuid!): typing_statuses

  """
  fetch data from the table: "vehicles"
  """
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """
  fetch aggregated fields from the table: "vehicles"
  """
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!

  """fetch data from the table: "vehicles" using primary key columns"""
  vehicles_by_pk(id: uuid!): vehicles

  """
  fetch data from the table: "visit_status"
  """
  visit_status(
    """distinct select on columns"""
    distinct_on: [visit_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visit_status_order_by!]

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): [visit_status!]!

  """
  fetch aggregated fields from the table: "visit_status"
  """
  visit_status_aggregate(
    """distinct select on columns"""
    distinct_on: [visit_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visit_status_order_by!]

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): visit_status_aggregate!

  """fetch data from the table: "visit_status" using primary key columns"""
  visit_status_by_pk(status: String!): visit_status

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!

  """fetch data from the table: "visitors" using primary key columns"""
  visitors_by_pk(id: uuid!): visitors

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!

  """fetch data from the table: "visits" using primary key columns"""
  visits_by_pk(id: uuid!): visits
}

"""
columns and relationships of "reports"
"""
type reports {
  created_at: timestamptz
  from_date: date!
  id: uuid!
  name: String!
  report_link: String!
  to_date: date!
  types: reporttypes
  updated_at: timestamptz
}

"""
aggregated selection of "reports"
"""
type reports_aggregate {
  aggregate: reports_aggregate_fields
  nodes: [reports!]!
}

"""
aggregate fields of "reports"
"""
type reports_aggregate_fields {
  count(columns: [reports_select_column!], distinct: Boolean): Int!
  max: reports_max_fields
  min: reports_min_fields
}

"""
Boolean expression to filter rows from the table "reports". All fields are combined with a logical 'AND'.
"""
input reports_bool_exp {
  _and: [reports_bool_exp!]
  _not: reports_bool_exp
  _or: [reports_bool_exp!]
  created_at: timestamptz_comparison_exp
  from_date: date_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  report_link: String_comparison_exp
  to_date: date_comparison_exp
  types: reporttypes_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "reports"
"""
enum reports_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  reports_pkey
}

"""
input type for inserting data into table "reports"
"""
input reports_insert_input {
  created_at: timestamptz
  from_date: date
  id: uuid
  name: String
  report_link: String
  to_date: date
  types: reporttypes
  updated_at: timestamptz
}

"""aggregate max on columns"""
type reports_max_fields {
  created_at: timestamptz
  from_date: date
  id: uuid
  name: String
  report_link: String
  to_date: date
  types: reporttypes
  updated_at: timestamptz
}

"""aggregate min on columns"""
type reports_min_fields {
  created_at: timestamptz
  from_date: date
  id: uuid
  name: String
  report_link: String
  to_date: date
  types: reporttypes
  updated_at: timestamptz
}

"""
response of any mutation on the table "reports"
"""
type reports_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [reports!]!
}

"""
on_conflict condition type for table "reports"
"""
input reports_on_conflict {
  constraint: reports_constraint!
  update_columns: [reports_update_column!]! = []
  where: reports_bool_exp
}

"""Ordering options when selecting data from "reports"."""
input reports_order_by {
  created_at: order_by
  from_date: order_by
  id: order_by
  name: order_by
  report_link: order_by
  to_date: order_by
  types: order_by
  updated_at: order_by
}

"""primary key columns input for table: reports"""
input reports_pk_columns_input {
  id: uuid!
}

"""
select columns of table "reports"
"""
enum reports_select_column {
  """column name"""
  created_at

  """column name"""
  from_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  report_link

  """column name"""
  to_date

  """column name"""
  types

  """column name"""
  updated_at
}

"""
input type for updating data in table "reports"
"""
input reports_set_input {
  created_at: timestamptz
  from_date: date
  id: uuid
  name: String
  report_link: String
  to_date: date
  types: reporttypes
  updated_at: timestamptz
}

"""
Streaming cursor of the table "reports"
"""
input reports_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: reports_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input reports_stream_cursor_value_input {
  created_at: timestamptz
  from_date: date
  id: uuid
  name: String
  report_link: String
  to_date: date
  types: reporttypes
  updated_at: timestamptz
}

"""
update columns of table "reports"
"""
enum reports_update_column {
  """column name"""
  created_at

  """column name"""
  from_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  report_link

  """column name"""
  to_date

  """column name"""
  types

  """column name"""
  updated_at
}

input reports_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: reports_set_input

  """filter the rows which have to be updated"""
  where: reports_bool_exp!
}

scalar reporttypes

"""
Boolean expression to compare columns of type "reporttypes". All fields are combined with logical 'AND'.
"""
input reporttypes_comparison_exp {
  _eq: reporttypes
  _gt: reporttypes
  _gte: reporttypes
  _in: [reporttypes!]
  _is_null: Boolean
  _lt: reporttypes
  _lte: reporttypes
  _neq: reporttypes
  _nin: [reporttypes!]
}

"""
columns and relationships of "roles"
"""
type roles {
  created_at: timestamptz

  """An array relationship"""
  employee_roles(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An aggregate relationship"""
  employee_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): employee_roles_aggregate!
  id: uuid!
  role_name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  count(columns: [roles_select_column!], distinct: Boolean): Int!
  max: roles_max_fields
  min: roles_min_fields
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee_roles: employee_roles_bool_exp
  employee_roles_aggregate: employee_roles_aggregate_bool_exp
  id: uuid_comparison_exp
  role_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey

  """
  unique or primary key constraint on columns "role_name"
  """
  roles_role_name_key
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  created_at: timestamptz
  employee_roles: employee_roles_arr_rel_insert_input
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type roles_max_fields {
  created_at: timestamptz
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type roles_min_fields {
  created_at: timestamptz
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input roles_obj_rel_insert_input {
  data: roles_insert_input!

  """upsert condition"""
  on_conflict: roles_on_conflict
}

"""
on_conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]! = []
  where: roles_bool_exp
}

"""Ordering options when selecting data from "roles"."""
input roles_order_by {
  created_at: order_by
  employee_roles_aggregate: employee_roles_aggregate_order_by
  id: order_by
  role_name: order_by
  updated_at: order_by
}

"""primary key columns input for table: roles"""
input roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role_name

  """column name"""
  updated_at
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  created_at: timestamptz
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "roles"
"""
input roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input roles_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role_name

  """column name"""
  updated_at
}

input roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: roles_set_input

  """filter the rows which have to be updated"""
  where: roles_bool_exp!
}

type RoleType {
  createdAt: DateTime
  id: UUID!
  roleName: String!
  updatedAt: DateTime
}

"""
columns and relationships of "services"
"""
type services {
  agency_id: uuid
  chief_service: uuid

  """An object relationship"""
  company: companies

  """An object relationship"""
  companyByCompanyId: companies
  company_id: uuid
  created_at: timestamptz

  """An object relationship"""
  department: departments
  department_id: uuid

  """An object relationship"""
  employee: employees

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  name: uuid
  status: status_enum

  """An object relationship"""
  statusByStatus: status

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "services"
"""
type services_aggregate {
  aggregate: services_aggregate_fields
  nodes: [services!]!
}

input services_aggregate_bool_exp {
  count: services_aggregate_bool_exp_count
}

input services_aggregate_bool_exp_count {
  arguments: [services_select_column!]
  distinct: Boolean
  filter: services_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "services"
"""
type services_aggregate_fields {
  count(columns: [services_select_column!], distinct: Boolean): Int!
  max: services_max_fields
  min: services_min_fields
}

"""
order by aggregate values of table "services"
"""
input services_aggregate_order_by {
  count: order_by
  max: services_max_order_by
  min: services_min_order_by
}

"""
input type for inserting array relation for remote table "services"
"""
input services_arr_rel_insert_input {
  data: [services_insert_input!]!

  """upsert condition"""
  on_conflict: services_on_conflict
}

"""
Boolean expression to filter rows from the table "services". All fields are combined with a logical 'AND'.
"""
input services_bool_exp {
  _and: [services_bool_exp!]
  _not: services_bool_exp
  _or: [services_bool_exp!]
  agency_id: uuid_comparison_exp
  chief_service: uuid_comparison_exp
  company: companies_bool_exp
  companyByCompanyId: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  department: departments_bool_exp
  department_id: uuid_comparison_exp
  employee: employees_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  name: uuid_comparison_exp
  status: status_enum_comparison_exp
  statusByStatus: status_bool_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "services"
"""
enum services_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  services_pkey
}

"""
input type for inserting data into table "services"
"""
input services_insert_input {
  agency_id: uuid
  chief_service: uuid
  company: companies_obj_rel_insert_input
  companyByCompanyId: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  department: departments_obj_rel_insert_input
  department_id: uuid
  employee: employees_obj_rel_insert_input
  employees: employees_arr_rel_insert_input
  id: uuid
  name: uuid
  status: status_enum
  statusByStatus: status_obj_rel_insert_input
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type services_max_fields {
  agency_id: uuid
  chief_service: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  id: uuid
  name: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "services"
"""
input services_max_order_by {
  agency_id: order_by
  chief_service: order_by
  company_id: order_by
  created_at: order_by
  department_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type services_min_fields {
  agency_id: uuid
  chief_service: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  id: uuid
  name: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "services"
"""
input services_min_order_by {
  agency_id: order_by
  chief_service: order_by
  company_id: order_by
  created_at: order_by
  department_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "services"
"""
type services_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [services!]!
}

"""
input type for inserting object relation for remote table "services"
"""
input services_obj_rel_insert_input {
  data: services_insert_input!

  """upsert condition"""
  on_conflict: services_on_conflict
}

"""
on_conflict condition type for table "services"
"""
input services_on_conflict {
  constraint: services_constraint!
  update_columns: [services_update_column!]! = []
  where: services_bool_exp
}

"""Ordering options when selecting data from "services"."""
input services_order_by {
  agency_id: order_by
  chief_service: order_by
  company: companies_order_by
  companyByCompanyId: companies_order_by
  company_id: order_by
  created_at: order_by
  department: departments_order_by
  department_id: order_by
  employee: employees_order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  name: order_by
  status: order_by
  statusByStatus: status_order_by
  text_content: text_content_order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: services"""
input services_pk_columns_input {
  id: uuid!
}

"""
select columns of table "services"
"""
enum services_select_column {
  """column name"""
  agency_id

  """column name"""
  chief_service

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  department_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "services"
"""
input services_set_input {
  agency_id: uuid
  chief_service: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  id: uuid
  name: uuid
  status: status_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "services"
"""
input services_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: services_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input services_stream_cursor_value_input {
  agency_id: uuid
  chief_service: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  id: uuid
  name: uuid
  status: status_enum
  updated_at: timestamptz
}

"""
update columns of table "services"
"""
enum services_update_column {
  """column name"""
  agency_id

  """column name"""
  chief_service

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  department_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  status

  """column name"""
  updated_at
}

input services_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: services_set_input

  """filter the rows which have to be updated"""
  where: services_bool_exp!
}

"""
columns and relationships of "shifts"
"""
type shifts {
  """An array relationship"""
  attendances(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """An aggregate relationship"""
  attendances_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): attendance_aggregate!

  """An array relationship"""
  employee_shifts(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An aggregate relationship"""
  employee_shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): employee_shifts_aggregate!
  end_time: time!
  id: uuid!
  name: String!
  start_time: time!
  working_days: [Int!]
}

"""
aggregated selection of "shifts"
"""
type shifts_aggregate {
  aggregate: shifts_aggregate_fields
  nodes: [shifts!]!
}

"""
aggregate fields of "shifts"
"""
type shifts_aggregate_fields {
  count(columns: [shifts_select_column!], distinct: Boolean): Int!
  max: shifts_max_fields
  min: shifts_min_fields
}

"""
Boolean expression to filter rows from the table "shifts". All fields are combined with a logical 'AND'.
"""
input shifts_bool_exp {
  _and: [shifts_bool_exp!]
  _not: shifts_bool_exp
  _or: [shifts_bool_exp!]
  attendances: attendance_bool_exp
  attendances_aggregate: attendance_aggregate_bool_exp
  employee_shifts: employee_shifts_bool_exp
  employee_shifts_aggregate: employee_shifts_aggregate_bool_exp
  end_time: time_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  start_time: time_comparison_exp
  working_days: Int_array_comparison_exp
}

"""
unique or primary key constraints on table "shifts"
"""
enum shifts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shifts_pkey
}

"""
input type for inserting data into table "shifts"
"""
input shifts_insert_input {
  attendances: attendance_arr_rel_insert_input
  employee_shifts: employee_shifts_arr_rel_insert_input
  end_time: time
  id: uuid
  name: String
  start_time: time
  working_days: [Int!]
}

"""aggregate max on columns"""
type shifts_max_fields {
  id: uuid
  name: String
  working_days: [Int!]
}

"""aggregate min on columns"""
type shifts_min_fields {
  id: uuid
  name: String
  working_days: [Int!]
}

"""
response of any mutation on the table "shifts"
"""
type shifts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shifts!]!
}

"""
input type for inserting object relation for remote table "shifts"
"""
input shifts_obj_rel_insert_input {
  data: shifts_insert_input!

  """upsert condition"""
  on_conflict: shifts_on_conflict
}

"""
on_conflict condition type for table "shifts"
"""
input shifts_on_conflict {
  constraint: shifts_constraint!
  update_columns: [shifts_update_column!]! = []
  where: shifts_bool_exp
}

"""Ordering options when selecting data from "shifts"."""
input shifts_order_by {
  attendances_aggregate: attendance_aggregate_order_by
  employee_shifts_aggregate: employee_shifts_aggregate_order_by
  end_time: order_by
  id: order_by
  name: order_by
  start_time: order_by
  working_days: order_by
}

"""primary key columns input for table: shifts"""
input shifts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "shifts"
"""
enum shifts_select_column {
  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  name

  """column name"""
  start_time

  """column name"""
  working_days
}

"""
input type for updating data in table "shifts"
"""
input shifts_set_input {
  end_time: time
  id: uuid
  name: String
  start_time: time
  working_days: [Int!]
}

"""
Streaming cursor of the table "shifts"
"""
input shifts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shifts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shifts_stream_cursor_value_input {
  end_time: time
  id: uuid
  name: String
  start_time: time
  working_days: [Int!]
}

"""
update columns of table "shifts"
"""
enum shifts_update_column {
  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  name

  """column name"""
  start_time

  """column name"""
  working_days
}

input shifts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: shifts_set_input

  """filter the rows which have to be updated"""
  where: shifts_bool_exp!
}

"""
columns and relationships of "spatial_ref_sys"
"""
type spatial_ref_sys {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int!
  srtext: String
}

"""
aggregated selection of "spatial_ref_sys"
"""
type spatial_ref_sys_aggregate {
  aggregate: spatial_ref_sys_aggregate_fields
  nodes: [spatial_ref_sys!]!
}

"""
aggregate fields of "spatial_ref_sys"
"""
type spatial_ref_sys_aggregate_fields {
  avg: spatial_ref_sys_avg_fields
  count(columns: [spatial_ref_sys_select_column!], distinct: Boolean): Int!
  max: spatial_ref_sys_max_fields
  min: spatial_ref_sys_min_fields
  stddev: spatial_ref_sys_stddev_fields
  stddev_pop: spatial_ref_sys_stddev_pop_fields
  stddev_samp: spatial_ref_sys_stddev_samp_fields
  sum: spatial_ref_sys_sum_fields
  var_pop: spatial_ref_sys_var_pop_fields
  var_samp: spatial_ref_sys_var_samp_fields
  variance: spatial_ref_sys_variance_fields
}

"""aggregate avg on columns"""
type spatial_ref_sys_avg_fields {
  auth_srid: Float
  srid: Float
}

"""
Boolean expression to filter rows from the table "spatial_ref_sys". All fields are combined with a logical 'AND'.
"""
input spatial_ref_sys_bool_exp {
  _and: [spatial_ref_sys_bool_exp!]
  _not: spatial_ref_sys_bool_exp
  _or: [spatial_ref_sys_bool_exp!]
  auth_name: String_comparison_exp
  auth_srid: Int_comparison_exp
  proj4text: String_comparison_exp
  srid: Int_comparison_exp
  srtext: String_comparison_exp
}

"""
unique or primary key constraints on table "spatial_ref_sys"
"""
enum spatial_ref_sys_constraint {
  """
  unique or primary key constraint on columns "srid"
  """
  spatial_ref_sys_pkey
}

"""
input type for incrementing numeric columns in table "spatial_ref_sys"
"""
input spatial_ref_sys_inc_input {
  auth_srid: Int
  srid: Int
}

"""
input type for inserting data into table "spatial_ref_sys"
"""
input spatial_ref_sys_insert_input {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""aggregate max on columns"""
type spatial_ref_sys_max_fields {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""aggregate min on columns"""
type spatial_ref_sys_min_fields {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""
response of any mutation on the table "spatial_ref_sys"
"""
type spatial_ref_sys_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [spatial_ref_sys!]!
}

"""
on_conflict condition type for table "spatial_ref_sys"
"""
input spatial_ref_sys_on_conflict {
  constraint: spatial_ref_sys_constraint!
  update_columns: [spatial_ref_sys_update_column!]! = []
  where: spatial_ref_sys_bool_exp
}

"""Ordering options when selecting data from "spatial_ref_sys"."""
input spatial_ref_sys_order_by {
  auth_name: order_by
  auth_srid: order_by
  proj4text: order_by
  srid: order_by
  srtext: order_by
}

"""primary key columns input for table: spatial_ref_sys"""
input spatial_ref_sys_pk_columns_input {
  srid: Int!
}

"""
select columns of table "spatial_ref_sys"
"""
enum spatial_ref_sys_select_column {
  """column name"""
  auth_name

  """column name"""
  auth_srid

  """column name"""
  proj4text

  """column name"""
  srid

  """column name"""
  srtext
}

"""
input type for updating data in table "spatial_ref_sys"
"""
input spatial_ref_sys_set_input {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""aggregate stddev on columns"""
type spatial_ref_sys_stddev_fields {
  auth_srid: Float
  srid: Float
}

"""aggregate stddev_pop on columns"""
type spatial_ref_sys_stddev_pop_fields {
  auth_srid: Float
  srid: Float
}

"""aggregate stddev_samp on columns"""
type spatial_ref_sys_stddev_samp_fields {
  auth_srid: Float
  srid: Float
}

"""
Streaming cursor of the table "spatial_ref_sys"
"""
input spatial_ref_sys_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: spatial_ref_sys_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input spatial_ref_sys_stream_cursor_value_input {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""aggregate sum on columns"""
type spatial_ref_sys_sum_fields {
  auth_srid: Int
  srid: Int
}

"""
update columns of table "spatial_ref_sys"
"""
enum spatial_ref_sys_update_column {
  """column name"""
  auth_name

  """column name"""
  auth_srid

  """column name"""
  proj4text

  """column name"""
  srid

  """column name"""
  srtext
}

input spatial_ref_sys_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: spatial_ref_sys_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: spatial_ref_sys_set_input

  """filter the rows which have to be updated"""
  where: spatial_ref_sys_bool_exp!
}

"""aggregate var_pop on columns"""
type spatial_ref_sys_var_pop_fields {
  auth_srid: Float
  srid: Float
}

"""aggregate var_samp on columns"""
type spatial_ref_sys_var_samp_fields {
  auth_srid: Float
  srid: Float
}

"""aggregate variance on columns"""
type spatial_ref_sys_variance_fields {
  auth_srid: Float
  srid: Float
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"""
columns and relationships of "status"
"""
type status {
  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  status: String!
}

"""
aggregated selection of "status"
"""
type status_aggregate {
  aggregate: status_aggregate_fields
  nodes: [status!]!
}

"""
aggregate fields of "status"
"""
type status_aggregate_fields {
  count(columns: [status_select_column!], distinct: Boolean): Int!
  max: status_max_fields
  min: status_min_fields
}

"""
Boolean expression to filter rows from the table "status". All fields are combined with a logical 'AND'.
"""
input status_bool_exp {
  _and: [status_bool_exp!]
  _not: status_bool_exp
  _or: [status_bool_exp!]
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "status"
"""
enum status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  status_pkey
}

enum status_enum {
  ACTIVE
  INACTIVE
}

"""
Boolean expression to compare columns of type "status_enum". All fields are combined with logical 'AND'.
"""
input status_enum_comparison_exp {
  _eq: status_enum
  _in: [status_enum!]
  _is_null: Boolean
  _neq: status_enum
  _nin: [status_enum!]
}

"""
input type for inserting data into table "status"
"""
input status_insert_input {
  departments: departments_arr_rel_insert_input
  employees: employees_arr_rel_insert_input
  services: services_arr_rel_insert_input
  status: String
}

"""aggregate max on columns"""
type status_max_fields {
  status: String
}

"""aggregate min on columns"""
type status_min_fields {
  status: String
}

"""
response of any mutation on the table "status"
"""
type status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [status!]!
}

"""
input type for inserting object relation for remote table "status"
"""
input status_obj_rel_insert_input {
  data: status_insert_input!

  """upsert condition"""
  on_conflict: status_on_conflict
}

"""
on_conflict condition type for table "status"
"""
input status_on_conflict {
  constraint: status_constraint!
  update_columns: [status_update_column!]! = []
  where: status_bool_exp
}

"""Ordering options when selecting data from "status"."""
input status_order_by {
  departments_aggregate: departments_aggregate_order_by
  employees_aggregate: employees_aggregate_order_by
  services_aggregate: services_aggregate_order_by
  status: order_by
}

"""primary key columns input for table: status"""
input status_pk_columns_input {
  status: String!
}

"""
select columns of table "status"
"""
enum status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "status"
"""
input status_set_input {
  status: String
}

"""
Streaming cursor of the table "status"
"""
input status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "status"
"""
enum status_update_column {
  """column name"""
  status
}

input status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: status_set_input

  """filter the rows which have to be updated"""
  where: status_bool_exp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """An array relationship"""
  agencies(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An aggregate relationship"""
  agencies_aggregate(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): agencies_aggregate!

  """fetch data from the table: "agencies" using primary key columns"""
  agencies_by_pk(id: uuid!): agencies

  """
  fetch data from the table in a streaming manner: "agencies"
  """
  agencies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agencies_stream_cursor_input]!

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An array relationship"""
  alarms(
    """distinct select on columns"""
    distinct_on: [alarms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alarms_order_by!]

    """filter the rows returned"""
    where: alarms_bool_exp
  ): [alarms!]!

  """An aggregate relationship"""
  alarms_aggregate(
    """distinct select on columns"""
    distinct_on: [alarms_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alarms_order_by!]

    """filter the rows returned"""
    where: alarms_bool_exp
  ): alarms_aggregate!

  """fetch data from the table: "alarms" using primary key columns"""
  alarms_by_pk(id: uuid!): alarms

  """
  fetch data from the table in a streaming manner: "alarms"
  """
  alarms_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [alarms_stream_cursor_input]!

    """filter the rows returned"""
    where: alarms_bool_exp
  ): [alarms!]!

  """
  fetch data from the table: "app_versions"
  """
  app_versions(
    """distinct select on columns"""
    distinct_on: [app_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_versions_order_by!]

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): [app_versions!]!

  """
  fetch aggregated fields from the table: "app_versions"
  """
  app_versions_aggregate(
    """distinct select on columns"""
    distinct_on: [app_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_versions_order_by!]

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): app_versions_aggregate!

  """fetch data from the table: "app_versions" using primary key columns"""
  app_versions_by_pk(version: String!): app_versions

  """
  fetch data from the table in a streaming manner: "app_versions"
  """
  app_versions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [app_versions_stream_cursor_input]!

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): [app_versions!]!

  """
  fetch data from the table: "appointment_status"
  """
  appointment_status(
    """distinct select on columns"""
    distinct_on: [appointment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_status_order_by!]

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): [appointment_status!]!

  """
  fetch aggregated fields from the table: "appointment_status"
  """
  appointment_status_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_status_order_by!]

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): appointment_status_aggregate!

  """
  fetch data from the table: "appointment_status" using primary key columns
  """
  appointment_status_by_pk(status: String!): appointment_status

  """
  fetch data from the table in a streaming manner: "appointment_status"
  """
  appointment_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [appointment_status_stream_cursor_input]!

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): [appointment_status!]!

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!

  """fetch data from the table: "appointments" using primary key columns"""
  appointments_by_pk(id: uuid!): appointments

  """
  fetch data from the table in a streaming manner: "appointments"
  """
  appointments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [appointments_stream_cursor_input]!

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An array relationship"""
  attachments(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """An aggregate relationship"""
  attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): attachments_aggregate!

  """fetch data from the table: "attachments" using primary key columns"""
  attachments_by_pk(id: uuid!): attachments

  """
  fetch data from the table in a streaming manner: "attachments"
  """
  attachments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attachments_stream_cursor_input]!

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """
  fetch data from the table: "attendance"
  """
  attendance(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """
  fetch aggregated fields from the table: "attendance"
  """
  attendance_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): attendance_aggregate!

  """fetch data from the table: "attendance" using primary key columns"""
  attendance_by_pk(id: uuid!): attendance

  """
  fetch data from the table: "attendance_state"
  """
  attendance_state(
    """distinct select on columns"""
    distinct_on: [attendance_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_state_order_by!]

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): [attendance_state!]!

  """
  fetch aggregated fields from the table: "attendance_state"
  """
  attendance_state_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_state_order_by!]

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): attendance_state_aggregate!

  """
  fetch data from the table: "attendance_state" using primary key columns
  """
  attendance_state_by_pk(id: uuid!): attendance_state

  """
  fetch data from the table in a streaming manner: "attendance_state"
  """
  attendance_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attendance_state_stream_cursor_input]!

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): [attendance_state!]!

  """
  fetch data from the table in a streaming manner: "attendance"
  """
  attendance_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attendance_stream_cursor_input]!

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An aggregate relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!

  """fetch data from the table: "companies" using primary key columns"""
  companies_by_pk(id: uuid!): companies

  """
  fetch data from the table in a streaming manner: "companies"
  """
  companies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [companies_stream_cursor_input]!

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An array relationship"""
  company_settings(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): [company_settings!]!

  """An aggregate relationship"""
  company_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): company_settings_aggregate!

  """
  fetch data from the table: "company_settings" using primary key columns
  """
  company_settings_by_pk(id: uuid!): company_settings

  """
  fetch data from the table in a streaming manner: "company_settings"
  """
  company_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [company_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): [company_settings!]!

  """
  fetch data from the table: "conversations"
  """
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """
  fetch aggregated fields from the table: "conversations"
  """
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """fetch data from the table: "conversations" using primary key columns"""
  conversations_by_pk(id: uuid!): conversations

  """
  fetch data from the table in a streaming manner: "conversations"
  """
  conversations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conversations_stream_cursor_input]!

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """fetch data from the table: "departments" using primary key columns"""
  departments_by_pk(id: uuid!): departments

  """
  fetch data from the table in a streaming manner: "departments"
  """
  departments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [departments_stream_cursor_input]!

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """
  fetch data from the table: "employee_conversation"
  """
  employee_conversation(
    """distinct select on columns"""
    distinct_on: [employee_conversation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_conversation_order_by!]

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): [employee_conversation!]!

  """
  fetch aggregated fields from the table: "employee_conversation"
  """
  employee_conversation_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_conversation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_conversation_order_by!]

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): employee_conversation_aggregate!

  """
  fetch data from the table: "employee_conversation" using primary key columns
  """
  employee_conversation_by_pk(id: uuid!): employee_conversation

  """
  fetch data from the table in a streaming manner: "employee_conversation"
  """
  employee_conversation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employee_conversation_stream_cursor_input]!

    """filter the rows returned"""
    where: employee_conversation_bool_exp
  ): [employee_conversation!]!

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!

  """
  fetch data from the table: "employee_notifications" using primary key columns
  """
  employee_notifications_by_pk(id: uuid!): employee_notifications

  """
  fetch data from the table in a streaming manner: "employee_notifications"
  """
  employee_notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employee_notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An array relationship"""
  employee_roles(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An aggregate relationship"""
  employee_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): employee_roles_aggregate!

  """fetch data from the table: "employee_roles" using primary key columns"""
  employee_roles_by_pk(id: uuid!): employee_roles

  """
  fetch data from the table in a streaming manner: "employee_roles"
  """
  employee_roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employee_roles_stream_cursor_input]!

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An array relationship"""
  employee_shifts(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An aggregate relationship"""
  employee_shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): employee_shifts_aggregate!

  """fetch data from the table: "employee_shifts" using primary key columns"""
  employee_shifts_by_pk(id: uuid!): employee_shifts

  """
  fetch data from the table in a streaming manner: "employee_shifts"
  """
  employee_shifts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employee_shifts_stream_cursor_input]!

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """fetch data from the table: "employees" using primary key columns"""
  employees_by_pk(id: uuid!): employees

  """
  fetch data from the table in a streaming manner: "employees"
  """
  employees_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employees_stream_cursor_input]!

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """
  fetch data from the table: "event_notification"
  """
  event_notification(
    """distinct select on columns"""
    distinct_on: [event_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_notification_order_by!]

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): [event_notification!]!

  """
  fetch aggregated fields from the table: "event_notification"
  """
  event_notification_aggregate(
    """distinct select on columns"""
    distinct_on: [event_notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_notification_order_by!]

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): event_notification_aggregate!

  """
  fetch data from the table: "event_notification" using primary key columns
  """
  event_notification_by_pk(id: uuid!): event_notification

  """
  fetch data from the table in a streaming manner: "event_notification"
  """
  event_notification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [event_notification_stream_cursor_input]!

    """filter the rows returned"""
    where: event_notification_bool_exp
  ): [event_notification!]!

  """An array relationship"""
  event_participants(
    """distinct select on columns"""
    distinct_on: [event_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_participants_order_by!]

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): [event_participants!]!

  """An aggregate relationship"""
  event_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [event_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [event_participants_order_by!]

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): event_participants_aggregate!

  """
  fetch data from the table: "event_participants" using primary key columns
  """
  event_participants_by_pk(id: uuid!): event_participants

  """
  fetch data from the table in a streaming manner: "event_participants"
  """
  event_participants_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [event_participants_stream_cursor_input]!

    """filter the rows returned"""
    where: event_participants_bool_exp
  ): [event_participants!]!

  """An array relationship"""
  events(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """An aggregate relationship"""
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): events_aggregate!

  """fetch data from the table: "events" using primary key columns"""
  events_by_pk(id: uuid!): events

  """
  fetch data from the table in a streaming manner: "events"
  """
  events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [events_stream_cursor_input]!

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """
  fetch data from the table: "files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: uuid!): files

  """
  fetch data from the table in a streaming manner: "files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "gender"
  """
  gender(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch aggregated fields from the table: "gender"
  """
  gender_aggregate(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): gender_aggregate!

  """fetch data from the table: "gender" using primary key columns"""
  gender_by_pk(gender: String!): gender

  """
  fetch data from the table in a streaming manner: "gender"
  """
  gender_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [gender_stream_cursor_input]!

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch data from the table: "geography_columns"
  """
  geography_columns(
    """distinct select on columns"""
    distinct_on: [geography_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geography_columns_order_by!]

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): [geography_columns!]!

  """
  fetch aggregated fields from the table: "geography_columns"
  """
  geography_columns_aggregate(
    """distinct select on columns"""
    distinct_on: [geography_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geography_columns_order_by!]

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): geography_columns_aggregate!

  """
  fetch data from the table in a streaming manner: "geography_columns"
  """
  geography_columns_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [geography_columns_stream_cursor_input]!

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): [geography_columns!]!

  """
  fetch data from the table: "geometry_columns"
  """
  geometry_columns(
    """distinct select on columns"""
    distinct_on: [geometry_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geometry_columns_order_by!]

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): [geometry_columns!]!

  """
  fetch aggregated fields from the table: "geometry_columns"
  """
  geometry_columns_aggregate(
    """distinct select on columns"""
    distinct_on: [geometry_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geometry_columns_order_by!]

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): geometry_columns_aggregate!

  """
  fetch data from the table in a streaming manner: "geometry_columns"
  """
  geometry_columns_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [geometry_columns_stream_cursor_input]!

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): [geometry_columns!]!
  getAttendancePercentage: AttendnacePercentage!
  getReportAttandance(input: AttendanceInpuType!): [DayAttendanceType!]!

  """An array relationship"""
  group_members(
    """distinct select on columns"""
    distinct_on: [group_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_members_order_by!]

    """filter the rows returned"""
    where: group_members_bool_exp
  ): [group_members!]!

  """An aggregate relationship"""
  group_members_aggregate(
    """distinct select on columns"""
    distinct_on: [group_members_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_members_order_by!]

    """filter the rows returned"""
    where: group_members_bool_exp
  ): group_members_aggregate!

  """fetch data from the table: "group_members" using primary key columns"""
  group_members_by_pk(id: uuid!): group_members

  """
  fetch data from the table in a streaming manner: "group_members"
  """
  group_members_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [group_members_stream_cursor_input]!

    """filter the rows returned"""
    where: group_members_bool_exp
  ): [group_members!]!

  """An array relationship"""
  group_messages(
    """distinct select on columns"""
    distinct_on: [group_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_messages_order_by!]

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): [group_messages!]!

  """An aggregate relationship"""
  group_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [group_messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_messages_order_by!]

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): group_messages_aggregate!

  """fetch data from the table: "group_messages" using primary key columns"""
  group_messages_by_pk(id: uuid!): group_messages

  """
  fetch data from the table in a streaming manner: "group_messages"
  """
  group_messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [group_messages_stream_cursor_input]!

    """filter the rows returned"""
    where: group_messages_bool_exp
  ): [group_messages!]!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [groups_order_by!]

    """filter the rows returned"""
    where: groups_bool_exp
  ): groups_aggregate!

  """fetch data from the table: "groups" using primary key columns"""
  groups_by_pk(id: uuid!): groups

  """
  fetch data from the table in a streaming manner: "groups"
  """
  groups_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [groups_stream_cursor_input]!

    """filter the rows returned"""
    where: groups_bool_exp
  ): [groups!]!

  """
  fetch data from the table: "leave_approval"
  """
  leave_approval(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """
  fetch aggregated fields from the table: "leave_approval"
  """
  leave_approval_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """fetch data from the table: "leave_approval" using primary key columns"""
  leave_approval_by_pk(id: uuid!): leave_approval

  """
  fetch data from the table: "leave_approval_status"
  """
  leave_approval_status(
    """distinct select on columns"""
    distinct_on: [leave_approval_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_status_order_by!]

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): [leave_approval_status!]!

  """
  fetch aggregated fields from the table: "leave_approval_status"
  """
  leave_approval_status_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_status_order_by!]

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): leave_approval_status_aggregate!

  """
  fetch data from the table: "leave_approval_status" using primary key columns
  """
  leave_approval_status_by_pk(id: uuid!): leave_approval_status

  """
  fetch data from the table in a streaming manner: "leave_approval_status"
  """
  leave_approval_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_approval_status_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_approval_status_bool_exp
  ): [leave_approval_status!]!

  """
  fetch data from the table in a streaming manner: "leave_approval"
  """
  leave_approval_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_approval_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """
  fetch data from the table: "leave_status"
  """
  leave_status(
    """distinct select on columns"""
    distinct_on: [leave_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_status_order_by!]

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): [leave_status!]!

  """
  fetch aggregated fields from the table: "leave_status"
  """
  leave_status_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_status_order_by!]

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): leave_status_aggregate!

  """fetch data from the table: "leave_status" using primary key columns"""
  leave_status_by_pk(status: String!): leave_status

  """
  fetch data from the table in a streaming manner: "leave_status"
  """
  leave_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_status_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): [leave_status!]!

  """
  fetch data from the table: "leave_type"
  """
  leave_type(
    """distinct select on columns"""
    distinct_on: [leave_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_type_order_by!]

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): [leave_type!]!

  """
  fetch aggregated fields from the table: "leave_type"
  """
  leave_type_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_type_order_by!]

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): leave_type_aggregate!

  """fetch data from the table: "leave_type" using primary key columns"""
  leave_type_by_pk(type: String!): leave_type

  """
  fetch data from the table in a streaming manner: "leave_type"
  """
  leave_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_type_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): [leave_type!]!

  """
  fetch data from the table: "leave_types"
  """
  leave_types(
    """distinct select on columns"""
    distinct_on: [leave_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_types_order_by!]

    """filter the rows returned"""
    where: leave_types_bool_exp
  ): [leave_types!]!

  """
  fetch aggregated fields from the table: "leave_types"
  """
  leave_types_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_types_order_by!]

    """filter the rows returned"""
    where: leave_types_bool_exp
  ): leave_types_aggregate!

  """fetch data from the table: "leave_types" using primary key columns"""
  leave_types_by_pk(id: uuid!): leave_types

  """
  fetch data from the table in a streaming manner: "leave_types"
  """
  leave_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_types_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_types_bool_exp
  ): [leave_types!]!

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!

  """fetch data from the table: "leaves" using primary key columns"""
  leaves_by_pk(id: uuid!): leaves

  """
  fetch data from the table in a streaming manner: "leaves"
  """
  leaves_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leaves_stream_cursor_input]!

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """
  fetch data from the table: "locations"
  """
  locations(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """
  fetch aggregated fields from the table: "locations"
  """
  locations_aggregate(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): locations_aggregate!

  """fetch data from the table: "locations" using primary key columns"""
  locations_by_pk(id: uuid!): locations

  """
  fetch data from the table in a streaming manner: "locations"
  """
  locations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [locations_stream_cursor_input]!

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """An array relationship"""
  message_statuses(
    """distinct select on columns"""
    distinct_on: [message_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_statuses_order_by!]

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): [message_statuses!]!

  """An aggregate relationship"""
  message_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [message_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_statuses_order_by!]

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): message_statuses_aggregate!

  """
  fetch data from the table: "message_statuses" using primary key columns
  """
  message_statuses_by_pk(id: uuid!): message_statuses

  """
  fetch data from the table in a streaming manner: "message_statuses"
  """
  message_statuses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [message_statuses_stream_cursor_input]!

    """filter the rows returned"""
    where: message_statuses_bool_exp
  ): [message_statuses!]!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table in a streaming manner: "messages"
  """
  messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [messages_stream_cursor_input]!

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An array relationship"""
  positions(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """An aggregate relationship"""
  positions_aggregate(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): positions_aggregate!

  """fetch data from the table: "positions" using primary key columns"""
  positions_by_pk(id: uuid!): positions

  """
  fetch data from the table in a streaming manner: "positions"
  """
  positions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [positions_stream_cursor_input]!

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """
  fetch data from the table: "reports"
  """
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch aggregated fields from the table: "reports"
  """
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!

  """fetch data from the table: "reports" using primary key columns"""
  reports_by_pk(id: uuid!): reports

  """
  fetch data from the table in a streaming manner: "reports"
  """
  reports_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [reports_stream_cursor_input]!

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [roles_stream_cursor_input]!

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(id: uuid!): services

  """
  fetch data from the table in a streaming manner: "services"
  """
  services_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [services_stream_cursor_input]!

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """
  fetch data from the table: "shifts"
  """
  shifts(
    """distinct select on columns"""
    distinct_on: [shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shifts_order_by!]

    """filter the rows returned"""
    where: shifts_bool_exp
  ): [shifts!]!

  """
  fetch aggregated fields from the table: "shifts"
  """
  shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shifts_order_by!]

    """filter the rows returned"""
    where: shifts_bool_exp
  ): shifts_aggregate!

  """fetch data from the table: "shifts" using primary key columns"""
  shifts_by_pk(id: uuid!): shifts

  """
  fetch data from the table in a streaming manner: "shifts"
  """
  shifts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shifts_stream_cursor_input]!

    """filter the rows returned"""
    where: shifts_bool_exp
  ): [shifts!]!

  """
  fetch data from the table: "spatial_ref_sys"
  """
  spatial_ref_sys(
    """distinct select on columns"""
    distinct_on: [spatial_ref_sys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [spatial_ref_sys_order_by!]

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): [spatial_ref_sys!]!

  """
  fetch aggregated fields from the table: "spatial_ref_sys"
  """
  spatial_ref_sys_aggregate(
    """distinct select on columns"""
    distinct_on: [spatial_ref_sys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [spatial_ref_sys_order_by!]

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): spatial_ref_sys_aggregate!

  """fetch data from the table: "spatial_ref_sys" using primary key columns"""
  spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  """
  fetch data from the table in a streaming manner: "spatial_ref_sys"
  """
  spatial_ref_sys_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [spatial_ref_sys_stream_cursor_input]!

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): [spatial_ref_sys!]!

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(status: String!): status

  """
  fetch data from the table in a streaming manner: "status"
  """
  status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [status_stream_cursor_input]!

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch data from the table: "task_status"
  """
  task_status(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): [task_status!]!

  """
  fetch aggregated fields from the table: "task_status"
  """
  task_status_aggregate(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): task_status_aggregate!

  """fetch data from the table: "task_status" using primary key columns"""
  task_status_by_pk(id: uuid!): task_status

  """
  fetch data from the table in a streaming manner: "task_status"
  """
  task_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [task_status_stream_cursor_input]!

    """filter the rows returned"""
    where: task_status_bool_exp
  ): [task_status!]!

  """An array relationship"""
  tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """An aggregate relationship"""
  tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!

  """fetch data from the table: "tasks" using primary key columns"""
  tasks_by_pk(id: uuid!): tasks

  """
  fetch data from the table in a streaming manner: "tasks"
  """
  tasks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tasks_stream_cursor_input]!

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """
  fetch data from the table: "text_content"
  """
  text_content(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): [text_content!]!

  """
  fetch aggregated fields from the table: "text_content"
  """
  text_content_aggregate(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): text_content_aggregate!

  """fetch data from the table: "text_content" using primary key columns"""
  text_content_by_pk(id: uuid!): text_content

  """
  fetch data from the table in a streaming manner: "text_content"
  """
  text_content_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [text_content_stream_cursor_input]!

    """filter the rows returned"""
    where: text_content_bool_exp
  ): [text_content!]!

  """
  fetch data from the table: "topology.layer"
  """
  topology_layer(
    """distinct select on columns"""
    distinct_on: [topology_layer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_layer_order_by!]

    """filter the rows returned"""
    where: topology_layer_bool_exp
  ): [topology_layer!]!

  """
  fetch aggregated fields from the table: "topology.layer"
  """
  topology_layer_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_layer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_layer_order_by!]

    """filter the rows returned"""
    where: topology_layer_bool_exp
  ): topology_layer_aggregate!

  """fetch data from the table: "topology.layer" using primary key columns"""
  topology_layer_by_pk(layer_id: Int!, topology_id: Int!): topology_layer

  """
  fetch data from the table in a streaming manner: "topology.layer"
  """
  topology_layer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [topology_layer_stream_cursor_input]!

    """filter the rows returned"""
    where: topology_layer_bool_exp
  ): [topology_layer!]!

  """
  fetch data from the table: "topology.topology"
  """
  topology_topology(
    """distinct select on columns"""
    distinct_on: [topology_topology_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_topology_order_by!]

    """filter the rows returned"""
    where: topology_topology_bool_exp
  ): [topology_topology!]!

  """
  fetch aggregated fields from the table: "topology.topology"
  """
  topology_topology_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_topology_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_topology_order_by!]

    """filter the rows returned"""
    where: topology_topology_bool_exp
  ): topology_topology_aggregate!

  """
  fetch data from the table: "topology.topology" using primary key columns
  """
  topology_topology_by_pk(id: Int!): topology_topology

  """
  fetch data from the table in a streaming manner: "topology.topology"
  """
  topology_topology_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [topology_topology_stream_cursor_input]!

    """filter the rows returned"""
    where: topology_topology_bool_exp
  ): [topology_topology!]!

  """
  fetch data from the table: "translations"
  """
  translations(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): [translations!]!

  """
  fetch aggregated fields from the table: "translations"
  """
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): translations_aggregate!

  """fetch data from the table: "translations" using primary key columns"""
  translations_by_pk(id: uuid!): translations

  """
  fetch data from the table in a streaming manner: "translations"
  """
  translations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translations_stream_cursor_input]!

    """filter the rows returned"""
    where: translations_bool_exp
  ): [translations!]!

  """An array relationship"""
  typing_statuses(
    """distinct select on columns"""
    distinct_on: [typing_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [typing_statuses_order_by!]

    """filter the rows returned"""
    where: typing_statuses_bool_exp
  ): [typing_statuses!]!

  """An aggregate relationship"""
  typing_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [typing_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [typing_statuses_order_by!]

    """filter the rows returned"""
    where: typing_statuses_bool_exp
  ): typing_statuses_aggregate!

  """fetch data from the table: "typing_statuses" using primary key columns"""
  typing_statuses_by_pk(id: uuid!): typing_statuses

  """
  fetch data from the table in a streaming manner: "typing_statuses"
  """
  typing_statuses_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [typing_statuses_stream_cursor_input]!

    """filter the rows returned"""
    where: typing_statuses_bool_exp
  ): [typing_statuses!]!

  """
  fetch data from the table: "vehicles"
  """
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """
  fetch aggregated fields from the table: "vehicles"
  """
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!

  """fetch data from the table: "vehicles" using primary key columns"""
  vehicles_by_pk(id: uuid!): vehicles

  """
  fetch data from the table in a streaming manner: "vehicles"
  """
  vehicles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [vehicles_stream_cursor_input]!

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """
  fetch data from the table: "visit_status"
  """
  visit_status(
    """distinct select on columns"""
    distinct_on: [visit_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visit_status_order_by!]

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): [visit_status!]!

  """
  fetch aggregated fields from the table: "visit_status"
  """
  visit_status_aggregate(
    """distinct select on columns"""
    distinct_on: [visit_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visit_status_order_by!]

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): visit_status_aggregate!

  """fetch data from the table: "visit_status" using primary key columns"""
  visit_status_by_pk(status: String!): visit_status

  """
  fetch data from the table in a streaming manner: "visit_status"
  """
  visit_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [visit_status_stream_cursor_input]!

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): [visit_status!]!

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!

  """fetch data from the table: "visitors" using primary key columns"""
  visitors_by_pk(id: uuid!): visitors

  """
  fetch data from the table in a streaming manner: "visitors"
  """
  visitors_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [visitors_stream_cursor_input]!

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!

  """fetch data from the table: "visits" using primary key columns"""
  visits_by_pk(id: uuid!): visits

  """
  fetch data from the table in a streaming manner: "visits"
  """
  visits_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [visits_stream_cursor_input]!

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!
}

"""
columns and relationships of "task_status"
"""
type task_status {
  comment: String
  created_at: timestamptz

  """An object relationship"""
  employee: employees!
  id: uuid!
  status: taskstatusenum

  """An object relationship"""
  task: tasks!
  task_id: uuid!
  updated_at: timestamptz
  updated_by: uuid!
}

"""
aggregated selection of "task_status"
"""
type task_status_aggregate {
  aggregate: task_status_aggregate_fields
  nodes: [task_status!]!
}

input task_status_aggregate_bool_exp {
  count: task_status_aggregate_bool_exp_count
}

input task_status_aggregate_bool_exp_count {
  arguments: [task_status_select_column!]
  distinct: Boolean
  filter: task_status_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "task_status"
"""
type task_status_aggregate_fields {
  count(columns: [task_status_select_column!], distinct: Boolean): Int!
  max: task_status_max_fields
  min: task_status_min_fields
}

"""
order by aggregate values of table "task_status"
"""
input task_status_aggregate_order_by {
  count: order_by
  max: task_status_max_order_by
  min: task_status_min_order_by
}

"""
input type for inserting array relation for remote table "task_status"
"""
input task_status_arr_rel_insert_input {
  data: [task_status_insert_input!]!

  """upsert condition"""
  on_conflict: task_status_on_conflict
}

"""
Boolean expression to filter rows from the table "task_status". All fields are combined with a logical 'AND'.
"""
input task_status_bool_exp {
  _and: [task_status_bool_exp!]
  _not: task_status_bool_exp
  _or: [task_status_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  id: uuid_comparison_exp
  status: taskstatusenum_comparison_exp
  task: tasks_bool_exp
  task_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  updated_by: uuid_comparison_exp
}

"""
unique or primary key constraints on table "task_status"
"""
enum task_status_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  task_status_pkey
}

"""
input type for inserting data into table "task_status"
"""
input task_status_insert_input {
  comment: String
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  id: uuid
  status: taskstatusenum
  task: tasks_obj_rel_insert_input
  task_id: uuid
  updated_at: timestamptz
  updated_by: uuid
}

"""aggregate max on columns"""
type task_status_max_fields {
  comment: String
  created_at: timestamptz
  id: uuid
  status: taskstatusenum
  task_id: uuid
  updated_at: timestamptz
  updated_by: uuid
}

"""
order by max() on columns of table "task_status"
"""
input task_status_max_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  status: order_by
  task_id: order_by
  updated_at: order_by
  updated_by: order_by
}

"""aggregate min on columns"""
type task_status_min_fields {
  comment: String
  created_at: timestamptz
  id: uuid
  status: taskstatusenum
  task_id: uuid
  updated_at: timestamptz
  updated_by: uuid
}

"""
order by min() on columns of table "task_status"
"""
input task_status_min_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  status: order_by
  task_id: order_by
  updated_at: order_by
  updated_by: order_by
}

"""
response of any mutation on the table "task_status"
"""
type task_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [task_status!]!
}

"""
on_conflict condition type for table "task_status"
"""
input task_status_on_conflict {
  constraint: task_status_constraint!
  update_columns: [task_status_update_column!]! = []
  where: task_status_bool_exp
}

"""Ordering options when selecting data from "task_status"."""
input task_status_order_by {
  comment: order_by
  created_at: order_by
  employee: employees_order_by
  id: order_by
  status: order_by
  task: tasks_order_by
  task_id: order_by
  updated_at: order_by
  updated_by: order_by
}

"""primary key columns input for table: task_status"""
input task_status_pk_columns_input {
  id: uuid!
}

"""
select columns of table "task_status"
"""
enum task_status_select_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  status

  """column name"""
  task_id

  """column name"""
  updated_at

  """column name"""
  updated_by
}

"""
input type for updating data in table "task_status"
"""
input task_status_set_input {
  comment: String
  created_at: timestamptz
  id: uuid
  status: taskstatusenum
  task_id: uuid
  updated_at: timestamptz
  updated_by: uuid
}

"""
Streaming cursor of the table "task_status"
"""
input task_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: task_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input task_status_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  id: uuid
  status: taskstatusenum
  task_id: uuid
  updated_at: timestamptz
  updated_by: uuid
}

"""
update columns of table "task_status"
"""
enum task_status_update_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  status

  """column name"""
  task_id

  """column name"""
  updated_at

  """column name"""
  updated_by
}

input task_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: task_status_set_input

  """filter the rows which have to be updated"""
  where: task_status_bool_exp!
}

type TaskCompletionPercentage {
  percentage: Float!
}

"""
columns and relationships of "tasks"
"""
type tasks {
  assigned_by: uuid!
  assigned_to: uuid!
  created_at: timestamptz
  description: String
  due_date: date

  """An object relationship"""
  employee: employees!

  """An object relationship"""
  employeeByAssignedTo: employees!

  """An object relationship"""
  event: events!
  event_id: uuid!
  id: uuid!

  """An array relationship"""
  task_statuses(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): [task_status!]!

  """An aggregate relationship"""
  task_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [task_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): task_status_aggregate!
  title: String!
  updated_at: timestamptz
}

"""
aggregated selection of "tasks"
"""
type tasks_aggregate {
  aggregate: tasks_aggregate_fields
  nodes: [tasks!]!
}

input tasks_aggregate_bool_exp {
  count: tasks_aggregate_bool_exp_count
}

input tasks_aggregate_bool_exp_count {
  arguments: [tasks_select_column!]
  distinct: Boolean
  filter: tasks_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tasks"
"""
type tasks_aggregate_fields {
  count(columns: [tasks_select_column!], distinct: Boolean): Int!
  max: tasks_max_fields
  min: tasks_min_fields
}

"""
order by aggregate values of table "tasks"
"""
input tasks_aggregate_order_by {
  count: order_by
  max: tasks_max_order_by
  min: tasks_min_order_by
}

"""
input type for inserting array relation for remote table "tasks"
"""
input tasks_arr_rel_insert_input {
  data: [tasks_insert_input!]!

  """upsert condition"""
  on_conflict: tasks_on_conflict
}

"""
Boolean expression to filter rows from the table "tasks". All fields are combined with a logical 'AND'.
"""
input tasks_bool_exp {
  _and: [tasks_bool_exp!]
  _not: tasks_bool_exp
  _or: [tasks_bool_exp!]
  assigned_by: uuid_comparison_exp
  assigned_to: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  due_date: date_comparison_exp
  employee: employees_bool_exp
  employeeByAssignedTo: employees_bool_exp
  event: events_bool_exp
  event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  task_statuses: task_status_bool_exp
  task_statuses_aggregate: task_status_aggregate_bool_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tasks"
"""
enum tasks_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tasks_pkey
}

"""
input type for inserting data into table "tasks"
"""
input tasks_insert_input {
  assigned_by: uuid
  assigned_to: uuid
  created_at: timestamptz
  description: String
  due_date: date
  employee: employees_obj_rel_insert_input
  employeeByAssignedTo: employees_obj_rel_insert_input
  event: events_obj_rel_insert_input
  event_id: uuid
  id: uuid
  task_statuses: task_status_arr_rel_insert_input
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type tasks_max_fields {
  assigned_by: uuid
  assigned_to: uuid
  created_at: timestamptz
  description: String
  due_date: date
  event_id: uuid
  id: uuid
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "tasks"
"""
input tasks_max_order_by {
  assigned_by: order_by
  assigned_to: order_by
  created_at: order_by
  description: order_by
  due_date: order_by
  event_id: order_by
  id: order_by
  title: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type tasks_min_fields {
  assigned_by: uuid
  assigned_to: uuid
  created_at: timestamptz
  description: String
  due_date: date
  event_id: uuid
  id: uuid
  title: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "tasks"
"""
input tasks_min_order_by {
  assigned_by: order_by
  assigned_to: order_by
  created_at: order_by
  description: order_by
  due_date: order_by
  event_id: order_by
  id: order_by
  title: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "tasks"
"""
type tasks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tasks!]!
}

"""
input type for inserting object relation for remote table "tasks"
"""
input tasks_obj_rel_insert_input {
  data: tasks_insert_input!

  """upsert condition"""
  on_conflict: tasks_on_conflict
}

"""
on_conflict condition type for table "tasks"
"""
input tasks_on_conflict {
  constraint: tasks_constraint!
  update_columns: [tasks_update_column!]! = []
  where: tasks_bool_exp
}

"""Ordering options when selecting data from "tasks"."""
input tasks_order_by {
  assigned_by: order_by
  assigned_to: order_by
  created_at: order_by
  description: order_by
  due_date: order_by
  employee: employees_order_by
  employeeByAssignedTo: employees_order_by
  event: events_order_by
  event_id: order_by
  id: order_by
  task_statuses_aggregate: task_status_aggregate_order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: tasks"""
input tasks_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tasks"
"""
enum tasks_select_column {
  """column name"""
  assigned_by

  """column name"""
  assigned_to

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  due_date

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "tasks"
"""
input tasks_set_input {
  assigned_by: uuid
  assigned_to: uuid
  created_at: timestamptz
  description: String
  due_date: date
  event_id: uuid
  id: uuid
  title: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "tasks"
"""
input tasks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tasks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tasks_stream_cursor_value_input {
  assigned_by: uuid
  assigned_to: uuid
  created_at: timestamptz
  description: String
  due_date: date
  event_id: uuid
  id: uuid
  title: String
  updated_at: timestamptz
}

"""
update columns of table "tasks"
"""
enum tasks_update_column {
  """column name"""
  assigned_by

  """column name"""
  assigned_to

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  due_date

  """column name"""
  event_id

  """column name"""
  id

  """column name"""
  title

  """column name"""
  updated_at
}

input tasks_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tasks_set_input

  """filter the rows which have to be updated"""
  where: tasks_bool_exp!
}

scalar taskstatusenum

"""
Boolean expression to compare columns of type "taskstatusenum". All fields are combined with logical 'AND'.
"""
input taskstatusenum_comparison_exp {
  _eq: taskstatusenum
  _gt: taskstatusenum
  _gte: taskstatusenum
  _in: [taskstatusenum!]
  _is_null: Boolean
  _lt: taskstatusenum
  _lte: taskstatusenum
  _neq: taskstatusenum
  _nin: [taskstatusenum!]
}

"""
columns and relationships of "text_content"
"""
type text_content {
  """An array relationship"""
  agencies(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An aggregate relationship"""
  agencies_aggregate(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): agencies_aggregate!

  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An aggregate relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!
  content: String!
  created_at: timestamptz

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!
  id: uuid!

  """An array relationship"""
  positions(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """An aggregate relationship"""
  positions_aggregate(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): positions_aggregate!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """An object relationship"""
  translation: translations
  translations: uuid

  """An array relationship"""
  translationsByContent(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): [translations!]!

  """An aggregate relationship"""
  translationsByContent_aggregate(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): translations_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "text_content"
"""
type text_content_aggregate {
  aggregate: text_content_aggregate_fields
  nodes: [text_content!]!
}

input text_content_aggregate_bool_exp {
  count: text_content_aggregate_bool_exp_count
}

input text_content_aggregate_bool_exp_count {
  arguments: [text_content_select_column!]
  distinct: Boolean
  filter: text_content_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "text_content"
"""
type text_content_aggregate_fields {
  count(columns: [text_content_select_column!], distinct: Boolean): Int!
  max: text_content_max_fields
  min: text_content_min_fields
}

"""
order by aggregate values of table "text_content"
"""
input text_content_aggregate_order_by {
  count: order_by
  max: text_content_max_order_by
  min: text_content_min_order_by
}

"""
input type for inserting array relation for remote table "text_content"
"""
input text_content_arr_rel_insert_input {
  data: [text_content_insert_input!]!

  """upsert condition"""
  on_conflict: text_content_on_conflict
}

"""
Boolean expression to filter rows from the table "text_content". All fields are combined with a logical 'AND'.
"""
input text_content_bool_exp {
  _and: [text_content_bool_exp!]
  _not: text_content_bool_exp
  _or: [text_content_bool_exp!]
  agencies: agencies_bool_exp
  agencies_aggregate: agencies_aggregate_bool_exp
  companies: companies_bool_exp
  companies_aggregate: companies_aggregate_bool_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  id: uuid_comparison_exp
  positions: positions_bool_exp
  positions_aggregate: positions_aggregate_bool_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  translation: translations_bool_exp
  translations: uuid_comparison_exp
  translationsByContent: translations_bool_exp
  translationsByContent_aggregate: translations_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "text_content"
"""
enum text_content_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  text_content_pkey
}

"""
input type for inserting data into table "text_content"
"""
input text_content_insert_input {
  agencies: agencies_arr_rel_insert_input
  companies: companies_arr_rel_insert_input
  content: String
  created_at: timestamptz
  departments: departments_arr_rel_insert_input
  id: uuid
  positions: positions_arr_rel_insert_input
  services: services_arr_rel_insert_input
  translation: translations_obj_rel_insert_input
  translations: uuid
  translationsByContent: translations_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type text_content_max_fields {
  content: String
  created_at: timestamptz
  id: uuid
  translations: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "text_content"
"""
input text_content_max_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  translations: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type text_content_min_fields {
  content: String
  created_at: timestamptz
  id: uuid
  translations: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "text_content"
"""
input text_content_min_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  translations: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "text_content"
"""
type text_content_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [text_content!]!
}

"""
input type for inserting object relation for remote table "text_content"
"""
input text_content_obj_rel_insert_input {
  data: text_content_insert_input!

  """upsert condition"""
  on_conflict: text_content_on_conflict
}

"""
on_conflict condition type for table "text_content"
"""
input text_content_on_conflict {
  constraint: text_content_constraint!
  update_columns: [text_content_update_column!]! = []
  where: text_content_bool_exp
}

"""Ordering options when selecting data from "text_content"."""
input text_content_order_by {
  agencies_aggregate: agencies_aggregate_order_by
  companies_aggregate: companies_aggregate_order_by
  content: order_by
  created_at: order_by
  departments_aggregate: departments_aggregate_order_by
  id: order_by
  positions_aggregate: positions_aggregate_order_by
  services_aggregate: services_aggregate_order_by
  translation: translations_order_by
  translations: order_by
  translationsByContent_aggregate: translations_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: text_content"""
input text_content_pk_columns_input {
  id: uuid!
}

"""
select columns of table "text_content"
"""
enum text_content_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  translations

  """column name"""
  updated_at
}

"""
input type for updating data in table "text_content"
"""
input text_content_set_input {
  content: String
  created_at: timestamptz
  id: uuid
  translations: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "text_content"
"""
input text_content_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: text_content_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input text_content_stream_cursor_value_input {
  content: String
  created_at: timestamptz
  id: uuid
  translations: uuid
  updated_at: timestamptz
}

"""
update columns of table "text_content"
"""
enum text_content_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  translations

  """column name"""
  updated_at
}

input text_content_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: text_content_set_input

  """filter the rows which have to be updated"""
  where: text_content_bool_exp!
}

scalar time

"""
Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'.
"""
input time_comparison_exp {
  _eq: time
  _gt: time
  _gte: time
  _in: [time!]
  _is_null: Boolean
  _lt: time
  _lte: time
  _neq: time
  _nin: [time!]
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "topology.layer"
"""
type topology_layer {
  child_id: Int
  feature_column: String!
  feature_type: Int!
  layer_id: Int!
  level: Int!
  schema_name: String!
  table_name: String!

  """An object relationship"""
  topology: topology_topology!
  topology_id: Int!
}

"""
aggregated selection of "topology.layer"
"""
type topology_layer_aggregate {
  aggregate: topology_layer_aggregate_fields
  nodes: [topology_layer!]!
}

input topology_layer_aggregate_bool_exp {
  count: topology_layer_aggregate_bool_exp_count
}

input topology_layer_aggregate_bool_exp_count {
  arguments: [topology_layer_select_column!]
  distinct: Boolean
  filter: topology_layer_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "topology.layer"
"""
type topology_layer_aggregate_fields {
  avg: topology_layer_avg_fields
  count(columns: [topology_layer_select_column!], distinct: Boolean): Int!
  max: topology_layer_max_fields
  min: topology_layer_min_fields
  stddev: topology_layer_stddev_fields
  stddev_pop: topology_layer_stddev_pop_fields
  stddev_samp: topology_layer_stddev_samp_fields
  sum: topology_layer_sum_fields
  var_pop: topology_layer_var_pop_fields
  var_samp: topology_layer_var_samp_fields
  variance: topology_layer_variance_fields
}

"""
order by aggregate values of table "topology.layer"
"""
input topology_layer_aggregate_order_by {
  avg: topology_layer_avg_order_by
  count: order_by
  max: topology_layer_max_order_by
  min: topology_layer_min_order_by
  stddev: topology_layer_stddev_order_by
  stddev_pop: topology_layer_stddev_pop_order_by
  stddev_samp: topology_layer_stddev_samp_order_by
  sum: topology_layer_sum_order_by
  var_pop: topology_layer_var_pop_order_by
  var_samp: topology_layer_var_samp_order_by
  variance: topology_layer_variance_order_by
}

"""
input type for inserting array relation for remote table "topology.layer"
"""
input topology_layer_arr_rel_insert_input {
  data: [topology_layer_insert_input!]!

  """upsert condition"""
  on_conflict: topology_layer_on_conflict
}

"""aggregate avg on columns"""
type topology_layer_avg_fields {
  child_id: Float
  feature_type: Float
  layer_id: Float
  level: Float
  topology_id: Float
}

"""
order by avg() on columns of table "topology.layer"
"""
input topology_layer_avg_order_by {
  child_id: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  topology_id: order_by
}

"""
Boolean expression to filter rows from the table "topology.layer". All fields are combined with a logical 'AND'.
"""
input topology_layer_bool_exp {
  _and: [topology_layer_bool_exp!]
  _not: topology_layer_bool_exp
  _or: [topology_layer_bool_exp!]
  child_id: Int_comparison_exp
  feature_column: String_comparison_exp
  feature_type: Int_comparison_exp
  layer_id: Int_comparison_exp
  level: Int_comparison_exp
  schema_name: String_comparison_exp
  table_name: String_comparison_exp
  topology: topology_topology_bool_exp
  topology_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "topology.layer"
"""
enum topology_layer_constraint {
  """
  unique or primary key constraint on columns "topology_id", "layer_id"
  """
  layer_pkey

  """
  unique or primary key constraint on columns "feature_column", "table_name", "schema_name"
  """
  layer_schema_name_table_name_feature_column_key
}

"""
input type for incrementing numeric columns in table "topology.layer"
"""
input topology_layer_inc_input {
  child_id: Int
  feature_type: Int
  layer_id: Int
  level: Int
  topology_id: Int
}

"""
input type for inserting data into table "topology.layer"
"""
input topology_layer_insert_input {
  child_id: Int
  feature_column: String
  feature_type: Int
  layer_id: Int
  level: Int
  schema_name: String
  table_name: String
  topology: topology_topology_obj_rel_insert_input
  topology_id: Int
}

"""aggregate max on columns"""
type topology_layer_max_fields {
  child_id: Int
  feature_column: String
  feature_type: Int
  layer_id: Int
  level: Int
  schema_name: String
  table_name: String
  topology_id: Int
}

"""
order by max() on columns of table "topology.layer"
"""
input topology_layer_max_order_by {
  child_id: order_by
  feature_column: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  schema_name: order_by
  table_name: order_by
  topology_id: order_by
}

"""aggregate min on columns"""
type topology_layer_min_fields {
  child_id: Int
  feature_column: String
  feature_type: Int
  layer_id: Int
  level: Int
  schema_name: String
  table_name: String
  topology_id: Int
}

"""
order by min() on columns of table "topology.layer"
"""
input topology_layer_min_order_by {
  child_id: order_by
  feature_column: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  schema_name: order_by
  table_name: order_by
  topology_id: order_by
}

"""
response of any mutation on the table "topology.layer"
"""
type topology_layer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [topology_layer!]!
}

"""
on_conflict condition type for table "topology.layer"
"""
input topology_layer_on_conflict {
  constraint: topology_layer_constraint!
  update_columns: [topology_layer_update_column!]! = []
  where: topology_layer_bool_exp
}

"""Ordering options when selecting data from "topology.layer"."""
input topology_layer_order_by {
  child_id: order_by
  feature_column: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  schema_name: order_by
  table_name: order_by
  topology: topology_topology_order_by
  topology_id: order_by
}

"""primary key columns input for table: topology.layer"""
input topology_layer_pk_columns_input {
  layer_id: Int!
  topology_id: Int!
}

"""
select columns of table "topology.layer"
"""
enum topology_layer_select_column {
  """column name"""
  child_id

  """column name"""
  feature_column

  """column name"""
  feature_type

  """column name"""
  layer_id

  """column name"""
  level

  """column name"""
  schema_name

  """column name"""
  table_name

  """column name"""
  topology_id
}

"""
input type for updating data in table "topology.layer"
"""
input topology_layer_set_input {
  child_id: Int
  feature_column: String
  feature_type: Int
  layer_id: Int
  level: Int
  schema_name: String
  table_name: String
  topology_id: Int
}

"""aggregate stddev on columns"""
type topology_layer_stddev_fields {
  child_id: Float
  feature_type: Float
  layer_id: Float
  level: Float
  topology_id: Float
}

"""
order by stddev() on columns of table "topology.layer"
"""
input topology_layer_stddev_order_by {
  child_id: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  topology_id: order_by
}

"""aggregate stddev_pop on columns"""
type topology_layer_stddev_pop_fields {
  child_id: Float
  feature_type: Float
  layer_id: Float
  level: Float
  topology_id: Float
}

"""
order by stddev_pop() on columns of table "topology.layer"
"""
input topology_layer_stddev_pop_order_by {
  child_id: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  topology_id: order_by
}

"""aggregate stddev_samp on columns"""
type topology_layer_stddev_samp_fields {
  child_id: Float
  feature_type: Float
  layer_id: Float
  level: Float
  topology_id: Float
}

"""
order by stddev_samp() on columns of table "topology.layer"
"""
input topology_layer_stddev_samp_order_by {
  child_id: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  topology_id: order_by
}

"""
Streaming cursor of the table "topology_layer"
"""
input topology_layer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: topology_layer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input topology_layer_stream_cursor_value_input {
  child_id: Int
  feature_column: String
  feature_type: Int
  layer_id: Int
  level: Int
  schema_name: String
  table_name: String
  topology_id: Int
}

"""aggregate sum on columns"""
type topology_layer_sum_fields {
  child_id: Int
  feature_type: Int
  layer_id: Int
  level: Int
  topology_id: Int
}

"""
order by sum() on columns of table "topology.layer"
"""
input topology_layer_sum_order_by {
  child_id: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  topology_id: order_by
}

"""
update columns of table "topology.layer"
"""
enum topology_layer_update_column {
  """column name"""
  child_id

  """column name"""
  feature_column

  """column name"""
  feature_type

  """column name"""
  layer_id

  """column name"""
  level

  """column name"""
  schema_name

  """column name"""
  table_name

  """column name"""
  topology_id
}

input topology_layer_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: topology_layer_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: topology_layer_set_input

  """filter the rows which have to be updated"""
  where: topology_layer_bool_exp!
}

"""aggregate var_pop on columns"""
type topology_layer_var_pop_fields {
  child_id: Float
  feature_type: Float
  layer_id: Float
  level: Float
  topology_id: Float
}

"""
order by var_pop() on columns of table "topology.layer"
"""
input topology_layer_var_pop_order_by {
  child_id: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  topology_id: order_by
}

"""aggregate var_samp on columns"""
type topology_layer_var_samp_fields {
  child_id: Float
  feature_type: Float
  layer_id: Float
  level: Float
  topology_id: Float
}

"""
order by var_samp() on columns of table "topology.layer"
"""
input topology_layer_var_samp_order_by {
  child_id: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  topology_id: order_by
}

"""aggregate variance on columns"""
type topology_layer_variance_fields {
  child_id: Float
  feature_type: Float
  layer_id: Float
  level: Float
  topology_id: Float
}

"""
order by variance() on columns of table "topology.layer"
"""
input topology_layer_variance_order_by {
  child_id: order_by
  feature_type: order_by
  layer_id: order_by
  level: order_by
  topology_id: order_by
}

"""
columns and relationships of "topology.topology"
"""
type topology_topology {
  hasz: Boolean!
  id: Int!

  """An array relationship"""
  layers(
    """distinct select on columns"""
    distinct_on: [topology_layer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_layer_order_by!]

    """filter the rows returned"""
    where: topology_layer_bool_exp
  ): [topology_layer!]!

  """An aggregate relationship"""
  layers_aggregate(
    """distinct select on columns"""
    distinct_on: [topology_layer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topology_layer_order_by!]

    """filter the rows returned"""
    where: topology_layer_bool_exp
  ): topology_layer_aggregate!
  name: String!
  precision: float8!
  srid: Int!
}

"""
aggregated selection of "topology.topology"
"""
type topology_topology_aggregate {
  aggregate: topology_topology_aggregate_fields
  nodes: [topology_topology!]!
}

"""
aggregate fields of "topology.topology"
"""
type topology_topology_aggregate_fields {
  avg: topology_topology_avg_fields
  count(columns: [topology_topology_select_column!], distinct: Boolean): Int!
  max: topology_topology_max_fields
  min: topology_topology_min_fields
  stddev: topology_topology_stddev_fields
  stddev_pop: topology_topology_stddev_pop_fields
  stddev_samp: topology_topology_stddev_samp_fields
  sum: topology_topology_sum_fields
  var_pop: topology_topology_var_pop_fields
  var_samp: topology_topology_var_samp_fields
  variance: topology_topology_variance_fields
}

"""aggregate avg on columns"""
type topology_topology_avg_fields {
  id: Float
  precision: Float
  srid: Float
}

"""
Boolean expression to filter rows from the table "topology.topology". All fields are combined with a logical 'AND'.
"""
input topology_topology_bool_exp {
  _and: [topology_topology_bool_exp!]
  _not: topology_topology_bool_exp
  _or: [topology_topology_bool_exp!]
  hasz: Boolean_comparison_exp
  id: Int_comparison_exp
  layers: topology_layer_bool_exp
  layers_aggregate: topology_layer_aggregate_bool_exp
  name: String_comparison_exp
  precision: float8_comparison_exp
  srid: Int_comparison_exp
}

"""
unique or primary key constraints on table "topology.topology"
"""
enum topology_topology_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  topology_name_key

  """
  unique or primary key constraint on columns "id"
  """
  topology_pkey
}

"""
input type for incrementing numeric columns in table "topology.topology"
"""
input topology_topology_inc_input {
  id: Int
  precision: float8
  srid: Int
}

"""
input type for inserting data into table "topology.topology"
"""
input topology_topology_insert_input {
  hasz: Boolean
  id: Int
  layers: topology_layer_arr_rel_insert_input
  name: String
  precision: float8
  srid: Int
}

"""aggregate max on columns"""
type topology_topology_max_fields {
  id: Int
  name: String
  precision: float8
  srid: Int
}

"""aggregate min on columns"""
type topology_topology_min_fields {
  id: Int
  name: String
  precision: float8
  srid: Int
}

"""
response of any mutation on the table "topology.topology"
"""
type topology_topology_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [topology_topology!]!
}

"""
input type for inserting object relation for remote table "topology.topology"
"""
input topology_topology_obj_rel_insert_input {
  data: topology_topology_insert_input!

  """upsert condition"""
  on_conflict: topology_topology_on_conflict
}

"""
on_conflict condition type for table "topology.topology"
"""
input topology_topology_on_conflict {
  constraint: topology_topology_constraint!
  update_columns: [topology_topology_update_column!]! = []
  where: topology_topology_bool_exp
}

"""Ordering options when selecting data from "topology.topology"."""
input topology_topology_order_by {
  hasz: order_by
  id: order_by
  layers_aggregate: topology_layer_aggregate_order_by
  name: order_by
  precision: order_by
  srid: order_by
}

"""primary key columns input for table: topology.topology"""
input topology_topology_pk_columns_input {
  id: Int!
}

"""
select columns of table "topology.topology"
"""
enum topology_topology_select_column {
  """column name"""
  hasz

  """column name"""
  id

  """column name"""
  name

  """column name"""
  precision

  """column name"""
  srid
}

"""
input type for updating data in table "topology.topology"
"""
input topology_topology_set_input {
  hasz: Boolean
  id: Int
  name: String
  precision: float8
  srid: Int
}

"""aggregate stddev on columns"""
type topology_topology_stddev_fields {
  id: Float
  precision: Float
  srid: Float
}

"""aggregate stddev_pop on columns"""
type topology_topology_stddev_pop_fields {
  id: Float
  precision: Float
  srid: Float
}

"""aggregate stddev_samp on columns"""
type topology_topology_stddev_samp_fields {
  id: Float
  precision: Float
  srid: Float
}

"""
Streaming cursor of the table "topology_topology"
"""
input topology_topology_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: topology_topology_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input topology_topology_stream_cursor_value_input {
  hasz: Boolean
  id: Int
  name: String
  precision: float8
  srid: Int
}

"""aggregate sum on columns"""
type topology_topology_sum_fields {
  id: Int
  precision: float8
  srid: Int
}

"""
update columns of table "topology.topology"
"""
enum topology_topology_update_column {
  """column name"""
  hasz

  """column name"""
  id

  """column name"""
  name

  """column name"""
  precision

  """column name"""
  srid
}

input topology_topology_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: topology_topology_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: topology_topology_set_input

  """filter the rows which have to be updated"""
  where: topology_topology_bool_exp!
}

"""aggregate var_pop on columns"""
type topology_topology_var_pop_fields {
  id: Float
  precision: Float
  srid: Float
}

"""aggregate var_samp on columns"""
type topology_topology_var_samp_fields {
  id: Float
  precision: Float
  srid: Float
}

"""aggregate variance on columns"""
type topology_topology_variance_fields {
  id: Float
  precision: Float
  srid: Float
}

"""
columns and relationships of "translations"
"""
type translations {
  content: uuid
  created_at: timestamptz
  id: uuid!
  language_iso_code: String

  """An object relationship"""
  text_content: text_content

  """An array relationship"""
  text_contents(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): [text_content!]!

  """An aggregate relationship"""
  text_contents_aggregate(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): text_content_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "translations"
"""
type translations_aggregate {
  aggregate: translations_aggregate_fields
  nodes: [translations!]!
}

input translations_aggregate_bool_exp {
  count: translations_aggregate_bool_exp_count
}

input translations_aggregate_bool_exp_count {
  arguments: [translations_select_column!]
  distinct: Boolean
  filter: translations_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "translations"
"""
type translations_aggregate_fields {
  count(columns: [translations_select_column!], distinct: Boolean): Int!
  max: translations_max_fields
  min: translations_min_fields
}

"""
order by aggregate values of table "translations"
"""
input translations_aggregate_order_by {
  count: order_by
  max: translations_max_order_by
  min: translations_min_order_by
}

"""
input type for inserting array relation for remote table "translations"
"""
input translations_arr_rel_insert_input {
  data: [translations_insert_input!]!

  """upsert condition"""
  on_conflict: translations_on_conflict
}

"""
Boolean expression to filter rows from the table "translations". All fields are combined with a logical 'AND'.
"""
input translations_bool_exp {
  _and: [translations_bool_exp!]
  _not: translations_bool_exp
  _or: [translations_bool_exp!]
  content: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  language_iso_code: String_comparison_exp
  text_content: text_content_bool_exp
  text_contents: text_content_bool_exp
  text_contents_aggregate: text_content_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "translations"
"""
enum translations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  translations_pkey
}

"""
input type for inserting data into table "translations"
"""
input translations_insert_input {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  text_content: text_content_obj_rel_insert_input
  text_contents: text_content_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type translations_max_fields {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "translations"
"""
input translations_max_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  language_iso_code: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type translations_min_fields {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "translations"
"""
input translations_min_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  language_iso_code: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "translations"
"""
type translations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translations!]!
}

"""
input type for inserting object relation for remote table "translations"
"""
input translations_obj_rel_insert_input {
  data: translations_insert_input!

  """upsert condition"""
  on_conflict: translations_on_conflict
}

"""
on_conflict condition type for table "translations"
"""
input translations_on_conflict {
  constraint: translations_constraint!
  update_columns: [translations_update_column!]! = []
  where: translations_bool_exp
}

"""Ordering options when selecting data from "translations"."""
input translations_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  language_iso_code: order_by
  text_content: text_content_order_by
  text_contents_aggregate: text_content_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: translations"""
input translations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "translations"
"""
enum translations_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  language_iso_code

  """column name"""
  updated_at
}

"""
input type for updating data in table "translations"
"""
input translations_set_input {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "translations"
"""
input translations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translations_stream_cursor_value_input {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  updated_at: timestamptz
}

"""
update columns of table "translations"
"""
enum translations_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  language_iso_code

  """column name"""
  updated_at
}

input translations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: translations_set_input

  """filter the rows which have to be updated"""
  where: translations_bool_exp!
}

"""
columns and relationships of "typing_statuses"
"""
type typing_statuses {
  """An object relationship"""
  employee: employees!
  employee_id: uuid!
  id: uuid!
  is_typing: Boolean
}

"""
aggregated selection of "typing_statuses"
"""
type typing_statuses_aggregate {
  aggregate: typing_statuses_aggregate_fields
  nodes: [typing_statuses!]!
}

input typing_statuses_aggregate_bool_exp {
  bool_and: typing_statuses_aggregate_bool_exp_bool_and
  bool_or: typing_statuses_aggregate_bool_exp_bool_or
  count: typing_statuses_aggregate_bool_exp_count
}

input typing_statuses_aggregate_bool_exp_bool_and {
  arguments: typing_statuses_select_column_typing_statuses_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: typing_statuses_bool_exp
  predicate: Boolean_comparison_exp!
}

input typing_statuses_aggregate_bool_exp_bool_or {
  arguments: typing_statuses_select_column_typing_statuses_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: typing_statuses_bool_exp
  predicate: Boolean_comparison_exp!
}

input typing_statuses_aggregate_bool_exp_count {
  arguments: [typing_statuses_select_column!]
  distinct: Boolean
  filter: typing_statuses_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "typing_statuses"
"""
type typing_statuses_aggregate_fields {
  count(columns: [typing_statuses_select_column!], distinct: Boolean): Int!
  max: typing_statuses_max_fields
  min: typing_statuses_min_fields
}

"""
order by aggregate values of table "typing_statuses"
"""
input typing_statuses_aggregate_order_by {
  count: order_by
  max: typing_statuses_max_order_by
  min: typing_statuses_min_order_by
}

"""
input type for inserting array relation for remote table "typing_statuses"
"""
input typing_statuses_arr_rel_insert_input {
  data: [typing_statuses_insert_input!]!

  """upsert condition"""
  on_conflict: typing_statuses_on_conflict
}

"""
Boolean expression to filter rows from the table "typing_statuses". All fields are combined with a logical 'AND'.
"""
input typing_statuses_bool_exp {
  _and: [typing_statuses_bool_exp!]
  _not: typing_statuses_bool_exp
  _or: [typing_statuses_bool_exp!]
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_typing: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "typing_statuses"
"""
enum typing_statuses_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  typing_statuses_pkey
}

"""
input type for inserting data into table "typing_statuses"
"""
input typing_statuses_insert_input {
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  is_typing: Boolean
}

"""aggregate max on columns"""
type typing_statuses_max_fields {
  employee_id: uuid
  id: uuid
}

"""
order by max() on columns of table "typing_statuses"
"""
input typing_statuses_max_order_by {
  employee_id: order_by
  id: order_by
}

"""aggregate min on columns"""
type typing_statuses_min_fields {
  employee_id: uuid
  id: uuid
}

"""
order by min() on columns of table "typing_statuses"
"""
input typing_statuses_min_order_by {
  employee_id: order_by
  id: order_by
}

"""
response of any mutation on the table "typing_statuses"
"""
type typing_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [typing_statuses!]!
}

"""
on_conflict condition type for table "typing_statuses"
"""
input typing_statuses_on_conflict {
  constraint: typing_statuses_constraint!
  update_columns: [typing_statuses_update_column!]! = []
  where: typing_statuses_bool_exp
}

"""Ordering options when selecting data from "typing_statuses"."""
input typing_statuses_order_by {
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  is_typing: order_by
}

"""primary key columns input for table: typing_statuses"""
input typing_statuses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "typing_statuses"
"""
enum typing_statuses_select_column {
  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  is_typing
}

"""
select "typing_statuses_aggregate_bool_exp_bool_and_arguments_columns" columns of table "typing_statuses"
"""
enum typing_statuses_select_column_typing_statuses_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_typing
}

"""
select "typing_statuses_aggregate_bool_exp_bool_or_arguments_columns" columns of table "typing_statuses"
"""
enum typing_statuses_select_column_typing_statuses_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_typing
}

"""
input type for updating data in table "typing_statuses"
"""
input typing_statuses_set_input {
  employee_id: uuid
  id: uuid
  is_typing: Boolean
}

"""
Streaming cursor of the table "typing_statuses"
"""
input typing_statuses_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: typing_statuses_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input typing_statuses_stream_cursor_value_input {
  employee_id: uuid
  id: uuid
  is_typing: Boolean
}

"""
update columns of table "typing_statuses"
"""
enum typing_statuses_update_column {
  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  is_typing
}

input typing_statuses_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: typing_statuses_set_input

  """filter the rows which have to be updated"""
  where: typing_statuses_bool_exp!
}

input UpdateEmployeeInput {
  address: String = null
  firstname: String = null
  id: UUID!
  lastname: String = null
  phoneNumber: String = null
}

input UpdatePasswordInputType {
  currentPassword: String!
  newPassword: String!
  phoneNumber: String!
}

type UpdatePasswordOutputType {
  success: String!
}

scalar uuid

scalar UUID

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "vehicles"
"""
type vehicles {
  brand: String
  color: String
  created_at: timestamptz
  flagged: Boolean
  id: uuid!
  license: String
  make: String
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "vehicles"
"""
type vehicles_aggregate {
  aggregate: vehicles_aggregate_fields
  nodes: [vehicles!]!
}

"""
aggregate fields of "vehicles"
"""
type vehicles_aggregate_fields {
  count(columns: [vehicles_select_column!], distinct: Boolean): Int!
  max: vehicles_max_fields
  min: vehicles_min_fields
}

"""
Boolean expression to filter rows from the table "vehicles". All fields are combined with a logical 'AND'.
"""
input vehicles_bool_exp {
  _and: [vehicles_bool_exp!]
  _not: vehicles_bool_exp
  _or: [vehicles_bool_exp!]
  brand: String_comparison_exp
  color: String_comparison_exp
  created_at: timestamptz_comparison_exp
  flagged: Boolean_comparison_exp
  id: uuid_comparison_exp
  license: String_comparison_exp
  make: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "vehicles"
"""
enum vehicles_constraint {
  """
  unique or primary key constraint on columns "license"
  """
  vehicles_license_key

  """
  unique or primary key constraint on columns "id"
  """
  vehicles_pkey
}

"""
input type for inserting data into table "vehicles"
"""
input vehicles_insert_input {
  brand: String
  color: String
  created_at: timestamptz
  flagged: Boolean
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type vehicles_max_fields {
  brand: String
  color: String
  created_at: timestamptz
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type vehicles_min_fields {
  brand: String
  color: String
  created_at: timestamptz
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "vehicles"
"""
type vehicles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [vehicles!]!
}

"""
input type for inserting object relation for remote table "vehicles"
"""
input vehicles_obj_rel_insert_input {
  data: vehicles_insert_input!

  """upsert condition"""
  on_conflict: vehicles_on_conflict
}

"""
on_conflict condition type for table "vehicles"
"""
input vehicles_on_conflict {
  constraint: vehicles_constraint!
  update_columns: [vehicles_update_column!]! = []
  where: vehicles_bool_exp
}

"""Ordering options when selecting data from "vehicles"."""
input vehicles_order_by {
  brand: order_by
  color: order_by
  created_at: order_by
  flagged: order_by
  id: order_by
  license: order_by
  make: order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: vehicles"""
input vehicles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "vehicles"
"""
enum vehicles_select_column {
  """column name"""
  brand

  """column name"""
  color

  """column name"""
  created_at

  """column name"""
  flagged

  """column name"""
  id

  """column name"""
  license

  """column name"""
  make

  """column name"""
  updated_at
}

"""
input type for updating data in table "vehicles"
"""
input vehicles_set_input {
  brand: String
  color: String
  created_at: timestamptz
  flagged: Boolean
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "vehicles"
"""
input vehicles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: vehicles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input vehicles_stream_cursor_value_input {
  brand: String
  color: String
  created_at: timestamptz
  flagged: Boolean
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
}

"""
update columns of table "vehicles"
"""
enum vehicles_update_column {
  """column name"""
  brand

  """column name"""
  color

  """column name"""
  created_at

  """column name"""
  flagged

  """column name"""
  id

  """column name"""
  license

  """column name"""
  make

  """column name"""
  updated_at
}

input vehicles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: vehicles_set_input

  """filter the rows which have to be updated"""
  where: vehicles_bool_exp!
}

"""
columns and relationships of "visit_status"
"""
type visit_status {
  status: String!

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "visit_status"
"""
type visit_status_aggregate {
  aggregate: visit_status_aggregate_fields
  nodes: [visit_status!]!
}

"""
aggregate fields of "visit_status"
"""
type visit_status_aggregate_fields {
  count(columns: [visit_status_select_column!], distinct: Boolean): Int!
  max: visit_status_max_fields
  min: visit_status_min_fields
}

"""
Boolean expression to filter rows from the table "visit_status". All fields are combined with a logical 'AND'.
"""
input visit_status_bool_exp {
  _and: [visit_status_bool_exp!]
  _not: visit_status_bool_exp
  _or: [visit_status_bool_exp!]
  status: String_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "visit_status"
"""
enum visit_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  visit_status_pkey
}

enum visit_status_enum {
  ACCEPTED
  PENDING
  REJECTED
}

"""
Boolean expression to compare columns of type "visit_status_enum". All fields are combined with logical 'AND'.
"""
input visit_status_enum_comparison_exp {
  _eq: visit_status_enum
  _in: [visit_status_enum!]
  _is_null: Boolean
  _neq: visit_status_enum
  _nin: [visit_status_enum!]
}

"""
input type for inserting data into table "visit_status"
"""
input visit_status_insert_input {
  status: String
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type visit_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type visit_status_min_fields {
  status: String
}

"""
response of any mutation on the table "visit_status"
"""
type visit_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [visit_status!]!
}

"""
input type for inserting object relation for remote table "visit_status"
"""
input visit_status_obj_rel_insert_input {
  data: visit_status_insert_input!

  """upsert condition"""
  on_conflict: visit_status_on_conflict
}

"""
on_conflict condition type for table "visit_status"
"""
input visit_status_on_conflict {
  constraint: visit_status_constraint!
  update_columns: [visit_status_update_column!]! = []
  where: visit_status_bool_exp
}

"""Ordering options when selecting data from "visit_status"."""
input visit_status_order_by {
  status: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: visit_status"""
input visit_status_pk_columns_input {
  status: String!
}

"""
select columns of table "visit_status"
"""
enum visit_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "visit_status"
"""
input visit_status_set_input {
  status: String
}

"""
Streaming cursor of the table "visit_status"
"""
input visit_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: visit_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input visit_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "visit_status"
"""
enum visit_status_update_column {
  """column name"""
  status
}

input visit_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: visit_status_set_input

  """filter the rows which have to be updated"""
  where: visit_status_bool_exp!
}

"""
columns and relationships of "visitors"
"""
type visitors {
  GENDER: gender_enum

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!
  back_id: uuid

  """An object relationship"""
  company: companies
  company_id: uuid
  created_at: timestamptz

  """An object relationship"""
  file: files

  """An object relationship"""
  fileByFrontId: files

  """An object relationship"""
  fileByPhoto: files
  firstname: String
  front_id: uuid

  """An object relationship"""
  gender: gender
  id: uuid!
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "visitors"
"""
type visitors_aggregate {
  aggregate: visitors_aggregate_fields
  nodes: [visitors!]!
}

input visitors_aggregate_bool_exp {
  count: visitors_aggregate_bool_exp_count
}

input visitors_aggregate_bool_exp_count {
  arguments: [visitors_select_column!]
  distinct: Boolean
  filter: visitors_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "visitors"
"""
type visitors_aggregate_fields {
  count(columns: [visitors_select_column!], distinct: Boolean): Int!
  max: visitors_max_fields
  min: visitors_min_fields
}

"""
order by aggregate values of table "visitors"
"""
input visitors_aggregate_order_by {
  count: order_by
  max: visitors_max_order_by
  min: visitors_min_order_by
}

"""
input type for inserting array relation for remote table "visitors"
"""
input visitors_arr_rel_insert_input {
  data: [visitors_insert_input!]!

  """upsert condition"""
  on_conflict: visitors_on_conflict
}

"""
Boolean expression to filter rows from the table "visitors". All fields are combined with a logical 'AND'.
"""
input visitors_bool_exp {
  GENDER: gender_enum_comparison_exp
  _and: [visitors_bool_exp!]
  _not: visitors_bool_exp
  _or: [visitors_bool_exp!]
  appointments: appointments_bool_exp
  appointments_aggregate: appointments_aggregate_bool_exp
  back_id: uuid_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  file: files_bool_exp
  fileByFrontId: files_bool_exp
  fileByPhoto: files_bool_exp
  firstname: String_comparison_exp
  front_id: uuid_comparison_exp
  gender: gender_bool_exp
  id: uuid_comparison_exp
  id_number: String_comparison_exp
  lastname: String_comparison_exp
  phone_number: String_comparison_exp
  photo: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "visitors"
"""
enum visitors_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  visitors_pkey
}

"""
input type for inserting data into table "visitors"
"""
input visitors_insert_input {
  GENDER: gender_enum
  appointments: appointments_arr_rel_insert_input
  back_id: uuid
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  file: files_obj_rel_insert_input
  fileByFrontId: files_obj_rel_insert_input
  fileByPhoto: files_obj_rel_insert_input
  firstname: String
  front_id: uuid
  gender: gender_obj_rel_insert_input
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type visitors_max_fields {
  back_id: uuid
  company_id: uuid
  created_at: timestamptz
  firstname: String
  front_id: uuid
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "visitors"
"""
input visitors_max_order_by {
  back_id: order_by
  company_id: order_by
  created_at: order_by
  firstname: order_by
  front_id: order_by
  id: order_by
  id_number: order_by
  lastname: order_by
  phone_number: order_by
  photo: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type visitors_min_fields {
  back_id: uuid
  company_id: uuid
  created_at: timestamptz
  firstname: String
  front_id: uuid
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "visitors"
"""
input visitors_min_order_by {
  back_id: order_by
  company_id: order_by
  created_at: order_by
  firstname: order_by
  front_id: order_by
  id: order_by
  id_number: order_by
  lastname: order_by
  phone_number: order_by
  photo: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "visitors"
"""
type visitors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [visitors!]!
}

"""
input type for inserting object relation for remote table "visitors"
"""
input visitors_obj_rel_insert_input {
  data: visitors_insert_input!

  """upsert condition"""
  on_conflict: visitors_on_conflict
}

"""
on_conflict condition type for table "visitors"
"""
input visitors_on_conflict {
  constraint: visitors_constraint!
  update_columns: [visitors_update_column!]! = []
  where: visitors_bool_exp
}

"""Ordering options when selecting data from "visitors"."""
input visitors_order_by {
  GENDER: order_by
  appointments_aggregate: appointments_aggregate_order_by
  back_id: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  file: files_order_by
  fileByFrontId: files_order_by
  fileByPhoto: files_order_by
  firstname: order_by
  front_id: order_by
  gender: gender_order_by
  id: order_by
  id_number: order_by
  lastname: order_by
  phone_number: order_by
  photo: order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: visitors"""
input visitors_pk_columns_input {
  id: uuid!
}

"""
select columns of table "visitors"
"""
enum visitors_select_column {
  """column name"""
  GENDER

  """column name"""
  back_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  firstname

  """column name"""
  front_id

  """column name"""
  id

  """column name"""
  id_number

  """column name"""
  lastname

  """column name"""
  phone_number

  """column name"""
  photo

  """column name"""
  updated_at
}

"""
input type for updating data in table "visitors"
"""
input visitors_set_input {
  GENDER: gender_enum
  back_id: uuid
  company_id: uuid
  created_at: timestamptz
  firstname: String
  front_id: uuid
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "visitors"
"""
input visitors_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: visitors_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input visitors_stream_cursor_value_input {
  GENDER: gender_enum
  back_id: uuid
  company_id: uuid
  created_at: timestamptz
  firstname: String
  front_id: uuid
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
}

"""
update columns of table "visitors"
"""
enum visitors_update_column {
  """column name"""
  GENDER

  """column name"""
  back_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  firstname

  """column name"""
  front_id

  """column name"""
  id

  """column name"""
  id_number

  """column name"""
  lastname

  """column name"""
  phone_number

  """column name"""
  photo

  """column name"""
  updated_at
}

input visitors_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: visitors_set_input

  """filter the rows which have to be updated"""
  where: visitors_bool_exp!
}

"""
columns and relationships of "visits"
"""
type visits {
  check_in_at: time
  check_out_at: time
  created_at: timestamptz
  date: date

  """An object relationship"""
  department: departments

  """An object relationship"""
  employee: employees

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid!
  reason: String
  reg_no: String

  """An object relationship"""
  service: services
  status: visit_status_enum
  updated_at: timestamptz
  vehicle: uuid

  """An object relationship"""
  vehicleByVehicle: vehicles

  """An object relationship"""
  visit_status: visit_status
  visitor: uuid!

  """An object relationship"""
  visitorByVisitor: visitors!
}

"""
aggregated selection of "visits"
"""
type visits_aggregate {
  aggregate: visits_aggregate_fields
  nodes: [visits!]!
}

input visits_aggregate_bool_exp {
  count: visits_aggregate_bool_exp_count
}

input visits_aggregate_bool_exp_count {
  arguments: [visits_select_column!]
  distinct: Boolean
  filter: visits_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "visits"
"""
type visits_aggregate_fields {
  count(columns: [visits_select_column!], distinct: Boolean): Int!
  max: visits_max_fields
  min: visits_min_fields
}

"""
order by aggregate values of table "visits"
"""
input visits_aggregate_order_by {
  count: order_by
  max: visits_max_order_by
  min: visits_min_order_by
}

"""
input type for inserting array relation for remote table "visits"
"""
input visits_arr_rel_insert_input {
  data: [visits_insert_input!]!

  """upsert condition"""
  on_conflict: visits_on_conflict
}

"""
Boolean expression to filter rows from the table "visits". All fields are combined with a logical 'AND'.
"""
input visits_bool_exp {
  _and: [visits_bool_exp!]
  _not: visits_bool_exp
  _or: [visits_bool_exp!]
  check_in_at: time_comparison_exp
  check_out_at: time_comparison_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  department: departments_bool_exp
  employee: employees_bool_exp
  employee_notifications: employee_notifications_bool_exp
  employee_notifications_aggregate: employee_notifications_aggregate_bool_exp
  host_department: uuid_comparison_exp
  host_employee: uuid_comparison_exp
  host_service: uuid_comparison_exp
  id: uuid_comparison_exp
  reason: String_comparison_exp
  reg_no: String_comparison_exp
  service: services_bool_exp
  status: visit_status_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  vehicle: uuid_comparison_exp
  vehicleByVehicle: vehicles_bool_exp
  visit_status: visit_status_bool_exp
  visitor: uuid_comparison_exp
  visitorByVisitor: visitors_bool_exp
}

"""
unique or primary key constraints on table "visits"
"""
enum visits_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  visits_pkey
}

"""
input type for inserting data into table "visits"
"""
input visits_insert_input {
  check_in_at: time
  check_out_at: time
  created_at: timestamptz
  date: date
  department: departments_obj_rel_insert_input
  employee: employees_obj_rel_insert_input
  employee_notifications: employee_notifications_arr_rel_insert_input
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  service: services_obj_rel_insert_input
  status: visit_status_enum
  updated_at: timestamptz
  vehicle: uuid
  vehicleByVehicle: vehicles_obj_rel_insert_input
  visit_status: visit_status_obj_rel_insert_input
  visitor: uuid
  visitorByVisitor: visitors_obj_rel_insert_input
}

"""aggregate max on columns"""
type visits_max_fields {
  created_at: timestamptz
  date: date
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  updated_at: timestamptz
  vehicle: uuid
  visitor: uuid
}

"""
order by max() on columns of table "visits"
"""
input visits_max_order_by {
  created_at: order_by
  date: order_by
  host_department: order_by
  host_employee: order_by
  host_service: order_by
  id: order_by
  reason: order_by
  reg_no: order_by
  updated_at: order_by
  vehicle: order_by
  visitor: order_by
}

"""aggregate min on columns"""
type visits_min_fields {
  created_at: timestamptz
  date: date
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  updated_at: timestamptz
  vehicle: uuid
  visitor: uuid
}

"""
order by min() on columns of table "visits"
"""
input visits_min_order_by {
  created_at: order_by
  date: order_by
  host_department: order_by
  host_employee: order_by
  host_service: order_by
  id: order_by
  reason: order_by
  reg_no: order_by
  updated_at: order_by
  vehicle: order_by
  visitor: order_by
}

"""
response of any mutation on the table "visits"
"""
type visits_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [visits!]!
}

"""
input type for inserting object relation for remote table "visits"
"""
input visits_obj_rel_insert_input {
  data: visits_insert_input!

  """upsert condition"""
  on_conflict: visits_on_conflict
}

"""
on_conflict condition type for table "visits"
"""
input visits_on_conflict {
  constraint: visits_constraint!
  update_columns: [visits_update_column!]! = []
  where: visits_bool_exp
}

"""Ordering options when selecting data from "visits"."""
input visits_order_by {
  check_in_at: order_by
  check_out_at: order_by
  created_at: order_by
  date: order_by
  department: departments_order_by
  employee: employees_order_by
  employee_notifications_aggregate: employee_notifications_aggregate_order_by
  host_department: order_by
  host_employee: order_by
  host_service: order_by
  id: order_by
  reason: order_by
  reg_no: order_by
  service: services_order_by
  status: order_by
  updated_at: order_by
  vehicle: order_by
  vehicleByVehicle: vehicles_order_by
  visit_status: visit_status_order_by
  visitor: order_by
  visitorByVisitor: visitors_order_by
}

"""primary key columns input for table: visits"""
input visits_pk_columns_input {
  id: uuid!
}

"""
select columns of table "visits"
"""
enum visits_select_column {
  """column name"""
  check_in_at

  """column name"""
  check_out_at

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  host_department

  """column name"""
  host_employee

  """column name"""
  host_service

  """column name"""
  id

  """column name"""
  reason

  """column name"""
  reg_no

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  vehicle

  """column name"""
  visitor
}

"""
input type for updating data in table "visits"
"""
input visits_set_input {
  check_in_at: time
  check_out_at: time
  created_at: timestamptz
  date: date
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  status: visit_status_enum
  updated_at: timestamptz
  vehicle: uuid
  visitor: uuid
}

"""
Streaming cursor of the table "visits"
"""
input visits_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: visits_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input visits_stream_cursor_value_input {
  check_in_at: time
  check_out_at: time
  created_at: timestamptz
  date: date
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  status: visit_status_enum
  updated_at: timestamptz
  vehicle: uuid
  visitor: uuid
}

"""
update columns of table "visits"
"""
enum visits_update_column {
  """column name"""
  check_in_at

  """column name"""
  check_out_at

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  host_department

  """column name"""
  host_employee

  """column name"""
  host_service

  """column name"""
  id

  """column name"""
  reason

  """column name"""
  reg_no

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  vehicle

  """column name"""
  visitor
}

input visits_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: visits_set_input

  """filter the rows which have to be updated"""
  where: visits_bool_exp!
}

type VisitsCountByDay {
  visitDay: String!
  visitorCount: Int!
}


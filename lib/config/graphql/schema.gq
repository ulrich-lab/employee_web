schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

input AddVisitorBrowserInputType {
  companyId: UUID!
  firstname: String!
  hostDepartment: UUID = null
  hostEmployee: UUID = null
  hostService: UUID = null
  idNumber: String!
  lastname: String!
  phoneNumber: String!
  reason: String
  regNo: String = null
  status: String!
  vehicle: UUID = null
  visitor: UUID = null
}

"""
columns and relationships of "agencies"
"""
type agencies {
  address: String
  city: String

  """An object relationship"""
  company: companies!
  company_id: uuid!
  created_at: timestamptz

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  location: geometry
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz
}

"""
aggregated selection of "agencies"
"""
type agencies_aggregate {
  aggregate: agencies_aggregate_fields
  nodes: [agencies!]!
}

input agencies_aggregate_bool_exp {
  count: agencies_aggregate_bool_exp_count
}

input agencies_aggregate_bool_exp_count {
  arguments: [agencies_select_column!]
  distinct: Boolean
  filter: agencies_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "agencies"
"""
type agencies_aggregate_fields {
  count(columns: [agencies_select_column!], distinct: Boolean): Int!
  max: agencies_max_fields
  min: agencies_min_fields
}

"""
order by aggregate values of table "agencies"
"""
input agencies_aggregate_order_by {
  count: order_by
  max: agencies_max_order_by
  min: agencies_min_order_by
}

"""
input type for inserting array relation for remote table "agencies"
"""
input agencies_arr_rel_insert_input {
  data: [agencies_insert_input!]!

  """upsert condition"""
  on_conflict: agencies_on_conflict
}

"""
Boolean expression to filter rows from the table "agencies". All fields are combined with a logical 'AND'.
"""
input agencies_bool_exp {
  _and: [agencies_bool_exp!]
  _not: agencies_bool_exp
  _or: [agencies_bool_exp!]
  address: String_comparison_exp
  city: String_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  name: uuid_comparison_exp
  neighborhood: String_comparison_exp
  office: String_comparison_exp
  phone_number: String_comparison_exp
  po_box: String_comparison_exp
  region: String_comparison_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "agencies"
"""
enum agencies_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  agencies_pkey
}

"""
input type for inserting data into table "agencies"
"""
input agencies_insert_input {
  address: String
  city: String
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  departments: departments_arr_rel_insert_input
  employees: employees_arr_rel_insert_input
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  services: services_arr_rel_insert_input
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type agencies_max_fields {
  address: String
  city: String
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "agencies"
"""
input agencies_max_order_by {
  address: order_by
  city: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  neighborhood: order_by
  office: order_by
  phone_number: order_by
  po_box: order_by
  region: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type agencies_min_fields {
  address: String
  city: String
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "agencies"
"""
input agencies_min_order_by {
  address: order_by
  city: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  neighborhood: order_by
  office: order_by
  phone_number: order_by
  po_box: order_by
  region: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "agencies"
"""
type agencies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [agencies!]!
}

"""
input type for inserting object relation for remote table "agencies"
"""
input agencies_obj_rel_insert_input {
  data: agencies_insert_input!

  """upsert condition"""
  on_conflict: agencies_on_conflict
}

"""
on_conflict condition type for table "agencies"
"""
input agencies_on_conflict {
  constraint: agencies_constraint!
  update_columns: [agencies_update_column!]! = []
  where: agencies_bool_exp
}

"""Ordering options when selecting data from "agencies"."""
input agencies_order_by {
  address: order_by
  city: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  departments_aggregate: departments_aggregate_order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  location: order_by
  name: order_by
  neighborhood: order_by
  office: order_by
  phone_number: order_by
  po_box: order_by
  region: order_by
  services_aggregate: services_aggregate_order_by
  text_content: text_content_order_by
  updated_at: order_by
}

"""primary key columns input for table: agencies"""
input agencies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "agencies"
"""
enum agencies_select_column {
  """column name"""
  address

  """column name"""
  city

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  neighborhood

  """column name"""
  office

  """column name"""
  phone_number

  """column name"""
  po_box

  """column name"""
  region

  """column name"""
  updated_at
}

"""
input type for updating data in table "agencies"
"""
input agencies_set_input {
  address: String
  city: String
  company_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "agencies"
"""
input agencies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: agencies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input agencies_stream_cursor_value_input {
  address: String
  city: String
  company_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  office: String
  phone_number: String
  po_box: String
  region: String
  updated_at: timestamptz
}

"""
update columns of table "agencies"
"""
enum agencies_update_column {
  """column name"""
  address

  """column name"""
  city

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  neighborhood

  """column name"""
  office

  """column name"""
  phone_number

  """column name"""
  po_box

  """column name"""
  region

  """column name"""
  updated_at
}

input agencies_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: agencies_set_input

  """filter the rows which have to be updated"""
  where: agencies_bool_exp!
}

"""
columns and relationships of "alembic_version"
"""
type alembic_version {
  version_num: String!
}

"""
aggregated selection of "alembic_version"
"""
type alembic_version_aggregate {
  aggregate: alembic_version_aggregate_fields
  nodes: [alembic_version!]!
}

"""
aggregate fields of "alembic_version"
"""
type alembic_version_aggregate_fields {
  count(columns: [alembic_version_select_column!], distinct: Boolean): Int!
  max: alembic_version_max_fields
  min: alembic_version_min_fields
}

"""
Boolean expression to filter rows from the table "alembic_version". All fields are combined with a logical 'AND'.
"""
input alembic_version_bool_exp {
  _and: [alembic_version_bool_exp!]
  _not: alembic_version_bool_exp
  _or: [alembic_version_bool_exp!]
  version_num: String_comparison_exp
}

"""
unique or primary key constraints on table "alembic_version"
"""
enum alembic_version_constraint {
  """
  unique or primary key constraint on columns "version_num"
  """
  alembic_version_pkc
}

"""
input type for inserting data into table "alembic_version"
"""
input alembic_version_insert_input {
  version_num: String
}

"""aggregate max on columns"""
type alembic_version_max_fields {
  version_num: String
}

"""aggregate min on columns"""
type alembic_version_min_fields {
  version_num: String
}

"""
response of any mutation on the table "alembic_version"
"""
type alembic_version_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [alembic_version!]!
}

"""
on_conflict condition type for table "alembic_version"
"""
input alembic_version_on_conflict {
  constraint: alembic_version_constraint!
  update_columns: [alembic_version_update_column!]! = []
  where: alembic_version_bool_exp
}

"""Ordering options when selecting data from "alembic_version"."""
input alembic_version_order_by {
  version_num: order_by
}

"""primary key columns input for table: alembic_version"""
input alembic_version_pk_columns_input {
  version_num: String!
}

"""
select columns of table "alembic_version"
"""
enum alembic_version_select_column {
  """column name"""
  version_num
}

"""
input type for updating data in table "alembic_version"
"""
input alembic_version_set_input {
  version_num: String
}

"""
Streaming cursor of the table "alembic_version"
"""
input alembic_version_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: alembic_version_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input alembic_version_stream_cursor_value_input {
  version_num: String
}

"""
update columns of table "alembic_version"
"""
enum alembic_version_update_column {
  """column name"""
  version_num
}

input alembic_version_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: alembic_version_set_input

  """filter the rows which have to be updated"""
  where: alembic_version_bool_exp!
}

"""
columns and relationships of "app_versions"
"""
type app_versions {
  created_at: timestamptz
  name: String!
  url: String!
  version: String!
}

"""
aggregated selection of "app_versions"
"""
type app_versions_aggregate {
  aggregate: app_versions_aggregate_fields
  nodes: [app_versions!]!
}

"""
aggregate fields of "app_versions"
"""
type app_versions_aggregate_fields {
  count(columns: [app_versions_select_column!], distinct: Boolean): Int!
  max: app_versions_max_fields
  min: app_versions_min_fields
}

"""
Boolean expression to filter rows from the table "app_versions". All fields are combined with a logical 'AND'.
"""
input app_versions_bool_exp {
  _and: [app_versions_bool_exp!]
  _not: app_versions_bool_exp
  _or: [app_versions_bool_exp!]
  created_at: timestamptz_comparison_exp
  name: String_comparison_exp
  url: String_comparison_exp
  version: String_comparison_exp
}

"""
unique or primary key constraints on table "app_versions"
"""
enum app_versions_constraint {
  """
  unique or primary key constraint on columns "version"
  """
  app_versions_pkey
}

"""
input type for inserting data into table "app_versions"
"""
input app_versions_insert_input {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""aggregate max on columns"""
type app_versions_max_fields {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""aggregate min on columns"""
type app_versions_min_fields {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""
response of any mutation on the table "app_versions"
"""
type app_versions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [app_versions!]!
}

"""
on_conflict condition type for table "app_versions"
"""
input app_versions_on_conflict {
  constraint: app_versions_constraint!
  update_columns: [app_versions_update_column!]! = []
  where: app_versions_bool_exp
}

"""Ordering options when selecting data from "app_versions"."""
input app_versions_order_by {
  created_at: order_by
  name: order_by
  url: order_by
  version: order_by
}

"""primary key columns input for table: app_versions"""
input app_versions_pk_columns_input {
  version: String!
}

"""
select columns of table "app_versions"
"""
enum app_versions_select_column {
  """column name"""
  created_at

  """column name"""
  name

  """column name"""
  url

  """column name"""
  version
}

"""
input type for updating data in table "app_versions"
"""
input app_versions_set_input {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""
Streaming cursor of the table "app_versions"
"""
input app_versions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: app_versions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input app_versions_stream_cursor_value_input {
  created_at: timestamptz
  name: String
  url: String
  version: String
}

"""
update columns of table "app_versions"
"""
enum app_versions_update_column {
  """column name"""
  created_at

  """column name"""
  name

  """column name"""
  url

  """column name"""
  version
}

input app_versions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: app_versions_set_input

  """filter the rows which have to be updated"""
  where: app_versions_bool_exp!
}

"""
columns and relationships of "appointment_status"
"""
type appointment_status {
  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!
  status: String!
}

"""
aggregated selection of "appointment_status"
"""
type appointment_status_aggregate {
  aggregate: appointment_status_aggregate_fields
  nodes: [appointment_status!]!
}

"""
aggregate fields of "appointment_status"
"""
type appointment_status_aggregate_fields {
  count(columns: [appointment_status_select_column!], distinct: Boolean): Int!
  max: appointment_status_max_fields
  min: appointment_status_min_fields
}

"""
Boolean expression to filter rows from the table "appointment_status". All fields are combined with a logical 'AND'.
"""
input appointment_status_bool_exp {
  _and: [appointment_status_bool_exp!]
  _not: appointment_status_bool_exp
  _or: [appointment_status_bool_exp!]
  appointments: appointments_bool_exp
  appointments_aggregate: appointments_aggregate_bool_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "appointment_status"
"""
enum appointment_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  appointment_status_pkey
}

enum appointment_status_enum {
  CANCELED
  COMPLETED
  PENDING
}

"""
Boolean expression to compare columns of type "appointment_status_enum". All fields are combined with logical 'AND'.
"""
input appointment_status_enum_comparison_exp {
  _eq: appointment_status_enum
  _in: [appointment_status_enum!]
  _is_null: Boolean
  _neq: appointment_status_enum
  _nin: [appointment_status_enum!]
}

"""
input type for inserting data into table "appointment_status"
"""
input appointment_status_insert_input {
  appointments: appointments_arr_rel_insert_input
  status: String
}

"""aggregate max on columns"""
type appointment_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type appointment_status_min_fields {
  status: String
}

"""
response of any mutation on the table "appointment_status"
"""
type appointment_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [appointment_status!]!
}

"""
input type for inserting object relation for remote table "appointment_status"
"""
input appointment_status_obj_rel_insert_input {
  data: appointment_status_insert_input!

  """upsert condition"""
  on_conflict: appointment_status_on_conflict
}

"""
on_conflict condition type for table "appointment_status"
"""
input appointment_status_on_conflict {
  constraint: appointment_status_constraint!
  update_columns: [appointment_status_update_column!]! = []
  where: appointment_status_bool_exp
}

"""Ordering options when selecting data from "appointment_status"."""
input appointment_status_order_by {
  appointments_aggregate: appointments_aggregate_order_by
  status: order_by
}

"""primary key columns input for table: appointment_status"""
input appointment_status_pk_columns_input {
  status: String!
}

"""
select columns of table "appointment_status"
"""
enum appointment_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "appointment_status"
"""
input appointment_status_set_input {
  status: String
}

"""
Streaming cursor of the table "appointment_status"
"""
input appointment_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: appointment_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input appointment_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "appointment_status"
"""
enum appointment_status_update_column {
  """column name"""
  status
}

input appointment_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: appointment_status_set_input

  """filter the rows which have to be updated"""
  where: appointment_status_bool_exp!
}

"""
columns and relationships of "appointments"
"""
type appointments {
  """An object relationship"""
  appointment_status: appointment_status
  created_at: timestamptz
  date: date
  description: String

  """An object relationship"""
  employee: employees
  employee_id: uuid
  end_time: time
  id: uuid!
  start_time: time
  status: appointment_status_enum
  updated_at: timestamptz

  """An object relationship"""
  visitor: visitors
  visitor_id: uuid
}

"""
aggregated selection of "appointments"
"""
type appointments_aggregate {
  aggregate: appointments_aggregate_fields
  nodes: [appointments!]!
}

input appointments_aggregate_bool_exp {
  count: appointments_aggregate_bool_exp_count
}

input appointments_aggregate_bool_exp_count {
  arguments: [appointments_select_column!]
  distinct: Boolean
  filter: appointments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "appointments"
"""
type appointments_aggregate_fields {
  count(columns: [appointments_select_column!], distinct: Boolean): Int!
  max: appointments_max_fields
  min: appointments_min_fields
}

"""
order by aggregate values of table "appointments"
"""
input appointments_aggregate_order_by {
  count: order_by
  max: appointments_max_order_by
  min: appointments_min_order_by
}

"""
input type for inserting array relation for remote table "appointments"
"""
input appointments_arr_rel_insert_input {
  data: [appointments_insert_input!]!

  """upsert condition"""
  on_conflict: appointments_on_conflict
}

"""
Boolean expression to filter rows from the table "appointments". All fields are combined with a logical 'AND'.
"""
input appointments_bool_exp {
  _and: [appointments_bool_exp!]
  _not: appointments_bool_exp
  _or: [appointments_bool_exp!]
  appointment_status: appointment_status_bool_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  description: String_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  end_time: time_comparison_exp
  id: uuid_comparison_exp
  start_time: time_comparison_exp
  status: appointment_status_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  visitor: visitors_bool_exp
  visitor_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "appointments"
"""
enum appointments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  appointments_pkey
}

"""
input type for inserting data into table "appointments"
"""
input appointments_insert_input {
  appointment_status: appointment_status_obj_rel_insert_input
  created_at: timestamptz
  date: date
  description: String
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  end_time: time
  id: uuid
  start_time: time
  status: appointment_status_enum
  updated_at: timestamptz
  visitor: visitors_obj_rel_insert_input
  visitor_id: uuid
}

"""aggregate max on columns"""
type appointments_max_fields {
  created_at: timestamptz
  date: date
  description: String
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
  visitor_id: uuid
}

"""
order by max() on columns of table "appointments"
"""
input appointments_max_order_by {
  created_at: order_by
  date: order_by
  description: order_by
  employee_id: order_by
  id: order_by
  updated_at: order_by
  visitor_id: order_by
}

"""aggregate min on columns"""
type appointments_min_fields {
  created_at: timestamptz
  date: date
  description: String
  employee_id: uuid
  id: uuid
  updated_at: timestamptz
  visitor_id: uuid
}

"""
order by min() on columns of table "appointments"
"""
input appointments_min_order_by {
  created_at: order_by
  date: order_by
  description: order_by
  employee_id: order_by
  id: order_by
  updated_at: order_by
  visitor_id: order_by
}

"""
response of any mutation on the table "appointments"
"""
type appointments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [appointments!]!
}

"""
on_conflict condition type for table "appointments"
"""
input appointments_on_conflict {
  constraint: appointments_constraint!
  update_columns: [appointments_update_column!]! = []
  where: appointments_bool_exp
}

"""Ordering options when selecting data from "appointments"."""
input appointments_order_by {
  appointment_status: appointment_status_order_by
  created_at: order_by
  date: order_by
  description: order_by
  employee: employees_order_by
  employee_id: order_by
  end_time: order_by
  id: order_by
  start_time: order_by
  status: order_by
  updated_at: order_by
  visitor: visitors_order_by
  visitor_id: order_by
}

"""primary key columns input for table: appointments"""
input appointments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "appointments"
"""
enum appointments_select_column {
  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  description

  """column name"""
  employee_id

  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  start_time

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  visitor_id
}

"""
input type for updating data in table "appointments"
"""
input appointments_set_input {
  created_at: timestamptz
  date: date
  description: String
  employee_id: uuid
  end_time: time
  id: uuid
  start_time: time
  status: appointment_status_enum
  updated_at: timestamptz
  visitor_id: uuid
}

"""
Streaming cursor of the table "appointments"
"""
input appointments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: appointments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input appointments_stream_cursor_value_input {
  created_at: timestamptz
  date: date
  description: String
  employee_id: uuid
  end_time: time
  id: uuid
  start_time: time
  status: appointment_status_enum
  updated_at: timestamptz
  visitor_id: uuid
}

"""
update columns of table "appointments"
"""
enum appointments_update_column {
  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  description

  """column name"""
  employee_id

  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  start_time

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  visitor_id
}

input appointments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: appointments_set_input

  """filter the rows which have to be updated"""
  where: appointments_bool_exp!
}

"""
columns and relationships of "attendance"
"""
type attendance {
  """An object relationship"""
  attendance_state: attendance_state
  building_id: uuid
  clock_in_date: date!
  clock_in_time: timestamptz
  clock_out_time: timestamptz

  """An object relationship"""
  employee: employees!
  employee_id: uuid!
  id: uuid!
  location: geometry

  """An object relationship"""
  shift: shifts
  shift_id: uuid
}

"""
aggregated selection of "attendance"
"""
type attendance_aggregate {
  aggregate: attendance_aggregate_fields
  nodes: [attendance!]!
}

input attendance_aggregate_bool_exp {
  count: attendance_aggregate_bool_exp_count
}

input attendance_aggregate_bool_exp_count {
  arguments: [attendance_select_column!]
  distinct: Boolean
  filter: attendance_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attendance"
"""
type attendance_aggregate_fields {
  count(columns: [attendance_select_column!], distinct: Boolean): Int!
  max: attendance_max_fields
  min: attendance_min_fields
}

"""
order by aggregate values of table "attendance"
"""
input attendance_aggregate_order_by {
  count: order_by
  max: attendance_max_order_by
  min: attendance_min_order_by
}

type attendance_all_month_employee {
  attendance_status(
    """JSON select path"""
    path: String
  ): json
  days(
    """JSON select path"""
    path: String
  ): json
  firstname: String
  id: uuid
}

"""
Boolean expression to filter rows from the logical model for
"attendance_all_month_employee". All fields are combined with a logical 'AND'.
"""
input attendance_all_month_employee_bool_exp_bool_exp {
  _and: [attendance_all_month_employee_bool_exp_bool_exp!]
  _not: attendance_all_month_employee_bool_exp_bool_exp
  _or: [attendance_all_month_employee_bool_exp_bool_exp!]
  attendance_status: json_comparison_exp
  days: json_comparison_exp
  firstname: String_comparison_exp
  id: uuid_comparison_exp
}

enum attendance_all_month_employee_enum_name {
  """column name"""
  attendance_status

  """column name"""
  days

  """column name"""
  firstname

  """column name"""
  id
}

"""
Ordering options when selecting data from "attendance_all_month_employee".
"""
input attendance_all_month_employee_order_by {
  attendance_status: order_by
  days: order_by
  firstname: order_by
  id: order_by
}

"""
input type for inserting array relation for remote table "attendance"
"""
input attendance_arr_rel_insert_input {
  data: [attendance_insert_input!]!

  """upsert condition"""
  on_conflict: attendance_on_conflict
}

"""
Boolean expression to filter rows from the table "attendance". All fields are combined with a logical 'AND'.
"""
input attendance_bool_exp {
  _and: [attendance_bool_exp!]
  _not: attendance_bool_exp
  _or: [attendance_bool_exp!]
  attendance_state: attendance_state_bool_exp
  building_id: uuid_comparison_exp
  clock_in_date: date_comparison_exp
  clock_in_time: timestamptz_comparison_exp
  clock_out_time: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  shift: shifts_bool_exp
  shift_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "attendance"
"""
enum attendance_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  attendance_pkey
}

"""
input type for inserting data into table "attendance"
"""
input attendance_insert_input {
  attendance_state: attendance_state_obj_rel_insert_input
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  location: geometry
  shift: shifts_obj_rel_insert_input
  shift_id: uuid
}

"""aggregate max on columns"""
type attendance_max_fields {
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
order by max() on columns of table "attendance"
"""
input attendance_max_order_by {
  building_id: order_by
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee_id: order_by
  id: order_by
  shift_id: order_by
}

"""aggregate min on columns"""
type attendance_min_fields {
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
order by min() on columns of table "attendance"
"""
input attendance_min_order_by {
  building_id: order_by
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee_id: order_by
  id: order_by
  shift_id: order_by
}

"""
response of any mutation on the table "attendance"
"""
type attendance_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attendance!]!
}

"""
columns and relationships of "attendance_new"
"""
type attendance_new {
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz

  """An object relationship"""
  employee: employees
  employee_id: uuid
  id: uuid!
  location: geometry

  """An object relationship"""
  shift: shifts
  shift_id: uuid
}

"""
aggregated selection of "attendance_new"
"""
type attendance_new_aggregate {
  aggregate: attendance_new_aggregate_fields
  nodes: [attendance_new!]!
}

input attendance_new_aggregate_bool_exp {
  count: attendance_new_aggregate_bool_exp_count
}

input attendance_new_aggregate_bool_exp_count {
  arguments: [attendance_new_select_column!]
  distinct: Boolean
  filter: attendance_new_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attendance_new"
"""
type attendance_new_aggregate_fields {
  count(columns: [attendance_new_select_column!], distinct: Boolean): Int!
  max: attendance_new_max_fields
  min: attendance_new_min_fields
}

"""
order by aggregate values of table "attendance_new"
"""
input attendance_new_aggregate_order_by {
  count: order_by
  max: attendance_new_max_order_by
  min: attendance_new_min_order_by
}

"""
input type for inserting array relation for remote table "attendance_new"
"""
input attendance_new_arr_rel_insert_input {
  data: [attendance_new_insert_input!]!

  """upsert condition"""
  on_conflict: attendance_new_on_conflict
}

"""
Boolean expression to filter rows from the table "attendance_new". All fields are combined with a logical 'AND'.
"""
input attendance_new_bool_exp {
  _and: [attendance_new_bool_exp!]
  _not: attendance_new_bool_exp
  _or: [attendance_new_bool_exp!]
  clock_in_date: date_comparison_exp
  clock_in_time: timestamptz_comparison_exp
  clock_out_time: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  shift: shifts_bool_exp
  shift_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "attendance_new"
"""
enum attendance_new_constraint {
  """
  unique or primary key constraint on columns "clock_in_date"
  """
  attendance_new_clock_in_date_key

  """
  unique or primary key constraint on columns "employee_id"
  """
  attendance_new_employee_id_key

  """
  unique or primary key constraint on columns "id"
  """
  attendance_new_pkey
}

"""
input type for inserting data into table "attendance_new"
"""
input attendance_new_insert_input {
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  location: geometry
  shift: shifts_obj_rel_insert_input
  shift_id: uuid
}

"""aggregate max on columns"""
type attendance_new_max_fields {
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
order by max() on columns of table "attendance_new"
"""
input attendance_new_max_order_by {
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee_id: order_by
  id: order_by
  shift_id: order_by
}

"""aggregate min on columns"""
type attendance_new_min_fields {
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  shift_id: uuid
}

"""
order by min() on columns of table "attendance_new"
"""
input attendance_new_min_order_by {
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee_id: order_by
  id: order_by
  shift_id: order_by
}

"""
response of any mutation on the table "attendance_new"
"""
type attendance_new_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attendance_new!]!
}

"""
input type for inserting object relation for remote table "attendance_new"
"""
input attendance_new_obj_rel_insert_input {
  data: attendance_new_insert_input!

  """upsert condition"""
  on_conflict: attendance_new_on_conflict
}

"""
on_conflict condition type for table "attendance_new"
"""
input attendance_new_on_conflict {
  constraint: attendance_new_constraint!
  update_columns: [attendance_new_update_column!]! = []
  where: attendance_new_bool_exp
}

"""Ordering options when selecting data from "attendance_new"."""
input attendance_new_order_by {
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  location: order_by
  shift: shifts_order_by
  shift_id: order_by
}

"""primary key columns input for table: attendance_new"""
input attendance_new_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attendance_new"
"""
enum attendance_new_select_column {
  """column name"""
  clock_in_date

  """column name"""
  clock_in_time

  """column name"""
  clock_out_time

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  shift_id
}

"""
input type for updating data in table "attendance_new"
"""
input attendance_new_set_input {
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  location: geometry
  shift_id: uuid
}

"""
Streaming cursor of the table "attendance_new"
"""
input attendance_new_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attendance_new_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attendance_new_stream_cursor_value_input {
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  location: geometry
  shift_id: uuid
}

"""
update columns of table "attendance_new"
"""
enum attendance_new_update_column {
  """column name"""
  clock_in_date

  """column name"""
  clock_in_time

  """column name"""
  clock_out_time

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  shift_id
}

input attendance_new_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: attendance_new_set_input

  """filter the rows which have to be updated"""
  where: attendance_new_bool_exp!
}

"""
input type for inserting object relation for remote table "attendance"
"""
input attendance_obj_rel_insert_input {
  data: attendance_insert_input!

  """upsert condition"""
  on_conflict: attendance_on_conflict
}

"""
on_conflict condition type for table "attendance"
"""
input attendance_on_conflict {
  constraint: attendance_constraint!
  update_columns: [attendance_update_column!]! = []
  where: attendance_bool_exp
}

"""Ordering options when selecting data from "attendance"."""
input attendance_order_by {
  attendance_state: attendance_state_order_by
  building_id: order_by
  clock_in_date: order_by
  clock_in_time: order_by
  clock_out_time: order_by
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  location: order_by
  shift: shifts_order_by
  shift_id: order_by
}

"""primary key columns input for table: attendance"""
input attendance_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attendance"
"""
enum attendance_select_column {
  """column name"""
  building_id

  """column name"""
  clock_in_date

  """column name"""
  clock_in_time

  """column name"""
  clock_out_time

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  shift_id
}

"""
input type for updating data in table "attendance"
"""
input attendance_set_input {
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  location: geometry
  shift_id: uuid
}

"""
columns and relationships of "attendance_state"
"""
type attendance_state {
  """An object relationship"""
  attendance: attendance
  attendance_id: uuid
  id: uuid!
  is_late: Boolean
}

"""
aggregated selection of "attendance_state"
"""
type attendance_state_aggregate {
  aggregate: attendance_state_aggregate_fields
  nodes: [attendance_state!]!
}

"""
aggregate fields of "attendance_state"
"""
type attendance_state_aggregate_fields {
  count(columns: [attendance_state_select_column!], distinct: Boolean): Int!
  max: attendance_state_max_fields
  min: attendance_state_min_fields
}

"""
Boolean expression to filter rows from the table "attendance_state". All fields are combined with a logical 'AND'.
"""
input attendance_state_bool_exp {
  _and: [attendance_state_bool_exp!]
  _not: attendance_state_bool_exp
  _or: [attendance_state_bool_exp!]
  attendance: attendance_bool_exp
  attendance_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_late: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "attendance_state"
"""
enum attendance_state_constraint {
  """
  unique or primary key constraint on columns "attendance_id"
  """
  attendance_state_attendance_id_key

  """
  unique or primary key constraint on columns "id"
  """
  attendance_state_pkey
}

"""
input type for inserting data into table "attendance_state"
"""
input attendance_state_insert_input {
  attendance: attendance_obj_rel_insert_input
  attendance_id: uuid
  id: uuid
  is_late: Boolean
}

"""aggregate max on columns"""
type attendance_state_max_fields {
  attendance_id: uuid
  id: uuid
}

"""aggregate min on columns"""
type attendance_state_min_fields {
  attendance_id: uuid
  id: uuid
}

"""
response of any mutation on the table "attendance_state"
"""
type attendance_state_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attendance_state!]!
}

"""
input type for inserting object relation for remote table "attendance_state"
"""
input attendance_state_obj_rel_insert_input {
  data: attendance_state_insert_input!

  """upsert condition"""
  on_conflict: attendance_state_on_conflict
}

"""
on_conflict condition type for table "attendance_state"
"""
input attendance_state_on_conflict {
  constraint: attendance_state_constraint!
  update_columns: [attendance_state_update_column!]! = []
  where: attendance_state_bool_exp
}

"""Ordering options when selecting data from "attendance_state"."""
input attendance_state_order_by {
  attendance: attendance_order_by
  attendance_id: order_by
  id: order_by
  is_late: order_by
}

"""primary key columns input for table: attendance_state"""
input attendance_state_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attendance_state"
"""
enum attendance_state_select_column {
  """column name"""
  attendance_id

  """column name"""
  id

  """column name"""
  is_late
}

"""
input type for updating data in table "attendance_state"
"""
input attendance_state_set_input {
  attendance_id: uuid
  id: uuid
  is_late: Boolean
}

"""
Streaming cursor of the table "attendance_state"
"""
input attendance_state_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attendance_state_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attendance_state_stream_cursor_value_input {
  attendance_id: uuid
  id: uuid
  is_late: Boolean
}

"""
update columns of table "attendance_state"
"""
enum attendance_state_update_column {
  """column name"""
  attendance_id

  """column name"""
  id

  """column name"""
  is_late
}

input attendance_state_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: attendance_state_set_input

  """filter the rows which have to be updated"""
  where: attendance_state_bool_exp!
}

"""
Streaming cursor of the table "attendance"
"""
input attendance_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attendance_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attendance_stream_cursor_value_input {
  building_id: uuid
  clock_in_date: date
  clock_in_time: timestamptz
  clock_out_time: timestamptz
  employee_id: uuid
  id: uuid
  location: geometry
  shift_id: uuid
}

"""
update columns of table "attendance"
"""
enum attendance_update_column {
  """column name"""
  building_id

  """column name"""
  clock_in_date

  """column name"""
  clock_in_time

  """column name"""
  clock_out_time

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  location

  """column name"""
  shift_id
}

input attendance_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: attendance_set_input

  """filter the rows which have to be updated"""
  where: attendance_bool_exp!
}

type attendance_week {
  on_time_count: bigint
  total_attendance: bigint
  weekday: String
}

"""
Boolean expression to filter rows from the logical model for "attendance_week".
All fields are combined with a logical 'AND'.
"""
input attendance_week_bool_exp_bool_exp {
  _and: [attendance_week_bool_exp_bool_exp!]
  _not: attendance_week_bool_exp_bool_exp
  _or: [attendance_week_bool_exp_bool_exp!]
  on_time_count: bigint_comparison_exp
  total_attendance: bigint_comparison_exp
  weekday: String_comparison_exp
}

enum attendance_week_enum_name {
  """column name"""
  on_time_count

  """column name"""
  total_attendance

  """column name"""
  weekday
}

"""Ordering options when selecting data from "attendance_week"."""
input attendance_week_order_by {
  on_time_count: order_by
  total_attendance: order_by
  weekday: order_by
}

input AttendanceInpuType {
  endDate: DateTime!
  startDate: DateTime!
}

type AttendanceType {
  clockIn: DateTime!
  clockOut: DateTime
  employee: EmployeeAttendatceType!
  timeInBuilding: String
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type clock_in_count {
  clock_in_count: bigint
  day: numeric
}

"""
Boolean expression to filter rows from the logical model for "clock_in_count". All fields are combined with a logical 'AND'.
"""
input clock_in_count_bool_exp_bool_exp {
  _and: [clock_in_count_bool_exp_bool_exp!]
  _not: clock_in_count_bool_exp_bool_exp
  _or: [clock_in_count_bool_exp_bool_exp!]
  clock_in_count: bigint_comparison_exp
  day: numeric_comparison_exp
}

enum clock_in_count_enum_name {
  """column name"""
  clock_in_count

  """column name"""
  day
}

"""Ordering options when selecting data from "clock_in_count"."""
input clock_in_count_order_by {
  clock_in_count: order_by
  day: order_by
}

"""
columns and relationships of "companies"
"""
type companies {
  abbrev: String
  address: String

  """An array relationship"""
  agencies(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An aggregate relationship"""
  agencies_aggregate(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): agencies_aggregate!
  city: String

  """An object relationship"""
  company_setting: company_settings

  """An array relationship"""
  company_settings(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): [company_settings!]!

  """An aggregate relationship"""
  company_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): company_settings_aggregate!
  created_at: timestamptz

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!
  email: String!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  location: geometry
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!
}

"""
aggregated selection of "companies"
"""
type companies_aggregate {
  aggregate: companies_aggregate_fields
  nodes: [companies!]!
}

input companies_aggregate_bool_exp {
  count: companies_aggregate_bool_exp_count
}

input companies_aggregate_bool_exp_count {
  arguments: [companies_select_column!]
  distinct: Boolean
  filter: companies_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "companies"
"""
type companies_aggregate_fields {
  count(columns: [companies_select_column!], distinct: Boolean): Int!
  max: companies_max_fields
  min: companies_min_fields
}

"""
order by aggregate values of table "companies"
"""
input companies_aggregate_order_by {
  count: order_by
  max: companies_max_order_by
  min: companies_min_order_by
}

"""
input type for inserting array relation for remote table "companies"
"""
input companies_arr_rel_insert_input {
  data: [companies_insert_input!]!

  """upsert condition"""
  on_conflict: companies_on_conflict
}

"""
Boolean expression to filter rows from the table "companies". All fields are combined with a logical 'AND'.
"""
input companies_bool_exp {
  _and: [companies_bool_exp!]
  _not: companies_bool_exp
  _or: [companies_bool_exp!]
  abbrev: String_comparison_exp
  address: String_comparison_exp
  agencies: agencies_bool_exp
  agencies_aggregate: agencies_aggregate_bool_exp
  city: String_comparison_exp
  company_setting: company_settings_bool_exp
  company_settings: company_settings_bool_exp
  company_settings_aggregate: company_settings_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  email: String_comparison_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  name: uuid_comparison_exp
  neighborhood: String_comparison_exp
  phone_number: String_comparison_exp
  po_box: String_comparison_exp
  profile_picture: String_comparison_exp
  region: String_comparison_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
  visitors: visitors_bool_exp
  visitors_aggregate: visitors_aggregate_bool_exp
}

"""
unique or primary key constraints on table "companies"
"""
enum companies_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  companies_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  companies_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  companies_pkey
}

"""
input type for inserting data into table "companies"
"""
input companies_insert_input {
  abbrev: String
  address: String
  agencies: agencies_arr_rel_insert_input
  city: String
  company_setting: company_settings_obj_rel_insert_input
  company_settings: company_settings_arr_rel_insert_input
  created_at: timestamptz
  departments: departments_arr_rel_insert_input
  email: String
  employees: employees_arr_rel_insert_input
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  services: services_arr_rel_insert_input
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
  visitors: visitors_arr_rel_insert_input
}

"""aggregate max on columns"""
type companies_max_fields {
  abbrev: String
  address: String
  city: String
  created_at: timestamptz
  email: String
  id: uuid
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "companies"
"""
input companies_max_order_by {
  abbrev: order_by
  address: order_by
  city: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  neighborhood: order_by
  phone_number: order_by
  po_box: order_by
  profile_picture: order_by
  region: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type companies_min_fields {
  abbrev: String
  address: String
  city: String
  created_at: timestamptz
  email: String
  id: uuid
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "companies"
"""
input companies_min_order_by {
  abbrev: order_by
  address: order_by
  city: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  neighborhood: order_by
  phone_number: order_by
  po_box: order_by
  profile_picture: order_by
  region: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "companies"
"""
type companies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [companies!]!
}

"""
input type for inserting object relation for remote table "companies"
"""
input companies_obj_rel_insert_input {
  data: companies_insert_input!

  """upsert condition"""
  on_conflict: companies_on_conflict
}

"""
on_conflict condition type for table "companies"
"""
input companies_on_conflict {
  constraint: companies_constraint!
  update_columns: [companies_update_column!]! = []
  where: companies_bool_exp
}

"""Ordering options when selecting data from "companies"."""
input companies_order_by {
  abbrev: order_by
  address: order_by
  agencies_aggregate: agencies_aggregate_order_by
  city: order_by
  company_setting: company_settings_order_by
  company_settings_aggregate: company_settings_aggregate_order_by
  created_at: order_by
  departments_aggregate: departments_aggregate_order_by
  email: order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  location: order_by
  name: order_by
  neighborhood: order_by
  phone_number: order_by
  po_box: order_by
  profile_picture: order_by
  region: order_by
  services_aggregate: services_aggregate_order_by
  text_content: text_content_order_by
  updated_at: order_by
  visitors_aggregate: visitors_aggregate_order_by
}

"""primary key columns input for table: companies"""
input companies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "companies"
"""
enum companies_select_column {
  """column name"""
  abbrev

  """column name"""
  address

  """column name"""
  city

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  neighborhood

  """column name"""
  phone_number

  """column name"""
  po_box

  """column name"""
  profile_picture

  """column name"""
  region

  """column name"""
  updated_at
}

"""
input type for updating data in table "companies"
"""
input companies_set_input {
  abbrev: String
  address: String
  city: String
  created_at: timestamptz
  email: String
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "companies"
"""
input companies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: companies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input companies_stream_cursor_value_input {
  abbrev: String
  address: String
  city: String
  created_at: timestamptz
  email: String
  id: uuid
  location: geometry
  name: uuid
  neighborhood: String
  phone_number: String
  po_box: String
  profile_picture: String
  region: String
  updated_at: timestamptz
}

"""
update columns of table "companies"
"""
enum companies_update_column {
  """column name"""
  abbrev

  """column name"""
  address

  """column name"""
  city

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  neighborhood

  """column name"""
  phone_number

  """column name"""
  po_box

  """column name"""
  profile_picture

  """column name"""
  region

  """column name"""
  updated_at
}

input companies_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: companies_set_input

  """filter the rows which have to be updated"""
  where: companies_bool_exp!
}

"""
columns and relationships of "company_settings"
"""
type company_settings {
  break_duration: interval

  """An object relationship"""
  company: companies!
  company_id: uuid!
  end_work_time: time!
  id: uuid!
  max_late_time: interval!
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  start_work_time: time!
  working_days: [Int!]!
}

"""
aggregated selection of "company_settings"
"""
type company_settings_aggregate {
  aggregate: company_settings_aggregate_fields
  nodes: [company_settings!]!
}

input company_settings_aggregate_bool_exp {
  count: company_settings_aggregate_bool_exp_count
}

input company_settings_aggregate_bool_exp_count {
  arguments: [company_settings_select_column!]
  distinct: Boolean
  filter: company_settings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "company_settings"
"""
type company_settings_aggregate_fields {
  avg: company_settings_avg_fields
  count(columns: [company_settings_select_column!], distinct: Boolean): Int!
  max: company_settings_max_fields
  min: company_settings_min_fields
  stddev: company_settings_stddev_fields
  stddev_pop: company_settings_stddev_pop_fields
  stddev_samp: company_settings_stddev_samp_fields
  sum: company_settings_sum_fields
  var_pop: company_settings_var_pop_fields
  var_samp: company_settings_var_samp_fields
  variance: company_settings_variance_fields
}

"""
order by aggregate values of table "company_settings"
"""
input company_settings_aggregate_order_by {
  avg: company_settings_avg_order_by
  count: order_by
  max: company_settings_max_order_by
  min: company_settings_min_order_by
  stddev: company_settings_stddev_order_by
  stddev_pop: company_settings_stddev_pop_order_by
  stddev_samp: company_settings_stddev_samp_order_by
  sum: company_settings_sum_order_by
  var_pop: company_settings_var_pop_order_by
  var_samp: company_settings_var_samp_order_by
  variance: company_settings_variance_order_by
}

"""
input type for inserting array relation for remote table "company_settings"
"""
input company_settings_arr_rel_insert_input {
  data: [company_settings_insert_input!]!

  """upsert condition"""
  on_conflict: company_settings_on_conflict
}

"""aggregate avg on columns"""
type company_settings_avg_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by avg() on columns of table "company_settings"
"""
input company_settings_avg_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""
Boolean expression to filter rows from the table "company_settings". All fields are combined with a logical 'AND'.
"""
input company_settings_bool_exp {
  _and: [company_settings_bool_exp!]
  _not: company_settings_bool_exp
  _or: [company_settings_bool_exp!]
  break_duration: interval_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  end_work_time: time_comparison_exp
  id: uuid_comparison_exp
  max_late_time: interval_comparison_exp
  max_leave_days_per_year: Int_comparison_exp
  number_of_leave_days: Int_comparison_exp
  start_work_time: time_comparison_exp
  working_days: Int_array_comparison_exp
}

"""
unique or primary key constraints on table "company_settings"
"""
enum company_settings_constraint {
  """
  unique or primary key constraint on columns "company_id"
  """
  company_settings_company_id_key

  """
  unique or primary key constraint on columns "id"
  """
  company_settings_pkey
}

"""
input type for incrementing numeric columns in table "company_settings"
"""
input company_settings_inc_input {
  max_leave_days_per_year: Int
  number_of_leave_days: Int
}

"""
input type for inserting data into table "company_settings"
"""
input company_settings_insert_input {
  break_duration: interval
  company: companies_obj_rel_insert_input
  company_id: uuid
  end_work_time: time
  id: uuid
  max_late_time: interval
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  start_work_time: time
  working_days: [Int!]
}

"""aggregate max on columns"""
type company_settings_max_fields {
  company_id: uuid
  id: uuid
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  working_days: [Int!]
}

"""
order by max() on columns of table "company_settings"
"""
input company_settings_max_order_by {
  company_id: order_by
  id: order_by
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
  working_days: order_by
}

"""aggregate min on columns"""
type company_settings_min_fields {
  company_id: uuid
  id: uuid
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  working_days: [Int!]
}

"""
order by min() on columns of table "company_settings"
"""
input company_settings_min_order_by {
  company_id: order_by
  id: order_by
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
  working_days: order_by
}

"""
response of any mutation on the table "company_settings"
"""
type company_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [company_settings!]!
}

"""
input type for inserting object relation for remote table "company_settings"
"""
input company_settings_obj_rel_insert_input {
  data: company_settings_insert_input!

  """upsert condition"""
  on_conflict: company_settings_on_conflict
}

"""
on_conflict condition type for table "company_settings"
"""
input company_settings_on_conflict {
  constraint: company_settings_constraint!
  update_columns: [company_settings_update_column!]! = []
  where: company_settings_bool_exp
}

"""Ordering options when selecting data from "company_settings"."""
input company_settings_order_by {
  break_duration: order_by
  company: companies_order_by
  company_id: order_by
  end_work_time: order_by
  id: order_by
  max_late_time: order_by
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
  start_work_time: order_by
  working_days: order_by
}

"""primary key columns input for table: company_settings"""
input company_settings_pk_columns_input {
  id: uuid!
}

"""
select columns of table "company_settings"
"""
enum company_settings_select_column {
  """column name"""
  break_duration

  """column name"""
  company_id

  """column name"""
  end_work_time

  """column name"""
  id

  """column name"""
  max_late_time

  """column name"""
  max_leave_days_per_year

  """column name"""
  number_of_leave_days

  """column name"""
  start_work_time

  """column name"""
  working_days
}

"""
input type for updating data in table "company_settings"
"""
input company_settings_set_input {
  break_duration: interval
  company_id: uuid
  end_work_time: time
  id: uuid
  max_late_time: interval
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  start_work_time: time
  working_days: [Int!]
}

"""aggregate stddev on columns"""
type company_settings_stddev_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by stddev() on columns of table "company_settings"
"""
input company_settings_stddev_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""aggregate stddev_pop on columns"""
type company_settings_stddev_pop_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by stddev_pop() on columns of table "company_settings"
"""
input company_settings_stddev_pop_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""aggregate stddev_samp on columns"""
type company_settings_stddev_samp_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by stddev_samp() on columns of table "company_settings"
"""
input company_settings_stddev_samp_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""
Streaming cursor of the table "company_settings"
"""
input company_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: company_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input company_settings_stream_cursor_value_input {
  break_duration: interval
  company_id: uuid
  end_work_time: time
  id: uuid
  max_late_time: interval
  max_leave_days_per_year: Int
  number_of_leave_days: Int
  start_work_time: time
  working_days: [Int!]
}

"""aggregate sum on columns"""
type company_settings_sum_fields {
  max_leave_days_per_year: Int
  number_of_leave_days: Int
}

"""
order by sum() on columns of table "company_settings"
"""
input company_settings_sum_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""
update columns of table "company_settings"
"""
enum company_settings_update_column {
  """column name"""
  break_duration

  """column name"""
  company_id

  """column name"""
  end_work_time

  """column name"""
  id

  """column name"""
  max_late_time

  """column name"""
  max_leave_days_per_year

  """column name"""
  number_of_leave_days

  """column name"""
  start_work_time

  """column name"""
  working_days
}

input company_settings_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: company_settings_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: company_settings_set_input

  """filter the rows which have to be updated"""
  where: company_settings_bool_exp!
}

"""aggregate var_pop on columns"""
type company_settings_var_pop_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by var_pop() on columns of table "company_settings"
"""
input company_settings_var_pop_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""aggregate var_samp on columns"""
type company_settings_var_samp_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by var_samp() on columns of table "company_settings"
"""
input company_settings_var_samp_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

"""aggregate variance on columns"""
type company_settings_variance_fields {
  max_leave_days_per_year: Float
  number_of_leave_days: Float
}

"""
order by variance() on columns of table "company_settings"
"""
input company_settings_variance_order_by {
  max_leave_days_per_year: order_by
  number_of_leave_days: order_by
}

input CreateEmployeeInput {
  address: String!
  agencyId: UUID = null
  companyId: UUID!
  departmentId: UUID!
  email: String
  firstname: String!
  function: String!
  lastname: String!
  license: String!
  password: String!
  phoneNumber: String!
  positionId: UUID!
  region: String!
  roles: CreateEmployeeRole!
  serviceId: UUID!
  supervisorId: UUID = null
}

enum CreateEmployeeRole {
  ADMIN
  EMPLOYEE
}

type CreateVisitorType {
  id: UUID!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""Date with time (isoformat)"""
scalar DateTime

type DayAttendanceType {
  attendance: [AttendanceType!]!
  date: DateTime!
}

"""
columns and relationships of "departments"
"""
type departments {
  abrev_code: String

  """An object relationship"""
  agency: agencies
  agency_id: uuid
  chief_department: uuid

  """An object relationship"""
  company: companies!
  company_id: uuid!
  created_at: timestamptz

  """An object relationship"""
  department: departments

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """An object relationship"""
  employee: employees

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  name: uuid
  parent_department_id: uuid

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  status: status_enum

  """An object relationship"""
  statusByStatus: status

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "departments"
"""
type departments_aggregate {
  aggregate: departments_aggregate_fields
  nodes: [departments!]!
}

input departments_aggregate_bool_exp {
  count: departments_aggregate_bool_exp_count
}

input departments_aggregate_bool_exp_count {
  arguments: [departments_select_column!]
  distinct: Boolean
  filter: departments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "departments"
"""
type departments_aggregate_fields {
  count(columns: [departments_select_column!], distinct: Boolean): Int!
  max: departments_max_fields
  min: departments_min_fields
}

"""
order by aggregate values of table "departments"
"""
input departments_aggregate_order_by {
  count: order_by
  max: departments_max_order_by
  min: departments_min_order_by
}

"""
input type for inserting array relation for remote table "departments"
"""
input departments_arr_rel_insert_input {
  data: [departments_insert_input!]!

  """upsert condition"""
  on_conflict: departments_on_conflict
}

"""
Boolean expression to filter rows from the table "departments". All fields are combined with a logical 'AND'.
"""
input departments_bool_exp {
  _and: [departments_bool_exp!]
  _not: departments_bool_exp
  _or: [departments_bool_exp!]
  abrev_code: String_comparison_exp
  agency: agencies_bool_exp
  agency_id: uuid_comparison_exp
  chief_department: uuid_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  department: departments_bool_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  employee: employees_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  name: uuid_comparison_exp
  parent_department_id: uuid_comparison_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  status: status_enum_comparison_exp
  statusByStatus: status_bool_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "departments"
"""
enum departments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  departments_pkey
}

"""
input type for inserting data into table "departments"
"""
input departments_insert_input {
  abrev_code: String
  agency: agencies_obj_rel_insert_input
  agency_id: uuid
  chief_department: uuid
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  department: departments_obj_rel_insert_input
  departments: departments_arr_rel_insert_input
  employee: employees_obj_rel_insert_input
  employees: employees_arr_rel_insert_input
  id: uuid
  name: uuid
  parent_department_id: uuid
  services: services_arr_rel_insert_input
  status: status_enum
  statusByStatus: status_obj_rel_insert_input
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type departments_max_fields {
  abrev_code: String
  agency_id: uuid
  chief_department: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  parent_department_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "departments"
"""
input departments_max_order_by {
  abrev_code: order_by
  agency_id: order_by
  chief_department: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  parent_department_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type departments_min_fields {
  abrev_code: String
  agency_id: uuid
  chief_department: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  parent_department_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "departments"
"""
input departments_min_order_by {
  abrev_code: order_by
  agency_id: order_by
  chief_department: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  parent_department_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "departments"
"""
type departments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [departments!]!
}

"""
input type for inserting object relation for remote table "departments"
"""
input departments_obj_rel_insert_input {
  data: departments_insert_input!

  """upsert condition"""
  on_conflict: departments_on_conflict
}

"""
on_conflict condition type for table "departments"
"""
input departments_on_conflict {
  constraint: departments_constraint!
  update_columns: [departments_update_column!]! = []
  where: departments_bool_exp
}

"""Ordering options when selecting data from "departments"."""
input departments_order_by {
  abrev_code: order_by
  agency: agencies_order_by
  agency_id: order_by
  chief_department: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  department: departments_order_by
  departments_aggregate: departments_aggregate_order_by
  employee: employees_order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  name: order_by
  parent_department_id: order_by
  services_aggregate: services_aggregate_order_by
  status: order_by
  statusByStatus: status_order_by
  text_content: text_content_order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: departments"""
input departments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "departments"
"""
enum departments_select_column {
  """column name"""
  abrev_code

  """column name"""
  agency_id

  """column name"""
  chief_department

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_department_id

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "departments"
"""
input departments_set_input {
  abrev_code: String
  agency_id: uuid
  chief_department: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  parent_department_id: uuid
  status: status_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "departments"
"""
input departments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: departments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input departments_stream_cursor_value_input {
  abrev_code: String
  agency_id: uuid
  chief_department: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  name: uuid
  parent_department_id: uuid
  status: status_enum
  updated_at: timestamptz
}

"""
update columns of table "departments"
"""
enum departments_update_column {
  """column name"""
  abrev_code

  """column name"""
  agency_id

  """column name"""
  chief_department

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_department_id

  """column name"""
  status

  """column name"""
  updated_at
}

input departments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: departments_set_input

  """filter the rows which have to be updated"""
  where: departments_bool_exp!
}

"""
columns and relationships of "employee_notifications"
"""
type employee_notifications {
  action: String!
  created_at: timestamptz

  """An object relationship"""
  employee: employees
  employee_id: uuid
  id: uuid!
  is_read: Boolean
  message: String!
  title: String!
  updated_at: timestamptz
}

"""
aggregated selection of "employee_notifications"
"""
type employee_notifications_aggregate {
  aggregate: employee_notifications_aggregate_fields
  nodes: [employee_notifications!]!
}

input employee_notifications_aggregate_bool_exp {
  bool_and: employee_notifications_aggregate_bool_exp_bool_and
  bool_or: employee_notifications_aggregate_bool_exp_bool_or
  count: employee_notifications_aggregate_bool_exp_count
}

input employee_notifications_aggregate_bool_exp_bool_and {
  arguments: employee_notifications_select_column_employee_notifications_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: employee_notifications_bool_exp
  predicate: Boolean_comparison_exp!
}

input employee_notifications_aggregate_bool_exp_bool_or {
  arguments: employee_notifications_select_column_employee_notifications_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: employee_notifications_bool_exp
  predicate: Boolean_comparison_exp!
}

input employee_notifications_aggregate_bool_exp_count {
  arguments: [employee_notifications_select_column!]
  distinct: Boolean
  filter: employee_notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employee_notifications"
"""
type employee_notifications_aggregate_fields {
  count(columns: [employee_notifications_select_column!], distinct: Boolean): Int!
  max: employee_notifications_max_fields
  min: employee_notifications_min_fields
}

"""
order by aggregate values of table "employee_notifications"
"""
input employee_notifications_aggregate_order_by {
  count: order_by
  max: employee_notifications_max_order_by
  min: employee_notifications_min_order_by
}

"""
input type for inserting array relation for remote table "employee_notifications"
"""
input employee_notifications_arr_rel_insert_input {
  data: [employee_notifications_insert_input!]!

  """upsert condition"""
  on_conflict: employee_notifications_on_conflict
}

"""
Boolean expression to filter rows from the table "employee_notifications". All fields are combined with a logical 'AND'.
"""
input employee_notifications_bool_exp {
  _and: [employee_notifications_bool_exp!]
  _not: employee_notifications_bool_exp
  _or: [employee_notifications_bool_exp!]
  action: String_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_read: Boolean_comparison_exp
  message: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "employee_notifications"
"""
enum employee_notifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employee_notifications_pkey
}

"""
input type for inserting data into table "employee_notifications"
"""
input employee_notifications_insert_input {
  action: String
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  is_read: Boolean
  message: String
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type employee_notifications_max_fields {
  action: String
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  message: String
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "employee_notifications"
"""
input employee_notifications_max_order_by {
  action: order_by
  created_at: order_by
  employee_id: order_by
  id: order_by
  message: order_by
  title: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type employee_notifications_min_fields {
  action: String
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  message: String
  title: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "employee_notifications"
"""
input employee_notifications_min_order_by {
  action: order_by
  created_at: order_by
  employee_id: order_by
  id: order_by
  message: order_by
  title: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "employee_notifications"
"""
type employee_notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employee_notifications!]!
}

"""
on_conflict condition type for table "employee_notifications"
"""
input employee_notifications_on_conflict {
  constraint: employee_notifications_constraint!
  update_columns: [employee_notifications_update_column!]! = []
  where: employee_notifications_bool_exp
}

"""Ordering options when selecting data from "employee_notifications"."""
input employee_notifications_order_by {
  action: order_by
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  is_read: order_by
  message: order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: employee_notifications"""
input employee_notifications_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_notifications"
"""
enum employee_notifications_select_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  title

  """column name"""
  updated_at
}

"""
select "employee_notifications_aggregate_bool_exp_bool_and_arguments_columns" columns of table "employee_notifications"
"""
enum employee_notifications_select_column_employee_notifications_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_read
}

"""
select "employee_notifications_aggregate_bool_exp_bool_or_arguments_columns" columns of table "employee_notifications"
"""
enum employee_notifications_select_column_employee_notifications_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_read
}

"""
input type for updating data in table "employee_notifications"
"""
input employee_notifications_set_input {
  action: String
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  is_read: Boolean
  message: String
  title: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "employee_notifications"
"""
input employee_notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employee_notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employee_notifications_stream_cursor_value_input {
  action: String
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  is_read: Boolean
  message: String
  title: String
  updated_at: timestamptz
}

"""
update columns of table "employee_notifications"
"""
enum employee_notifications_update_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  title

  """column name"""
  updated_at
}

input employee_notifications_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employee_notifications_set_input

  """filter the rows which have to be updated"""
  where: employee_notifications_bool_exp!
}

"""
columns and relationships of "employee_roles"
"""
type employee_roles {
  created_at: timestamptz

  """An object relationship"""
  employee: employees!
  employee_id: uuid!
  id: uuid!

  """An object relationship"""
  role: roles!
  role_id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "employee_roles"
"""
type employee_roles_aggregate {
  aggregate: employee_roles_aggregate_fields
  nodes: [employee_roles!]!
}

input employee_roles_aggregate_bool_exp {
  count: employee_roles_aggregate_bool_exp_count
}

input employee_roles_aggregate_bool_exp_count {
  arguments: [employee_roles_select_column!]
  distinct: Boolean
  filter: employee_roles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employee_roles"
"""
type employee_roles_aggregate_fields {
  count(columns: [employee_roles_select_column!], distinct: Boolean): Int!
  max: employee_roles_max_fields
  min: employee_roles_min_fields
}

"""
order by aggregate values of table "employee_roles"
"""
input employee_roles_aggregate_order_by {
  count: order_by
  max: employee_roles_max_order_by
  min: employee_roles_min_order_by
}

"""
input type for inserting array relation for remote table "employee_roles"
"""
input employee_roles_arr_rel_insert_input {
  data: [employee_roles_insert_input!]!

  """upsert condition"""
  on_conflict: employee_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "employee_roles". All fields are combined with a logical 'AND'.
"""
input employee_roles_bool_exp {
  _and: [employee_roles_bool_exp!]
  _not: employee_roles_bool_exp
  _or: [employee_roles_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  role: roles_bool_exp
  role_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "employee_roles"
"""
enum employee_roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employee_roles_pkey
}

"""
input type for inserting data into table "employee_roles"
"""
input employee_roles_insert_input {
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  role: roles_obj_rel_insert_input
  role_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type employee_roles_max_fields {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "employee_roles"
"""
input employee_roles_max_order_by {
  created_at: order_by
  employee_id: order_by
  id: order_by
  role_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type employee_roles_min_fields {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "employee_roles"
"""
input employee_roles_min_order_by {
  created_at: order_by
  employee_id: order_by
  id: order_by
  role_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "employee_roles"
"""
type employee_roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employee_roles!]!
}

"""
on_conflict condition type for table "employee_roles"
"""
input employee_roles_on_conflict {
  constraint: employee_roles_constraint!
  update_columns: [employee_roles_update_column!]! = []
  where: employee_roles_bool_exp
}

"""Ordering options when selecting data from "employee_roles"."""
input employee_roles_order_by {
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  role: roles_order_by
  role_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: employee_roles"""
input employee_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_roles"
"""
enum employee_roles_select_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "employee_roles"
"""
input employee_roles_set_input {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "employee_roles"
"""
input employee_roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employee_roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employee_roles_stream_cursor_value_input {
  created_at: timestamptz
  employee_id: uuid
  id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "employee_roles"
"""
enum employee_roles_update_column {
  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  updated_at
}

input employee_roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employee_roles_set_input

  """filter the rows which have to be updated"""
  where: employee_roles_bool_exp!
}

"""
columns and relationships of "employee_shifts"
"""
type employee_shifts {
  """An object relationship"""
  employee: employees
  employee_id: uuid
  id: uuid!

  """An object relationship"""
  shift: shifts
  shit_id: uuid
}

"""
aggregated selection of "employee_shifts"
"""
type employee_shifts_aggregate {
  aggregate: employee_shifts_aggregate_fields
  nodes: [employee_shifts!]!
}

input employee_shifts_aggregate_bool_exp {
  count: employee_shifts_aggregate_bool_exp_count
}

input employee_shifts_aggregate_bool_exp_count {
  arguments: [employee_shifts_select_column!]
  distinct: Boolean
  filter: employee_shifts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employee_shifts"
"""
type employee_shifts_aggregate_fields {
  count(columns: [employee_shifts_select_column!], distinct: Boolean): Int!
  max: employee_shifts_max_fields
  min: employee_shifts_min_fields
}

"""
order by aggregate values of table "employee_shifts"
"""
input employee_shifts_aggregate_order_by {
  count: order_by
  max: employee_shifts_max_order_by
  min: employee_shifts_min_order_by
}

"""
input type for inserting array relation for remote table "employee_shifts"
"""
input employee_shifts_arr_rel_insert_input {
  data: [employee_shifts_insert_input!]!

  """upsert condition"""
  on_conflict: employee_shifts_on_conflict
}

"""
Boolean expression to filter rows from the table "employee_shifts". All fields are combined with a logical 'AND'.
"""
input employee_shifts_bool_exp {
  _and: [employee_shifts_bool_exp!]
  _not: employee_shifts_bool_exp
  _or: [employee_shifts_bool_exp!]
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  id: uuid_comparison_exp
  shift: shifts_bool_exp
  shit_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "employee_shifts"
"""
enum employee_shifts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employee_shifts_pkey
}

"""
input type for inserting data into table "employee_shifts"
"""
input employee_shifts_insert_input {
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  id: uuid
  shift: shifts_obj_rel_insert_input
  shit_id: uuid
}

"""aggregate max on columns"""
type employee_shifts_max_fields {
  employee_id: uuid
  id: uuid
  shit_id: uuid
}

"""
order by max() on columns of table "employee_shifts"
"""
input employee_shifts_max_order_by {
  employee_id: order_by
  id: order_by
  shit_id: order_by
}

"""aggregate min on columns"""
type employee_shifts_min_fields {
  employee_id: uuid
  id: uuid
  shit_id: uuid
}

"""
order by min() on columns of table "employee_shifts"
"""
input employee_shifts_min_order_by {
  employee_id: order_by
  id: order_by
  shit_id: order_by
}

"""
response of any mutation on the table "employee_shifts"
"""
type employee_shifts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employee_shifts!]!
}

"""
on_conflict condition type for table "employee_shifts"
"""
input employee_shifts_on_conflict {
  constraint: employee_shifts_constraint!
  update_columns: [employee_shifts_update_column!]! = []
  where: employee_shifts_bool_exp
}

"""Ordering options when selecting data from "employee_shifts"."""
input employee_shifts_order_by {
  employee: employees_order_by
  employee_id: order_by
  id: order_by
  shift: shifts_order_by
  shit_id: order_by
}

"""primary key columns input for table: employee_shifts"""
input employee_shifts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_shifts"
"""
enum employee_shifts_select_column {
  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  shit_id
}

"""
input type for updating data in table "employee_shifts"
"""
input employee_shifts_set_input {
  employee_id: uuid
  id: uuid
  shit_id: uuid
}

"""
Streaming cursor of the table "employee_shifts"
"""
input employee_shifts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employee_shifts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employee_shifts_stream_cursor_value_input {
  employee_id: uuid
  id: uuid
  shit_id: uuid
}

"""
update columns of table "employee_shifts"
"""
enum employee_shifts_update_column {
  """column name"""
  employee_id

  """column name"""
  id

  """column name"""
  shit_id
}

input employee_shifts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employee_shifts_set_input

  """filter the rows which have to be updated"""
  where: employee_shifts_bool_exp!
}

type EmployeeAttendatceType {
  firstname: String!
  id: UUID!
  lastname: String!
}

type EmployeeCreationType {
  firstname: String!
  id: UUID!
  lastname: String!
  phoneNumber: String!
}

type EmployeeRole {
  createdAt: DateTime
  employeeId: UUID
  id: UUID
  role: RoleType!
  roleId: UUID
  updatedAt: DateTime
}

"""
columns and relationships of "employees"
"""
type employees {
  address: String

  """An object relationship"""
  agency: agencies
  agency_id: uuid

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!

  """An object relationship"""
  attendance: attendance

  """An object relationship"""
  attendance_new: attendance_new

  """An array relationship"""
  attendances(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """An aggregate relationship"""
  attendances_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): attendance_aggregate!

  """An object relationship"""
  company: companies
  company_id: uuid
  created_at: timestamptz
  date_of_birth: date

  """An object relationship"""
  department: departments!
  department_id: uuid!

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!
  email: String

  """An object relationship"""
  employee: employees

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!

  """An array relationship"""
  employee_roles(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An aggregate relationship"""
  employee_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): employee_roles_aggregate!

  """An array relationship"""
  employee_shifts(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An aggregate relationship"""
  employee_shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): employee_shifts_aggregate!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """An object relationship"""
  file: files
  firebase_token: String
  firstname: String!
  function: String!
  id: uuid!
  id_card_number: String
  lastname: String!

  """An array relationship"""
  leave_approvals(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """An aggregate relationship"""
  leave_approvals_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!
  license: String
  password: String!
  password_change_at: timestamp
  phone_number: String!

  """An object relationship"""
  position: positions
  position_id: uuid
  profile_picture: uuid
  region: String

  """An object relationship"""
  service: services
  service_id: uuid

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  status: status_enum

  """An object relationship"""
  statusByStatus: status
  supervisor_id: uuid
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "employees"
"""
type employees_aggregate {
  aggregate: employees_aggregate_fields
  nodes: [employees!]!
}

input employees_aggregate_bool_exp {
  count: employees_aggregate_bool_exp_count
}

input employees_aggregate_bool_exp_count {
  arguments: [employees_select_column!]
  distinct: Boolean
  filter: employees_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employees"
"""
type employees_aggregate_fields {
  count(columns: [employees_select_column!], distinct: Boolean): Int!
  max: employees_max_fields
  min: employees_min_fields
}

"""
order by aggregate values of table "employees"
"""
input employees_aggregate_order_by {
  count: order_by
  max: employees_max_order_by
  min: employees_min_order_by
}

"""
input type for inserting array relation for remote table "employees"
"""
input employees_arr_rel_insert_input {
  data: [employees_insert_input!]!

  """upsert condition"""
  on_conflict: employees_on_conflict
}

"""
Boolean expression to filter rows from the table "employees". All fields are combined with a logical 'AND'.
"""
input employees_bool_exp {
  _and: [employees_bool_exp!]
  _not: employees_bool_exp
  _or: [employees_bool_exp!]
  address: String_comparison_exp
  agency: agencies_bool_exp
  agency_id: uuid_comparison_exp
  appointments: appointments_bool_exp
  appointments_aggregate: appointments_aggregate_bool_exp
  attendance: attendance_bool_exp
  attendance_new: attendance_new_bool_exp
  attendances: attendance_bool_exp
  attendances_aggregate: attendance_aggregate_bool_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  date_of_birth: date_comparison_exp
  department: departments_bool_exp
  department_id: uuid_comparison_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  email: String_comparison_exp
  employee: employees_bool_exp
  employee_notifications: employee_notifications_bool_exp
  employee_notifications_aggregate: employee_notifications_aggregate_bool_exp
  employee_roles: employee_roles_bool_exp
  employee_roles_aggregate: employee_roles_aggregate_bool_exp
  employee_shifts: employee_shifts_bool_exp
  employee_shifts_aggregate: employee_shifts_aggregate_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  file: files_bool_exp
  firebase_token: String_comparison_exp
  firstname: String_comparison_exp
  function: String_comparison_exp
  id: uuid_comparison_exp
  id_card_number: String_comparison_exp
  lastname: String_comparison_exp
  leave_approvals: leave_approval_bool_exp
  leave_approvals_aggregate: leave_approval_aggregate_bool_exp
  leaves: leaves_bool_exp
  leaves_aggregate: leaves_aggregate_bool_exp
  license: String_comparison_exp
  password: String_comparison_exp
  password_change_at: timestamp_comparison_exp
  phone_number: String_comparison_exp
  position: positions_bool_exp
  position_id: uuid_comparison_exp
  profile_picture: uuid_comparison_exp
  region: String_comparison_exp
  service: services_bool_exp
  service_id: uuid_comparison_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  status: status_enum_comparison_exp
  statusByStatus: status_bool_exp
  supervisor_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "employees"
"""
enum employees_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  employees_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  employees_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  employees_pkey
}

"""
input type for inserting data into table "employees"
"""
input employees_insert_input {
  address: String
  agency: agencies_obj_rel_insert_input
  agency_id: uuid
  appointments: appointments_arr_rel_insert_input
  attendance: attendance_obj_rel_insert_input
  attendance_new: attendance_new_obj_rel_insert_input
  attendances: attendance_arr_rel_insert_input
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  date_of_birth: date
  department: departments_obj_rel_insert_input
  department_id: uuid
  departments: departments_arr_rel_insert_input
  email: String
  employee: employees_obj_rel_insert_input
  employee_notifications: employee_notifications_arr_rel_insert_input
  employee_roles: employee_roles_arr_rel_insert_input
  employee_shifts: employee_shifts_arr_rel_insert_input
  employees: employees_arr_rel_insert_input
  file: files_obj_rel_insert_input
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  leave_approvals: leave_approval_arr_rel_insert_input
  leaves: leaves_arr_rel_insert_input
  license: String
  password: String
  password_change_at: timestamp
  phone_number: String
  position: positions_obj_rel_insert_input
  position_id: uuid
  profile_picture: uuid
  region: String
  service: services_obj_rel_insert_input
  service_id: uuid
  services: services_arr_rel_insert_input
  status: status_enum
  statusByStatus: status_obj_rel_insert_input
  supervisor_id: uuid
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type employees_max_fields {
  address: String
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  date_of_birth: date
  department_id: uuid
  email: String
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  license: String
  password: String
  password_change_at: timestamp
  phone_number: String
  position_id: uuid
  profile_picture: uuid
  region: String
  service_id: uuid
  supervisor_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "employees"
"""
input employees_max_order_by {
  address: order_by
  agency_id: order_by
  company_id: order_by
  created_at: order_by
  date_of_birth: order_by
  department_id: order_by
  email: order_by
  firebase_token: order_by
  firstname: order_by
  function: order_by
  id: order_by
  id_card_number: order_by
  lastname: order_by
  license: order_by
  password: order_by
  password_change_at: order_by
  phone_number: order_by
  position_id: order_by
  profile_picture: order_by
  region: order_by
  service_id: order_by
  supervisor_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type employees_min_fields {
  address: String
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  date_of_birth: date
  department_id: uuid
  email: String
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  license: String
  password: String
  password_change_at: timestamp
  phone_number: String
  position_id: uuid
  profile_picture: uuid
  region: String
  service_id: uuid
  supervisor_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "employees"
"""
input employees_min_order_by {
  address: order_by
  agency_id: order_by
  company_id: order_by
  created_at: order_by
  date_of_birth: order_by
  department_id: order_by
  email: order_by
  firebase_token: order_by
  firstname: order_by
  function: order_by
  id: order_by
  id_card_number: order_by
  lastname: order_by
  license: order_by
  password: order_by
  password_change_at: order_by
  phone_number: order_by
  position_id: order_by
  profile_picture: order_by
  region: order_by
  service_id: order_by
  supervisor_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "employees"
"""
type employees_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employees!]!
}

"""
input type for inserting object relation for remote table "employees"
"""
input employees_obj_rel_insert_input {
  data: employees_insert_input!

  """upsert condition"""
  on_conflict: employees_on_conflict
}

"""
on_conflict condition type for table "employees"
"""
input employees_on_conflict {
  constraint: employees_constraint!
  update_columns: [employees_update_column!]! = []
  where: employees_bool_exp
}

"""Ordering options when selecting data from "employees"."""
input employees_order_by {
  address: order_by
  agency: agencies_order_by
  agency_id: order_by
  appointments_aggregate: appointments_aggregate_order_by
  attendance: attendance_order_by
  attendance_new: attendance_new_order_by
  attendances_aggregate: attendance_aggregate_order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  date_of_birth: order_by
  department: departments_order_by
  department_id: order_by
  departments_aggregate: departments_aggregate_order_by
  email: order_by
  employee: employees_order_by
  employee_notifications_aggregate: employee_notifications_aggregate_order_by
  employee_roles_aggregate: employee_roles_aggregate_order_by
  employee_shifts_aggregate: employee_shifts_aggregate_order_by
  employees_aggregate: employees_aggregate_order_by
  file: files_order_by
  firebase_token: order_by
  firstname: order_by
  function: order_by
  id: order_by
  id_card_number: order_by
  lastname: order_by
  leave_approvals_aggregate: leave_approval_aggregate_order_by
  leaves_aggregate: leaves_aggregate_order_by
  license: order_by
  password: order_by
  password_change_at: order_by
  phone_number: order_by
  position: positions_order_by
  position_id: order_by
  profile_picture: order_by
  region: order_by
  service: services_order_by
  service_id: order_by
  services_aggregate: services_aggregate_order_by
  status: order_by
  statusByStatus: status_order_by
  supervisor_id: order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: employees"""
input employees_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employees"
"""
enum employees_select_column {
  """column name"""
  address

  """column name"""
  agency_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  date_of_birth

  """column name"""
  department_id

  """column name"""
  email

  """column name"""
  firebase_token

  """column name"""
  firstname

  """column name"""
  function

  """column name"""
  id

  """column name"""
  id_card_number

  """column name"""
  lastname

  """column name"""
  license

  """column name"""
  password

  """column name"""
  password_change_at

  """column name"""
  phone_number

  """column name"""
  position_id

  """column name"""
  profile_picture

  """column name"""
  region

  """column name"""
  service_id

  """column name"""
  status

  """column name"""
  supervisor_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "employees"
"""
input employees_set_input {
  address: String
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  date_of_birth: date
  department_id: uuid
  email: String
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  license: String
  password: String
  password_change_at: timestamp
  phone_number: String
  position_id: uuid
  profile_picture: uuid
  region: String
  service_id: uuid
  status: status_enum
  supervisor_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "employees"
"""
input employees_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employees_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employees_stream_cursor_value_input {
  address: String
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  date_of_birth: date
  department_id: uuid
  email: String
  firebase_token: String
  firstname: String
  function: String
  id: uuid
  id_card_number: String
  lastname: String
  license: String
  password: String
  password_change_at: timestamp
  phone_number: String
  position_id: uuid
  profile_picture: uuid
  region: String
  service_id: uuid
  status: status_enum
  supervisor_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "employees"
"""
enum employees_update_column {
  """column name"""
  address

  """column name"""
  agency_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  date_of_birth

  """column name"""
  department_id

  """column name"""
  email

  """column name"""
  firebase_token

  """column name"""
  firstname

  """column name"""
  function

  """column name"""
  id

  """column name"""
  id_card_number

  """column name"""
  lastname

  """column name"""
  license

  """column name"""
  password

  """column name"""
  password_change_at

  """column name"""
  phone_number

  """column name"""
  position_id

  """column name"""
  profile_picture

  """column name"""
  region

  """column name"""
  service_id

  """column name"""
  status

  """column name"""
  supervisor_id

  """column name"""
  updated_at
}

input employees_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employees_set_input

  """filter the rows which have to be updated"""
  where: employees_bool_exp!
}

type EmployeeType {
  agencyId: UUID
  companyId: UUID
  createdAt: DateTime
  departmentId: UUID
  email: String
  firstname: String
  function: String
  id: UUID!
  lastname: String
  password: String
  phoneNumber: String
  position: PositionType
  positionId: UUID
  profilePicture: UUID
  roles: [EmployeeRole!]
  serviceId: UUID
  supervisorId: UUID
  updatedAt: DateTime
}

type EmployeeUpdateType {
  address: String
  firstname: String
  id: UUID
  lastname: String
  phoneNumber: String
}

"""
columns and relationships of "files"
"""
type files {
  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  file_name: String
  file_size: float8
  file_url: String
  id: uuid!
  mime_type: String

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An array relationship"""
  visitorsByBackId(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitorsByBackId_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!

  """An array relationship"""
  visitorsByFrontId(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitorsByFrontId_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!
}

"""
aggregated selection of "files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

"""
aggregate fields of "files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""aggregate avg on columns"""
type files_avg_fields {
  file_size: Float
}

"""
Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  file_name: String_comparison_exp
  file_size: float8_comparison_exp
  file_url: String_comparison_exp
  id: uuid_comparison_exp
  mime_type: String_comparison_exp
  visitors: visitors_bool_exp
  visitorsByBackId: visitors_bool_exp
  visitorsByBackId_aggregate: visitors_aggregate_bool_exp
  visitorsByFrontId: visitors_bool_exp
  visitorsByFrontId_aggregate: visitors_aggregate_bool_exp
  visitors_aggregate: visitors_aggregate_bool_exp
}

"""
unique or primary key constraints on table "files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
input type for incrementing numeric columns in table "files"
"""
input files_inc_input {
  file_size: float8
}

"""
input type for inserting data into table "files"
"""
input files_insert_input {
  employees: employees_arr_rel_insert_input
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
  visitors: visitors_arr_rel_insert_input
  visitorsByBackId: visitors_arr_rel_insert_input
  visitorsByFrontId: visitors_arr_rel_insert_input
}

"""aggregate max on columns"""
type files_max_fields {
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
}

"""aggregate min on columns"""
type files_min_fields {
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
}

"""
response of any mutation on the table "files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
input type for inserting object relation for remote table "files"
"""
input files_obj_rel_insert_input {
  data: files_insert_input!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""
on_conflict condition type for table "files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "files"."""
input files_order_by {
  employees_aggregate: employees_aggregate_order_by
  file_name: order_by
  file_size: order_by
  file_url: order_by
  id: order_by
  mime_type: order_by
  visitorsByBackId_aggregate: visitors_aggregate_order_by
  visitorsByFrontId_aggregate: visitors_aggregate_order_by
  visitors_aggregate: visitors_aggregate_order_by
}

"""primary key columns input for table: files"""
input files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "files"
"""
enum files_select_column {
  """column name"""
  file_name

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  mime_type
}

"""
input type for updating data in table "files"
"""
input files_set_input {
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  file_size: Float
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  file_size: Float
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  file_size: Float
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  file_name: String
  file_size: float8
  file_url: String
  id: uuid
  mime_type: String
}

"""aggregate sum on columns"""
type files_sum_fields {
  file_size: float8
}

"""
update columns of table "files"
"""
enum files_update_column {
  """column name"""
  file_name

  """column name"""
  file_size

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  mime_type
}

input files_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input

  """filter the rows which have to be updated"""
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  file_size: Float
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  file_size: Float
}

"""aggregate variance on columns"""
type files_variance_fields {
  file_size: Float
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
columns and relationships of "gender"
"""
type gender {
  gender: String!

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!
}

"""
aggregated selection of "gender"
"""
type gender_aggregate {
  aggregate: gender_aggregate_fields
  nodes: [gender!]!
}

"""
aggregate fields of "gender"
"""
type gender_aggregate_fields {
  count(columns: [gender_select_column!], distinct: Boolean): Int!
  max: gender_max_fields
  min: gender_min_fields
}

"""
Boolean expression to filter rows from the table "gender". All fields are combined with a logical 'AND'.
"""
input gender_bool_exp {
  _and: [gender_bool_exp!]
  _not: gender_bool_exp
  _or: [gender_bool_exp!]
  gender: String_comparison_exp
  visitors: visitors_bool_exp
  visitors_aggregate: visitors_aggregate_bool_exp
}

"""
unique or primary key constraints on table "gender"
"""
enum gender_constraint {
  """
  unique or primary key constraint on columns "gender"
  """
  gender_pkey
}

enum gender_enum {
  FEMALE
  MALE
}

"""
Boolean expression to compare columns of type "gender_enum". All fields are combined with logical 'AND'.
"""
input gender_enum_comparison_exp {
  _eq: gender_enum
  _in: [gender_enum!]
  _is_null: Boolean
  _neq: gender_enum
  _nin: [gender_enum!]
}

"""
input type for inserting data into table "gender"
"""
input gender_insert_input {
  gender: String
  visitors: visitors_arr_rel_insert_input
}

"""aggregate max on columns"""
type gender_max_fields {
  gender: String
}

"""aggregate min on columns"""
type gender_min_fields {
  gender: String
}

"""
response of any mutation on the table "gender"
"""
type gender_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [gender!]!
}

"""
input type for inserting object relation for remote table "gender"
"""
input gender_obj_rel_insert_input {
  data: gender_insert_input!

  """upsert condition"""
  on_conflict: gender_on_conflict
}

"""
on_conflict condition type for table "gender"
"""
input gender_on_conflict {
  constraint: gender_constraint!
  update_columns: [gender_update_column!]! = []
  where: gender_bool_exp
}

"""Ordering options when selecting data from "gender"."""
input gender_order_by {
  gender: order_by
  visitors_aggregate: visitors_aggregate_order_by
}

"""primary key columns input for table: gender"""
input gender_pk_columns_input {
  gender: String!
}

"""
select columns of table "gender"
"""
enum gender_select_column {
  """column name"""
  gender
}

"""
input type for updating data in table "gender"
"""
input gender_set_input {
  gender: String
}

"""
Streaming cursor of the table "gender"
"""
input gender_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: gender_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input gender_stream_cursor_value_input {
  gender: String
}

"""
update columns of table "gender"
"""
enum gender_update_column {
  """column name"""
  gender
}

input gender_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: gender_set_input

  """filter the rows which have to be updated"""
  where: gender_bool_exp!
}

scalar geography

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"""
columns and relationships of "geography_columns"
"""
type geography_columns {
  coord_dimension: Int
  f_geography_column: name
  f_table_catalog: name
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""
aggregated selection of "geography_columns"
"""
type geography_columns_aggregate {
  aggregate: geography_columns_aggregate_fields
  nodes: [geography_columns!]!
}

"""
aggregate fields of "geography_columns"
"""
type geography_columns_aggregate_fields {
  avg: geography_columns_avg_fields
  count(columns: [geography_columns_select_column!], distinct: Boolean): Int!
  max: geography_columns_max_fields
  min: geography_columns_min_fields
  stddev: geography_columns_stddev_fields
  stddev_pop: geography_columns_stddev_pop_fields
  stddev_samp: geography_columns_stddev_samp_fields
  sum: geography_columns_sum_fields
  var_pop: geography_columns_var_pop_fields
  var_samp: geography_columns_var_samp_fields
  variance: geography_columns_variance_fields
}

"""aggregate avg on columns"""
type geography_columns_avg_fields {
  coord_dimension: Float
  srid: Float
}

"""
Boolean expression to filter rows from the table "geography_columns". All fields are combined with a logical 'AND'.
"""
input geography_columns_bool_exp {
  _and: [geography_columns_bool_exp!]
  _not: geography_columns_bool_exp
  _or: [geography_columns_bool_exp!]
  coord_dimension: Int_comparison_exp
  f_geography_column: name_comparison_exp
  f_table_catalog: name_comparison_exp
  f_table_name: name_comparison_exp
  f_table_schema: name_comparison_exp
  srid: Int_comparison_exp
  type: String_comparison_exp
}

"""aggregate max on columns"""
type geography_columns_max_fields {
  coord_dimension: Int
  srid: Int
  type: String
}

"""aggregate min on columns"""
type geography_columns_min_fields {
  coord_dimension: Int
  srid: Int
  type: String
}

"""Ordering options when selecting data from "geography_columns"."""
input geography_columns_order_by {
  coord_dimension: order_by
  f_geography_column: order_by
  f_table_catalog: order_by
  f_table_name: order_by
  f_table_schema: order_by
  srid: order_by
  type: order_by
}

"""
select columns of table "geography_columns"
"""
enum geography_columns_select_column {
  """column name"""
  coord_dimension

  """column name"""
  f_geography_column

  """column name"""
  f_table_catalog

  """column name"""
  f_table_name

  """column name"""
  f_table_schema

  """column name"""
  srid

  """column name"""
  type
}

"""aggregate stddev on columns"""
type geography_columns_stddev_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate stddev_pop on columns"""
type geography_columns_stddev_pop_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate stddev_samp on columns"""
type geography_columns_stddev_samp_fields {
  coord_dimension: Float
  srid: Float
}

"""
Streaming cursor of the table "geography_columns"
"""
input geography_columns_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: geography_columns_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input geography_columns_stream_cursor_value_input {
  coord_dimension: Int
  f_geography_column: name
  f_table_catalog: name
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""aggregate sum on columns"""
type geography_columns_sum_fields {
  coord_dimension: Int
  srid: Int
}

"""aggregate var_pop on columns"""
type geography_columns_var_pop_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate var_samp on columns"""
type geography_columns_var_samp_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate variance on columns"""
type geography_columns_variance_fields {
  coord_dimension: Float
  srid: Float
}

"""
Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'.
"""
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  """is the column within a given distance from the given geography value"""
  _st_d_within: st_d_within_geography_input

  """does the column spatially intersect the given geography value"""
  _st_intersects: geography
}

scalar geometry

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"""
columns and relationships of "geometry_columns"
"""
type geometry_columns {
  coord_dimension: Int
  f_geometry_column: name
  f_table_catalog: String
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""
aggregated selection of "geometry_columns"
"""
type geometry_columns_aggregate {
  aggregate: geometry_columns_aggregate_fields
  nodes: [geometry_columns!]!
}

"""
aggregate fields of "geometry_columns"
"""
type geometry_columns_aggregate_fields {
  avg: geometry_columns_avg_fields
  count(columns: [geometry_columns_select_column!], distinct: Boolean): Int!
  max: geometry_columns_max_fields
  min: geometry_columns_min_fields
  stddev: geometry_columns_stddev_fields
  stddev_pop: geometry_columns_stddev_pop_fields
  stddev_samp: geometry_columns_stddev_samp_fields
  sum: geometry_columns_sum_fields
  var_pop: geometry_columns_var_pop_fields
  var_samp: geometry_columns_var_samp_fields
  variance: geometry_columns_variance_fields
}

"""aggregate avg on columns"""
type geometry_columns_avg_fields {
  coord_dimension: Float
  srid: Float
}

"""
Boolean expression to filter rows from the table "geometry_columns". All fields are combined with a logical 'AND'.
"""
input geometry_columns_bool_exp {
  _and: [geometry_columns_bool_exp!]
  _not: geometry_columns_bool_exp
  _or: [geometry_columns_bool_exp!]
  coord_dimension: Int_comparison_exp
  f_geometry_column: name_comparison_exp
  f_table_catalog: String_comparison_exp
  f_table_name: name_comparison_exp
  f_table_schema: name_comparison_exp
  srid: Int_comparison_exp
  type: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "geometry_columns"
"""
input geometry_columns_inc_input {
  coord_dimension: Int
  srid: Int
}

"""
input type for inserting data into table "geometry_columns"
"""
input geometry_columns_insert_input {
  coord_dimension: Int
  f_geometry_column: name
  f_table_catalog: String
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""aggregate max on columns"""
type geometry_columns_max_fields {
  coord_dimension: Int
  f_table_catalog: String
  srid: Int
  type: String
}

"""aggregate min on columns"""
type geometry_columns_min_fields {
  coord_dimension: Int
  f_table_catalog: String
  srid: Int
  type: String
}

"""
response of any mutation on the table "geometry_columns"
"""
type geometry_columns_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [geometry_columns!]!
}

"""Ordering options when selecting data from "geometry_columns"."""
input geometry_columns_order_by {
  coord_dimension: order_by
  f_geometry_column: order_by
  f_table_catalog: order_by
  f_table_name: order_by
  f_table_schema: order_by
  srid: order_by
  type: order_by
}

"""
select columns of table "geometry_columns"
"""
enum geometry_columns_select_column {
  """column name"""
  coord_dimension

  """column name"""
  f_geometry_column

  """column name"""
  f_table_catalog

  """column name"""
  f_table_name

  """column name"""
  f_table_schema

  """column name"""
  srid

  """column name"""
  type
}

"""
input type for updating data in table "geometry_columns"
"""
input geometry_columns_set_input {
  coord_dimension: Int
  f_geometry_column: name
  f_table_catalog: String
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""aggregate stddev on columns"""
type geometry_columns_stddev_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate stddev_pop on columns"""
type geometry_columns_stddev_pop_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate stddev_samp on columns"""
type geometry_columns_stddev_samp_fields {
  coord_dimension: Float
  srid: Float
}

"""
Streaming cursor of the table "geometry_columns"
"""
input geometry_columns_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: geometry_columns_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input geometry_columns_stream_cursor_value_input {
  coord_dimension: Int
  f_geometry_column: name
  f_table_catalog: String
  f_table_name: name
  f_table_schema: name
  srid: Int
  type: String
}

"""aggregate sum on columns"""
type geometry_columns_sum_fields {
  coord_dimension: Int
  srid: Int
}

input geometry_columns_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: geometry_columns_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: geometry_columns_set_input

  """filter the rows which have to be updated"""
  where: geometry_columns_bool_exp!
}

"""aggregate var_pop on columns"""
type geometry_columns_var_pop_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate var_samp on columns"""
type geometry_columns_var_samp_fields {
  coord_dimension: Float
  srid: Float
}

"""aggregate variance on columns"""
type geometry_columns_variance_fields {
  coord_dimension: Float
  srid: Float
}

"""
Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'.
"""
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  """is the column within a given 3D distance from the given geometry value"""
  _st_3d_d_within: st_d_within_input

  """does the column spatially intersect the given geometry value in 3D"""
  _st_3d_intersects: geometry

  """does the column contain the given geometry value"""
  _st_contains: geometry

  """does the column cross the given geometry value"""
  _st_crosses: geometry

  """is the column within a given distance from the given geometry value"""
  _st_d_within: st_d_within_input

  """
  is the column equal to given geometry value (directionality is ignored)
  """
  _st_equals: geometry

  """does the column spatially intersect the given geometry value"""
  _st_intersects: geometry

  """
  does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  """
  _st_overlaps: geometry

  """
  does the column have atleast one point in common with the given geometry value
  """
  _st_touches: geometry

  """is the column contained in the given geometry value"""
  _st_within: geometry
}

"""get_attenance_monthly_all_employeeNative Query Arguments"""
input get_attenance_monthly_all_employee_arguments {
  company_id: uuid!
  froms: date!
  to: date!
}

type get_visitor_stat {
  day: numeric
  visits_per_day: bigint
}

"""
Boolean expression to filter rows from the logical model for "get_visitor_stat".
All fields are combined with a logical 'AND'.
"""
input get_visitor_stat_bool_exp_bool_exp {
  _and: [get_visitor_stat_bool_exp_bool_exp!]
  _not: get_visitor_stat_bool_exp_bool_exp
  _or: [get_visitor_stat_bool_exp_bool_exp!]
  day: numeric_comparison_exp
  visits_per_day: bigint_comparison_exp
}

enum get_visitor_stat_enum_name {
  """column name"""
  day

  """column name"""
  visits_per_day
}

"""Ordering options when selecting data from "get_visitor_stat"."""
input get_visitor_stat_order_by {
  day: order_by
  visits_per_day: order_by
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [Int!]

  """does the array contain the given value"""
  _contains: [Int!]
  _eq: [Int!]
  _gt: [Int!]
  _gte: [Int!]
  _in: [[Int!]!]
  _is_null: Boolean
  _lt: [Int!]
  _lte: [Int!]
  _neq: [Int!]
  _nin: [[Int!]!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar interval

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input interval_comparison_exp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _is_null: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

"""
columns and relationships of "leave_approval"
"""
type leave_approval {
  approval_status: leave_status_enum!
  approver_id: uuid
  comments: String
  created_at: timestamptz

  """An object relationship"""
  employee: employees
  id: uuid!

  """An object relationship"""
  leave: leaves
  leave_id: uuid

  """An object relationship"""
  leave_status: leave_status!
  updated_at: timestamptz
}

"""
aggregated selection of "leave_approval"
"""
type leave_approval_aggregate {
  aggregate: leave_approval_aggregate_fields
  nodes: [leave_approval!]!
}

input leave_approval_aggregate_bool_exp {
  count: leave_approval_aggregate_bool_exp_count
}

input leave_approval_aggregate_bool_exp_count {
  arguments: [leave_approval_select_column!]
  distinct: Boolean
  filter: leave_approval_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "leave_approval"
"""
type leave_approval_aggregate_fields {
  count(columns: [leave_approval_select_column!], distinct: Boolean): Int!
  max: leave_approval_max_fields
  min: leave_approval_min_fields
}

"""
order by aggregate values of table "leave_approval"
"""
input leave_approval_aggregate_order_by {
  count: order_by
  max: leave_approval_max_order_by
  min: leave_approval_min_order_by
}

"""
input type for inserting array relation for remote table "leave_approval"
"""
input leave_approval_arr_rel_insert_input {
  data: [leave_approval_insert_input!]!

  """upsert condition"""
  on_conflict: leave_approval_on_conflict
}

"""
Boolean expression to filter rows from the table "leave_approval". All fields are combined with a logical 'AND'.
"""
input leave_approval_bool_exp {
  _and: [leave_approval_bool_exp!]
  _not: leave_approval_bool_exp
  _or: [leave_approval_bool_exp!]
  approval_status: leave_status_enum_comparison_exp
  approver_id: uuid_comparison_exp
  comments: String_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  id: uuid_comparison_exp
  leave: leaves_bool_exp
  leave_id: uuid_comparison_exp
  leave_status: leave_status_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "leave_approval"
"""
enum leave_approval_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_approval_pkey
}

"""
input type for inserting data into table "leave_approval"
"""
input leave_approval_insert_input {
  approval_status: leave_status_enum
  approver_id: uuid
  comments: String
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  id: uuid
  leave: leaves_obj_rel_insert_input
  leave_id: uuid
  leave_status: leave_status_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type leave_approval_max_fields {
  approver_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  leave_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "leave_approval"
"""
input leave_approval_max_order_by {
  approver_id: order_by
  comments: order_by
  created_at: order_by
  id: order_by
  leave_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type leave_approval_min_fields {
  approver_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  leave_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "leave_approval"
"""
input leave_approval_min_order_by {
  approver_id: order_by
  comments: order_by
  created_at: order_by
  id: order_by
  leave_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "leave_approval"
"""
type leave_approval_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave_approval!]!
}

"""
on_conflict condition type for table "leave_approval"
"""
input leave_approval_on_conflict {
  constraint: leave_approval_constraint!
  update_columns: [leave_approval_update_column!]! = []
  where: leave_approval_bool_exp
}

"""Ordering options when selecting data from "leave_approval"."""
input leave_approval_order_by {
  approval_status: order_by
  approver_id: order_by
  comments: order_by
  created_at: order_by
  employee: employees_order_by
  id: order_by
  leave: leaves_order_by
  leave_id: order_by
  leave_status: leave_status_order_by
  updated_at: order_by
}

"""primary key columns input for table: leave_approval"""
input leave_approval_pk_columns_input {
  id: uuid!
}

"""
select columns of table "leave_approval"
"""
enum leave_approval_select_column {
  """column name"""
  approval_status

  """column name"""
  approver_id

  """column name"""
  comments

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  leave_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "leave_approval"
"""
input leave_approval_set_input {
  approval_status: leave_status_enum
  approver_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  leave_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "leave_approval"
"""
input leave_approval_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_approval_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_approval_stream_cursor_value_input {
  approval_status: leave_status_enum
  approver_id: uuid
  comments: String
  created_at: timestamptz
  id: uuid
  leave_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "leave_approval"
"""
enum leave_approval_update_column {
  """column name"""
  approval_status

  """column name"""
  approver_id

  """column name"""
  comments

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  leave_id

  """column name"""
  updated_at
}

input leave_approval_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_approval_set_input

  """filter the rows which have to be updated"""
  where: leave_approval_bool_exp!
}

"""
columns and relationships of "leave_status"
"""
type leave_status {
  """An array relationship"""
  leave_approvals(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """An aggregate relationship"""
  leave_approvals_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!
  status: String!
}

"""
aggregated selection of "leave_status"
"""
type leave_status_aggregate {
  aggregate: leave_status_aggregate_fields
  nodes: [leave_status!]!
}

"""
aggregate fields of "leave_status"
"""
type leave_status_aggregate_fields {
  count(columns: [leave_status_select_column!], distinct: Boolean): Int!
  max: leave_status_max_fields
  min: leave_status_min_fields
}

"""
Boolean expression to filter rows from the table "leave_status". All fields are combined with a logical 'AND'.
"""
input leave_status_bool_exp {
  _and: [leave_status_bool_exp!]
  _not: leave_status_bool_exp
  _or: [leave_status_bool_exp!]
  leave_approvals: leave_approval_bool_exp
  leave_approvals_aggregate: leave_approval_aggregate_bool_exp
  leaves: leaves_bool_exp
  leaves_aggregate: leaves_aggregate_bool_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "leave_status"
"""
enum leave_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  leave_status_pkey
}

enum leave_status_enum {
  ACCEPTED
  PENDING
  REJECTED
}

"""
Boolean expression to compare columns of type "leave_status_enum". All fields are combined with logical 'AND'.
"""
input leave_status_enum_comparison_exp {
  _eq: leave_status_enum
  _in: [leave_status_enum!]
  _is_null: Boolean
  _neq: leave_status_enum
  _nin: [leave_status_enum!]
}

"""
input type for inserting data into table "leave_status"
"""
input leave_status_insert_input {
  leave_approvals: leave_approval_arr_rel_insert_input
  leaves: leaves_arr_rel_insert_input
  status: String
}

"""aggregate max on columns"""
type leave_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type leave_status_min_fields {
  status: String
}

"""
response of any mutation on the table "leave_status"
"""
type leave_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave_status!]!
}

"""
input type for inserting object relation for remote table "leave_status"
"""
input leave_status_obj_rel_insert_input {
  data: leave_status_insert_input!

  """upsert condition"""
  on_conflict: leave_status_on_conflict
}

"""
on_conflict condition type for table "leave_status"
"""
input leave_status_on_conflict {
  constraint: leave_status_constraint!
  update_columns: [leave_status_update_column!]! = []
  where: leave_status_bool_exp
}

"""Ordering options when selecting data from "leave_status"."""
input leave_status_order_by {
  leave_approvals_aggregate: leave_approval_aggregate_order_by
  leaves_aggregate: leaves_aggregate_order_by
  status: order_by
}

"""primary key columns input for table: leave_status"""
input leave_status_pk_columns_input {
  status: String!
}

"""
select columns of table "leave_status"
"""
enum leave_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "leave_status"
"""
input leave_status_set_input {
  status: String
}

"""
Streaming cursor of the table "leave_status"
"""
input leave_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "leave_status"
"""
enum leave_status_update_column {
  """column name"""
  status
}

input leave_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_status_set_input

  """filter the rows which have to be updated"""
  where: leave_status_bool_exp!
}

"""
columns and relationships of "leave_type"
"""
type leave_type {
  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!
  type: String!
}

"""
aggregated selection of "leave_type"
"""
type leave_type_aggregate {
  aggregate: leave_type_aggregate_fields
  nodes: [leave_type!]!
}

"""
aggregate fields of "leave_type"
"""
type leave_type_aggregate_fields {
  count(columns: [leave_type_select_column!], distinct: Boolean): Int!
  max: leave_type_max_fields
  min: leave_type_min_fields
}

"""
Boolean expression to filter rows from the table "leave_type". All fields are combined with a logical 'AND'.
"""
input leave_type_bool_exp {
  _and: [leave_type_bool_exp!]
  _not: leave_type_bool_exp
  _or: [leave_type_bool_exp!]
  leaves: leaves_bool_exp
  leaves_aggregate: leaves_aggregate_bool_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "leave_type"
"""
enum leave_type_constraint {
  """
  unique or primary key constraint on columns "type"
  """
  leave_type_pkey
}

enum leave_type_enum {
  BEREAVEMENT
  EMERGENCY
  MATERNITY
  OTHER
  SICK
  VACATION
}

"""
Boolean expression to compare columns of type "leave_type_enum". All fields are combined with logical 'AND'.
"""
input leave_type_enum_comparison_exp {
  _eq: leave_type_enum
  _in: [leave_type_enum!]
  _is_null: Boolean
  _neq: leave_type_enum
  _nin: [leave_type_enum!]
}

"""
input type for inserting data into table "leave_type"
"""
input leave_type_insert_input {
  leaves: leaves_arr_rel_insert_input
  type: String
}

"""aggregate max on columns"""
type leave_type_max_fields {
  type: String
}

"""aggregate min on columns"""
type leave_type_min_fields {
  type: String
}

"""
response of any mutation on the table "leave_type"
"""
type leave_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave_type!]!
}

"""
input type for inserting object relation for remote table "leave_type"
"""
input leave_type_obj_rel_insert_input {
  data: leave_type_insert_input!

  """upsert condition"""
  on_conflict: leave_type_on_conflict
}

"""
on_conflict condition type for table "leave_type"
"""
input leave_type_on_conflict {
  constraint: leave_type_constraint!
  update_columns: [leave_type_update_column!]! = []
  where: leave_type_bool_exp
}

"""Ordering options when selecting data from "leave_type"."""
input leave_type_order_by {
  leaves_aggregate: leaves_aggregate_order_by
  type: order_by
}

"""primary key columns input for table: leave_type"""
input leave_type_pk_columns_input {
  type: String!
}

"""
select columns of table "leave_type"
"""
enum leave_type_select_column {
  """column name"""
  type
}

"""
input type for updating data in table "leave_type"
"""
input leave_type_set_input {
  type: String
}

"""
Streaming cursor of the table "leave_type"
"""
input leave_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_type_stream_cursor_value_input {
  type: String
}

"""
update columns of table "leave_type"
"""
enum leave_type_update_column {
  """column name"""
  type
}

input leave_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_type_set_input

  """filter the rows which have to be updated"""
  where: leave_type_bool_exp!
}

"""
columns and relationships of "leaves"
"""
type leaves {
  comment: String
  created_at: timestamptz

  """An object relationship"""
  employee: employees
  employee_id: uuid
  end_date: date!
  id: uuid!

  """An object relationship"""
  leaveTypeByLeaveType: leave_type!

  """An array relationship"""
  leave_approvals(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """An aggregate relationship"""
  leave_approvals_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """An object relationship"""
  leave_status: leave_status!
  leave_type: leave_type_enum!
  start_date: date!
  status: leave_status_enum!
  updated_at: timestamptz
}

"""
aggregated selection of "leaves"
"""
type leaves_aggregate {
  aggregate: leaves_aggregate_fields
  nodes: [leaves!]!
}

input leaves_aggregate_bool_exp {
  count: leaves_aggregate_bool_exp_count
}

input leaves_aggregate_bool_exp_count {
  arguments: [leaves_select_column!]
  distinct: Boolean
  filter: leaves_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "leaves"
"""
type leaves_aggregate_fields {
  count(columns: [leaves_select_column!], distinct: Boolean): Int!
  max: leaves_max_fields
  min: leaves_min_fields
}

"""
order by aggregate values of table "leaves"
"""
input leaves_aggregate_order_by {
  count: order_by
  max: leaves_max_order_by
  min: leaves_min_order_by
}

"""
input type for inserting array relation for remote table "leaves"
"""
input leaves_arr_rel_insert_input {
  data: [leaves_insert_input!]!

  """upsert condition"""
  on_conflict: leaves_on_conflict
}

"""
Boolean expression to filter rows from the table "leaves". All fields are combined with a logical 'AND'.
"""
input leaves_bool_exp {
  _and: [leaves_bool_exp!]
  _not: leaves_bool_exp
  _or: [leaves_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employee_id: uuid_comparison_exp
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  leaveTypeByLeaveType: leave_type_bool_exp
  leave_approvals: leave_approval_bool_exp
  leave_approvals_aggregate: leave_approval_aggregate_bool_exp
  leave_status: leave_status_bool_exp
  leave_type: leave_type_enum_comparison_exp
  start_date: date_comparison_exp
  status: leave_status_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "leaves"
"""
enum leaves_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leaves_pkey
}

"""
input type for inserting data into table "leaves"
"""
input leaves_insert_input {
  comment: String
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employee_id: uuid
  end_date: date
  id: uuid
  leaveTypeByLeaveType: leave_type_obj_rel_insert_input
  leave_approvals: leave_approval_arr_rel_insert_input
  leave_status: leave_status_obj_rel_insert_input
  leave_type: leave_type_enum
  start_date: date
  status: leave_status_enum
  updated_at: timestamptz
}

"""aggregate max on columns"""
type leaves_max_fields {
  comment: String
  created_at: timestamptz
  employee_id: uuid
  end_date: date
  id: uuid
  start_date: date
  updated_at: timestamptz
}

"""
order by max() on columns of table "leaves"
"""
input leaves_max_order_by {
  comment: order_by
  created_at: order_by
  employee_id: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type leaves_min_fields {
  comment: String
  created_at: timestamptz
  employee_id: uuid
  end_date: date
  id: uuid
  start_date: date
  updated_at: timestamptz
}

"""
order by min() on columns of table "leaves"
"""
input leaves_min_order_by {
  comment: order_by
  created_at: order_by
  employee_id: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "leaves"
"""
type leaves_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leaves!]!
}

"""
input type for inserting object relation for remote table "leaves"
"""
input leaves_obj_rel_insert_input {
  data: leaves_insert_input!

  """upsert condition"""
  on_conflict: leaves_on_conflict
}

"""
on_conflict condition type for table "leaves"
"""
input leaves_on_conflict {
  constraint: leaves_constraint!
  update_columns: [leaves_update_column!]! = []
  where: leaves_bool_exp
}

"""Ordering options when selecting data from "leaves"."""
input leaves_order_by {
  comment: order_by
  created_at: order_by
  employee: employees_order_by
  employee_id: order_by
  end_date: order_by
  id: order_by
  leaveTypeByLeaveType: leave_type_order_by
  leave_approvals_aggregate: leave_approval_aggregate_order_by
  leave_status: leave_status_order_by
  leave_type: order_by
  start_date: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: leaves"""
input leaves_pk_columns_input {
  id: uuid!
}

"""
select columns of table "leaves"
"""
enum leaves_select_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  leave_type

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "leaves"
"""
input leaves_set_input {
  comment: String
  created_at: timestamptz
  employee_id: uuid
  end_date: date
  id: uuid
  leave_type: leave_type_enum
  start_date: date
  status: leave_status_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "leaves"
"""
input leaves_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leaves_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leaves_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  employee_id: uuid
  end_date: date
  id: uuid
  leave_type: leave_type_enum
  start_date: date
  status: leave_status_enum
  updated_at: timestamptz
}

"""
update columns of table "leaves"
"""
enum leaves_update_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  employee_id

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  leave_type

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  updated_at
}

input leaves_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leaves_set_input

  """filter the rows which have to be updated"""
  where: leaves_bool_exp!
}

"""
columns and relationships of "locations"
"""
type locations {
  building_id: uuid
  created_at: timestamptz
  id: uuid!
  location: geometry
  name: String
  updated_at: timestamptz
}

"""
aggregated selection of "locations"
"""
type locations_aggregate {
  aggregate: locations_aggregate_fields
  nodes: [locations!]!
}

"""
aggregate fields of "locations"
"""
type locations_aggregate_fields {
  count(columns: [locations_select_column!], distinct: Boolean): Int!
  max: locations_max_fields
  min: locations_min_fields
}

"""
Boolean expression to filter rows from the table "locations". All fields are combined with a logical 'AND'.
"""
input locations_bool_exp {
  _and: [locations_bool_exp!]
  _not: locations_bool_exp
  _or: [locations_bool_exp!]
  building_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  location: geometry_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "locations"
"""
enum locations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  locations_pkey
}

"""
input type for inserting data into table "locations"
"""
input locations_insert_input {
  building_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type locations_max_fields {
  building_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type locations_min_fields {
  building_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "locations"
"""
type locations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [locations!]!
}

"""
on_conflict condition type for table "locations"
"""
input locations_on_conflict {
  constraint: locations_constraint!
  update_columns: [locations_update_column!]! = []
  where: locations_bool_exp
}

"""Ordering options when selecting data from "locations"."""
input locations_order_by {
  building_id: order_by
  created_at: order_by
  id: order_by
  location: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: locations"""
input locations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "locations"
"""
enum locations_select_column {
  """column name"""
  building_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "locations"
"""
input locations_set_input {
  building_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "locations"
"""
input locations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: locations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input locations_stream_cursor_value_input {
  building_id: uuid
  created_at: timestamptz
  id: uuid
  location: geometry
  name: String
  updated_at: timestamptz
}

"""
update columns of table "locations"
"""
enum locations_update_column {
  """column name"""
  building_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  location

  """column name"""
  name

  """column name"""
  updated_at
}

input locations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: locations_set_input

  """filter the rows which have to be updated"""
  where: locations_bool_exp!
}

type LoginReturnType {
  employee: EmployeeType!
  token: String!
}

"""mutation root"""
type mutation_root {
  createEmployee(employee: CreateEmployeeInput!): EmployeeCreationType!
  createVisitor(visitor: AddVisitorBrowserInputType!): CreateVisitorType!

  """
  delete data from the table: "agencies"
  """
  delete_agencies(
    """filter the rows which have to be deleted"""
    where: agencies_bool_exp!
  ): agencies_mutation_response

  """
  delete single row from the table: "agencies"
  """
  delete_agencies_by_pk(id: uuid!): agencies

  """
  delete data from the table: "alembic_version"
  """
  delete_alembic_version(
    """filter the rows which have to be deleted"""
    where: alembic_version_bool_exp!
  ): alembic_version_mutation_response

  """
  delete single row from the table: "alembic_version"
  """
  delete_alembic_version_by_pk(version_num: String!): alembic_version

  """
  delete data from the table: "app_versions"
  """
  delete_app_versions(
    """filter the rows which have to be deleted"""
    where: app_versions_bool_exp!
  ): app_versions_mutation_response

  """
  delete single row from the table: "app_versions"
  """
  delete_app_versions_by_pk(version: String!): app_versions

  """
  delete data from the table: "appointment_status"
  """
  delete_appointment_status(
    """filter the rows which have to be deleted"""
    where: appointment_status_bool_exp!
  ): appointment_status_mutation_response

  """
  delete single row from the table: "appointment_status"
  """
  delete_appointment_status_by_pk(status: String!): appointment_status

  """
  delete data from the table: "appointments"
  """
  delete_appointments(
    """filter the rows which have to be deleted"""
    where: appointments_bool_exp!
  ): appointments_mutation_response

  """
  delete single row from the table: "appointments"
  """
  delete_appointments_by_pk(id: uuid!): appointments

  """
  delete data from the table: "attendance"
  """
  delete_attendance(
    """filter the rows which have to be deleted"""
    where: attendance_bool_exp!
  ): attendance_mutation_response

  """
  delete single row from the table: "attendance"
  """
  delete_attendance_by_pk(id: uuid!): attendance

  """
  delete data from the table: "attendance_new"
  """
  delete_attendance_new(
    """filter the rows which have to be deleted"""
    where: attendance_new_bool_exp!
  ): attendance_new_mutation_response

  """
  delete single row from the table: "attendance_new"
  """
  delete_attendance_new_by_pk(id: uuid!): attendance_new

  """
  delete data from the table: "attendance_state"
  """
  delete_attendance_state(
    """filter the rows which have to be deleted"""
    where: attendance_state_bool_exp!
  ): attendance_state_mutation_response

  """
  delete single row from the table: "attendance_state"
  """
  delete_attendance_state_by_pk(id: uuid!): attendance_state

  """
  delete data from the table: "companies"
  """
  delete_companies(
    """filter the rows which have to be deleted"""
    where: companies_bool_exp!
  ): companies_mutation_response

  """
  delete single row from the table: "companies"
  """
  delete_companies_by_pk(id: uuid!): companies

  """
  delete data from the table: "company_settings"
  """
  delete_company_settings(
    """filter the rows which have to be deleted"""
    where: company_settings_bool_exp!
  ): company_settings_mutation_response

  """
  delete single row from the table: "company_settings"
  """
  delete_company_settings_by_pk(id: uuid!): company_settings

  """
  delete data from the table: "departments"
  """
  delete_departments(
    """filter the rows which have to be deleted"""
    where: departments_bool_exp!
  ): departments_mutation_response

  """
  delete single row from the table: "departments"
  """
  delete_departments_by_pk(id: uuid!): departments

  """
  delete data from the table: "employee_notifications"
  """
  delete_employee_notifications(
    """filter the rows which have to be deleted"""
    where: employee_notifications_bool_exp!
  ): employee_notifications_mutation_response

  """
  delete single row from the table: "employee_notifications"
  """
  delete_employee_notifications_by_pk(id: uuid!): employee_notifications

  """
  delete data from the table: "employee_roles"
  """
  delete_employee_roles(
    """filter the rows which have to be deleted"""
    where: employee_roles_bool_exp!
  ): employee_roles_mutation_response

  """
  delete single row from the table: "employee_roles"
  """
  delete_employee_roles_by_pk(id: uuid!): employee_roles

  """
  delete data from the table: "employee_shifts"
  """
  delete_employee_shifts(
    """filter the rows which have to be deleted"""
    where: employee_shifts_bool_exp!
  ): employee_shifts_mutation_response

  """
  delete single row from the table: "employee_shifts"
  """
  delete_employee_shifts_by_pk(id: uuid!): employee_shifts

  """
  delete data from the table: "employees"
  """
  delete_employees(
    """filter the rows which have to be deleted"""
    where: employees_bool_exp!
  ): employees_mutation_response

  """
  delete single row from the table: "employees"
  """
  delete_employees_by_pk(id: uuid!): employees

  """
  delete data from the table: "files"
  """
  delete_files(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "files"
  """
  delete_files_by_pk(id: uuid!): files

  """
  delete data from the table: "gender"
  """
  delete_gender(
    """filter the rows which have to be deleted"""
    where: gender_bool_exp!
  ): gender_mutation_response

  """
  delete single row from the table: "gender"
  """
  delete_gender_by_pk(gender: String!): gender

  """
  delete data from the table: "geometry_columns"
  """
  delete_geometry_columns(
    """filter the rows which have to be deleted"""
    where: geometry_columns_bool_exp!
  ): geometry_columns_mutation_response

  """
  delete data from the table: "leave_approval"
  """
  delete_leave_approval(
    """filter the rows which have to be deleted"""
    where: leave_approval_bool_exp!
  ): leave_approval_mutation_response

  """
  delete single row from the table: "leave_approval"
  """
  delete_leave_approval_by_pk(id: uuid!): leave_approval

  """
  delete data from the table: "leave_status"
  """
  delete_leave_status(
    """filter the rows which have to be deleted"""
    where: leave_status_bool_exp!
  ): leave_status_mutation_response

  """
  delete single row from the table: "leave_status"
  """
  delete_leave_status_by_pk(status: String!): leave_status

  """
  delete data from the table: "leave_type"
  """
  delete_leave_type(
    """filter the rows which have to be deleted"""
    where: leave_type_bool_exp!
  ): leave_type_mutation_response

  """
  delete single row from the table: "leave_type"
  """
  delete_leave_type_by_pk(type: String!): leave_type

  """
  delete data from the table: "leaves"
  """
  delete_leaves(
    """filter the rows which have to be deleted"""
    where: leaves_bool_exp!
  ): leaves_mutation_response

  """
  delete single row from the table: "leaves"
  """
  delete_leaves_by_pk(id: uuid!): leaves

  """
  delete data from the table: "locations"
  """
  delete_locations(
    """filter the rows which have to be deleted"""
    where: locations_bool_exp!
  ): locations_mutation_response

  """
  delete single row from the table: "locations"
  """
  delete_locations_by_pk(id: uuid!): locations

  """
  delete data from the table: "positions"
  """
  delete_positions(
    """filter the rows which have to be deleted"""
    where: positions_bool_exp!
  ): positions_mutation_response

  """
  delete single row from the table: "positions"
  """
  delete_positions_by_pk(id: uuid!): positions

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(id: uuid!): roles

  """
  delete data from the table: "services"
  """
  delete_services(
    """filter the rows which have to be deleted"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  delete single row from the table: "services"
  """
  delete_services_by_pk(id: uuid!): services

  """
  delete data from the table: "shifts"
  """
  delete_shifts(
    """filter the rows which have to be deleted"""
    where: shifts_bool_exp!
  ): shifts_mutation_response

  """
  delete single row from the table: "shifts"
  """
  delete_shifts_by_pk(id: uuid!): shifts

  """
  delete data from the table: "spatial_ref_sys"
  """
  delete_spatial_ref_sys(
    """filter the rows which have to be deleted"""
    where: spatial_ref_sys_bool_exp!
  ): spatial_ref_sys_mutation_response

  """
  delete single row from the table: "spatial_ref_sys"
  """
  delete_spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  """
  delete data from the table: "status"
  """
  delete_status(
    """filter the rows which have to be deleted"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  delete single row from the table: "status"
  """
  delete_status_by_pk(status: String!): status

  """
  delete data from the table: "text_content"
  """
  delete_text_content(
    """filter the rows which have to be deleted"""
    where: text_content_bool_exp!
  ): text_content_mutation_response

  """
  delete single row from the table: "text_content"
  """
  delete_text_content_by_pk(id: uuid!): text_content

  """
  delete data from the table: "translations"
  """
  delete_translations(
    """filter the rows which have to be deleted"""
    where: translations_bool_exp!
  ): translations_mutation_response

  """
  delete single row from the table: "translations"
  """
  delete_translations_by_pk(id: uuid!): translations

  """
  delete data from the table: "vehicles"
  """
  delete_vehicles(
    """filter the rows which have to be deleted"""
    where: vehicles_bool_exp!
  ): vehicles_mutation_response

  """
  delete single row from the table: "vehicles"
  """
  delete_vehicles_by_pk(id: uuid!): vehicles

  """
  delete data from the table: "visit_status"
  """
  delete_visit_status(
    """filter the rows which have to be deleted"""
    where: visit_status_bool_exp!
  ): visit_status_mutation_response

  """
  delete single row from the table: "visit_status"
  """
  delete_visit_status_by_pk(status: String!): visit_status

  """
  delete data from the table: "visitors"
  """
  delete_visitors(
    """filter the rows which have to be deleted"""
    where: visitors_bool_exp!
  ): visitors_mutation_response

  """
  delete single row from the table: "visitors"
  """
  delete_visitors_by_pk(id: uuid!): visitors

  """
  delete data from the table: "visits"
  """
  delete_visits(
    """filter the rows which have to be deleted"""
    where: visits_bool_exp!
  ): visits_mutation_response

  """
  delete single row from the table: "visits"
  """
  delete_visits_by_pk(id: uuid!): visits

  """
  insert data into the table: "agencies"
  """
  insert_agencies(
    """the rows to be inserted"""
    objects: [agencies_insert_input!]!

    """upsert condition"""
    on_conflict: agencies_on_conflict
  ): agencies_mutation_response

  """
  insert a single row into the table: "agencies"
  """
  insert_agencies_one(
    """the row to be inserted"""
    object: agencies_insert_input!

    """upsert condition"""
    on_conflict: agencies_on_conflict
  ): agencies

  """
  insert data into the table: "alembic_version"
  """
  insert_alembic_version(
    """the rows to be inserted"""
    objects: [alembic_version_insert_input!]!

    """upsert condition"""
    on_conflict: alembic_version_on_conflict
  ): alembic_version_mutation_response

  """
  insert a single row into the table: "alembic_version"
  """
  insert_alembic_version_one(
    """the row to be inserted"""
    object: alembic_version_insert_input!

    """upsert condition"""
    on_conflict: alembic_version_on_conflict
  ): alembic_version

  """
  insert data into the table: "app_versions"
  """
  insert_app_versions(
    """the rows to be inserted"""
    objects: [app_versions_insert_input!]!

    """upsert condition"""
    on_conflict: app_versions_on_conflict
  ): app_versions_mutation_response

  """
  insert a single row into the table: "app_versions"
  """
  insert_app_versions_one(
    """the row to be inserted"""
    object: app_versions_insert_input!

    """upsert condition"""
    on_conflict: app_versions_on_conflict
  ): app_versions

  """
  insert data into the table: "appointment_status"
  """
  insert_appointment_status(
    """the rows to be inserted"""
    objects: [appointment_status_insert_input!]!

    """upsert condition"""
    on_conflict: appointment_status_on_conflict
  ): appointment_status_mutation_response

  """
  insert a single row into the table: "appointment_status"
  """
  insert_appointment_status_one(
    """the row to be inserted"""
    object: appointment_status_insert_input!

    """upsert condition"""
    on_conflict: appointment_status_on_conflict
  ): appointment_status

  """
  insert data into the table: "appointments"
  """
  insert_appointments(
    """the rows to be inserted"""
    objects: [appointments_insert_input!]!

    """upsert condition"""
    on_conflict: appointments_on_conflict
  ): appointments_mutation_response

  """
  insert a single row into the table: "appointments"
  """
  insert_appointments_one(
    """the row to be inserted"""
    object: appointments_insert_input!

    """upsert condition"""
    on_conflict: appointments_on_conflict
  ): appointments

  """
  insert data into the table: "attendance"
  """
  insert_attendance(
    """the rows to be inserted"""
    objects: [attendance_insert_input!]!

    """upsert condition"""
    on_conflict: attendance_on_conflict
  ): attendance_mutation_response

  """
  insert data into the table: "attendance_new"
  """
  insert_attendance_new(
    """the rows to be inserted"""
    objects: [attendance_new_insert_input!]!

    """upsert condition"""
    on_conflict: attendance_new_on_conflict
  ): attendance_new_mutation_response

  """
  insert a single row into the table: "attendance_new"
  """
  insert_attendance_new_one(
    """the row to be inserted"""
    object: attendance_new_insert_input!

    """upsert condition"""
    on_conflict: attendance_new_on_conflict
  ): attendance_new

  """
  insert a single row into the table: "attendance"
  """
  insert_attendance_one(
    """the row to be inserted"""
    object: attendance_insert_input!

    """upsert condition"""
    on_conflict: attendance_on_conflict
  ): attendance

  """
  insert data into the table: "attendance_state"
  """
  insert_attendance_state(
    """the rows to be inserted"""
    objects: [attendance_state_insert_input!]!

    """upsert condition"""
    on_conflict: attendance_state_on_conflict
  ): attendance_state_mutation_response

  """
  insert a single row into the table: "attendance_state"
  """
  insert_attendance_state_one(
    """the row to be inserted"""
    object: attendance_state_insert_input!

    """upsert condition"""
    on_conflict: attendance_state_on_conflict
  ): attendance_state

  """
  insert data into the table: "companies"
  """
  insert_companies(
    """the rows to be inserted"""
    objects: [companies_insert_input!]!

    """upsert condition"""
    on_conflict: companies_on_conflict
  ): companies_mutation_response

  """
  insert a single row into the table: "companies"
  """
  insert_companies_one(
    """the row to be inserted"""
    object: companies_insert_input!

    """upsert condition"""
    on_conflict: companies_on_conflict
  ): companies

  """
  insert data into the table: "company_settings"
  """
  insert_company_settings(
    """the rows to be inserted"""
    objects: [company_settings_insert_input!]!

    """upsert condition"""
    on_conflict: company_settings_on_conflict
  ): company_settings_mutation_response

  """
  insert a single row into the table: "company_settings"
  """
  insert_company_settings_one(
    """the row to be inserted"""
    object: company_settings_insert_input!

    """upsert condition"""
    on_conflict: company_settings_on_conflict
  ): company_settings

  """
  insert data into the table: "departments"
  """
  insert_departments(
    """the rows to be inserted"""
    objects: [departments_insert_input!]!

    """upsert condition"""
    on_conflict: departments_on_conflict
  ): departments_mutation_response

  """
  insert a single row into the table: "departments"
  """
  insert_departments_one(
    """the row to be inserted"""
    object: departments_insert_input!

    """upsert condition"""
    on_conflict: departments_on_conflict
  ): departments

  """
  insert data into the table: "employee_notifications"
  """
  insert_employee_notifications(
    """the rows to be inserted"""
    objects: [employee_notifications_insert_input!]!

    """upsert condition"""
    on_conflict: employee_notifications_on_conflict
  ): employee_notifications_mutation_response

  """
  insert a single row into the table: "employee_notifications"
  """
  insert_employee_notifications_one(
    """the row to be inserted"""
    object: employee_notifications_insert_input!

    """upsert condition"""
    on_conflict: employee_notifications_on_conflict
  ): employee_notifications

  """
  insert data into the table: "employee_roles"
  """
  insert_employee_roles(
    """the rows to be inserted"""
    objects: [employee_roles_insert_input!]!

    """upsert condition"""
    on_conflict: employee_roles_on_conflict
  ): employee_roles_mutation_response

  """
  insert a single row into the table: "employee_roles"
  """
  insert_employee_roles_one(
    """the row to be inserted"""
    object: employee_roles_insert_input!

    """upsert condition"""
    on_conflict: employee_roles_on_conflict
  ): employee_roles

  """
  insert data into the table: "employee_shifts"
  """
  insert_employee_shifts(
    """the rows to be inserted"""
    objects: [employee_shifts_insert_input!]!

    """upsert condition"""
    on_conflict: employee_shifts_on_conflict
  ): employee_shifts_mutation_response

  """
  insert a single row into the table: "employee_shifts"
  """
  insert_employee_shifts_one(
    """the row to be inserted"""
    object: employee_shifts_insert_input!

    """upsert condition"""
    on_conflict: employee_shifts_on_conflict
  ): employee_shifts

  """
  insert data into the table: "employees"
  """
  insert_employees(
    """the rows to be inserted"""
    objects: [employees_insert_input!]!

    """upsert condition"""
    on_conflict: employees_on_conflict
  ): employees_mutation_response

  """
  insert a single row into the table: "employees"
  """
  insert_employees_one(
    """the row to be inserted"""
    object: employees_insert_input!

    """upsert condition"""
    on_conflict: employees_on_conflict
  ): employees

  """
  insert data into the table: "files"
  """
  insert_files(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "files"
  """
  insert_files_one(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "gender"
  """
  insert_gender(
    """the rows to be inserted"""
    objects: [gender_insert_input!]!

    """upsert condition"""
    on_conflict: gender_on_conflict
  ): gender_mutation_response

  """
  insert a single row into the table: "gender"
  """
  insert_gender_one(
    """the row to be inserted"""
    object: gender_insert_input!

    """upsert condition"""
    on_conflict: gender_on_conflict
  ): gender

  """
  insert data into the table: "geometry_columns"
  """
  insert_geometry_columns(
    """the rows to be inserted"""
    objects: [geometry_columns_insert_input!]!
  ): geometry_columns_mutation_response

  """
  insert a single row into the table: "geometry_columns"
  """
  insert_geometry_columns_one(
    """the row to be inserted"""
    object: geometry_columns_insert_input!
  ): geometry_columns

  """
  insert data into the table: "leave_approval"
  """
  insert_leave_approval(
    """the rows to be inserted"""
    objects: [leave_approval_insert_input!]!

    """upsert condition"""
    on_conflict: leave_approval_on_conflict
  ): leave_approval_mutation_response

  """
  insert a single row into the table: "leave_approval"
  """
  insert_leave_approval_one(
    """the row to be inserted"""
    object: leave_approval_insert_input!

    """upsert condition"""
    on_conflict: leave_approval_on_conflict
  ): leave_approval

  """
  insert data into the table: "leave_status"
  """
  insert_leave_status(
    """the rows to be inserted"""
    objects: [leave_status_insert_input!]!

    """upsert condition"""
    on_conflict: leave_status_on_conflict
  ): leave_status_mutation_response

  """
  insert a single row into the table: "leave_status"
  """
  insert_leave_status_one(
    """the row to be inserted"""
    object: leave_status_insert_input!

    """upsert condition"""
    on_conflict: leave_status_on_conflict
  ): leave_status

  """
  insert data into the table: "leave_type"
  """
  insert_leave_type(
    """the rows to be inserted"""
    objects: [leave_type_insert_input!]!

    """upsert condition"""
    on_conflict: leave_type_on_conflict
  ): leave_type_mutation_response

  """
  insert a single row into the table: "leave_type"
  """
  insert_leave_type_one(
    """the row to be inserted"""
    object: leave_type_insert_input!

    """upsert condition"""
    on_conflict: leave_type_on_conflict
  ): leave_type

  """
  insert data into the table: "leaves"
  """
  insert_leaves(
    """the rows to be inserted"""
    objects: [leaves_insert_input!]!

    """upsert condition"""
    on_conflict: leaves_on_conflict
  ): leaves_mutation_response

  """
  insert a single row into the table: "leaves"
  """
  insert_leaves_one(
    """the row to be inserted"""
    object: leaves_insert_input!

    """upsert condition"""
    on_conflict: leaves_on_conflict
  ): leaves

  """
  insert data into the table: "locations"
  """
  insert_locations(
    """the rows to be inserted"""
    objects: [locations_insert_input!]!

    """upsert condition"""
    on_conflict: locations_on_conflict
  ): locations_mutation_response

  """
  insert a single row into the table: "locations"
  """
  insert_locations_one(
    """the row to be inserted"""
    object: locations_insert_input!

    """upsert condition"""
    on_conflict: locations_on_conflict
  ): locations

  """
  insert data into the table: "positions"
  """
  insert_positions(
    """the rows to be inserted"""
    objects: [positions_insert_input!]!

    """upsert condition"""
    on_conflict: positions_on_conflict
  ): positions_mutation_response

  """
  insert a single row into the table: "positions"
  """
  insert_positions_one(
    """the row to be inserted"""
    object: positions_insert_input!

    """upsert condition"""
    on_conflict: positions_on_conflict
  ): positions

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "services"
  """
  insert_services(
    """the rows to be inserted"""
    objects: [services_insert_input!]!

    """upsert condition"""
    on_conflict: services_on_conflict
  ): services_mutation_response

  """
  insert a single row into the table: "services"
  """
  insert_services_one(
    """the row to be inserted"""
    object: services_insert_input!

    """upsert condition"""
    on_conflict: services_on_conflict
  ): services

  """
  insert data into the table: "shifts"
  """
  insert_shifts(
    """the rows to be inserted"""
    objects: [shifts_insert_input!]!

    """upsert condition"""
    on_conflict: shifts_on_conflict
  ): shifts_mutation_response

  """
  insert a single row into the table: "shifts"
  """
  insert_shifts_one(
    """the row to be inserted"""
    object: shifts_insert_input!

    """upsert condition"""
    on_conflict: shifts_on_conflict
  ): shifts

  """
  insert data into the table: "spatial_ref_sys"
  """
  insert_spatial_ref_sys(
    """the rows to be inserted"""
    objects: [spatial_ref_sys_insert_input!]!

    """upsert condition"""
    on_conflict: spatial_ref_sys_on_conflict
  ): spatial_ref_sys_mutation_response

  """
  insert a single row into the table: "spatial_ref_sys"
  """
  insert_spatial_ref_sys_one(
    """the row to be inserted"""
    object: spatial_ref_sys_insert_input!

    """upsert condition"""
    on_conflict: spatial_ref_sys_on_conflict
  ): spatial_ref_sys

  """
  insert data into the table: "status"
  """
  insert_status(
    """the rows to be inserted"""
    objects: [status_insert_input!]!

    """upsert condition"""
    on_conflict: status_on_conflict
  ): status_mutation_response

  """
  insert a single row into the table: "status"
  """
  insert_status_one(
    """the row to be inserted"""
    object: status_insert_input!

    """upsert condition"""
    on_conflict: status_on_conflict
  ): status

  """
  insert data into the table: "text_content"
  """
  insert_text_content(
    """the rows to be inserted"""
    objects: [text_content_insert_input!]!

    """upsert condition"""
    on_conflict: text_content_on_conflict
  ): text_content_mutation_response

  """
  insert a single row into the table: "text_content"
  """
  insert_text_content_one(
    """the row to be inserted"""
    object: text_content_insert_input!

    """upsert condition"""
    on_conflict: text_content_on_conflict
  ): text_content

  """
  insert data into the table: "translations"
  """
  insert_translations(
    """the rows to be inserted"""
    objects: [translations_insert_input!]!

    """upsert condition"""
    on_conflict: translations_on_conflict
  ): translations_mutation_response

  """
  insert a single row into the table: "translations"
  """
  insert_translations_one(
    """the row to be inserted"""
    object: translations_insert_input!

    """upsert condition"""
    on_conflict: translations_on_conflict
  ): translations

  """
  insert data into the table: "vehicles"
  """
  insert_vehicles(
    """the rows to be inserted"""
    objects: [vehicles_insert_input!]!

    """upsert condition"""
    on_conflict: vehicles_on_conflict
  ): vehicles_mutation_response

  """
  insert a single row into the table: "vehicles"
  """
  insert_vehicles_one(
    """the row to be inserted"""
    object: vehicles_insert_input!

    """upsert condition"""
    on_conflict: vehicles_on_conflict
  ): vehicles

  """
  insert data into the table: "visit_status"
  """
  insert_visit_status(
    """the rows to be inserted"""
    objects: [visit_status_insert_input!]!

    """upsert condition"""
    on_conflict: visit_status_on_conflict
  ): visit_status_mutation_response

  """
  insert a single row into the table: "visit_status"
  """
  insert_visit_status_one(
    """the row to be inserted"""
    object: visit_status_insert_input!

    """upsert condition"""
    on_conflict: visit_status_on_conflict
  ): visit_status

  """
  insert data into the table: "visitors"
  """
  insert_visitors(
    """the rows to be inserted"""
    objects: [visitors_insert_input!]!

    """upsert condition"""
    on_conflict: visitors_on_conflict
  ): visitors_mutation_response

  """
  insert a single row into the table: "visitors"
  """
  insert_visitors_one(
    """the row to be inserted"""
    object: visitors_insert_input!

    """upsert condition"""
    on_conflict: visitors_on_conflict
  ): visitors

  """
  insert data into the table: "visits"
  """
  insert_visits(
    """the rows to be inserted"""
    objects: [visits_insert_input!]!

    """upsert condition"""
    on_conflict: visits_on_conflict
  ): visits_mutation_response

  """
  insert a single row into the table: "visits"
  """
  insert_visits_one(
    """the row to be inserted"""
    object: visits_insert_input!

    """upsert condition"""
    on_conflict: visits_on_conflict
  ): visits
  updateEmployeePassword(employeeInfo: UpdatePasswordInputType!): UpdatePasswordOutputType!
  updateUserInfo(employee: UpdateEmployeeInput!): EmployeeUpdateType!

  """
  update data of the table: "agencies"
  """
  update_agencies(
    """sets the columns of the filtered rows to the given values"""
    _set: agencies_set_input

    """filter the rows which have to be updated"""
    where: agencies_bool_exp!
  ): agencies_mutation_response

  """
  update single row of the table: "agencies"
  """
  update_agencies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: agencies_set_input
    pk_columns: agencies_pk_columns_input!
  ): agencies

  """
  update multiples rows of table: "agencies"
  """
  update_agencies_many(
    """updates to execute, in order"""
    updates: [agencies_updates!]!
  ): [agencies_mutation_response]

  """
  update data of the table: "alembic_version"
  """
  update_alembic_version(
    """sets the columns of the filtered rows to the given values"""
    _set: alembic_version_set_input

    """filter the rows which have to be updated"""
    where: alembic_version_bool_exp!
  ): alembic_version_mutation_response

  """
  update single row of the table: "alembic_version"
  """
  update_alembic_version_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: alembic_version_set_input
    pk_columns: alembic_version_pk_columns_input!
  ): alembic_version

  """
  update multiples rows of table: "alembic_version"
  """
  update_alembic_version_many(
    """updates to execute, in order"""
    updates: [alembic_version_updates!]!
  ): [alembic_version_mutation_response]

  """
  update data of the table: "app_versions"
  """
  update_app_versions(
    """sets the columns of the filtered rows to the given values"""
    _set: app_versions_set_input

    """filter the rows which have to be updated"""
    where: app_versions_bool_exp!
  ): app_versions_mutation_response

  """
  update single row of the table: "app_versions"
  """
  update_app_versions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: app_versions_set_input
    pk_columns: app_versions_pk_columns_input!
  ): app_versions

  """
  update multiples rows of table: "app_versions"
  """
  update_app_versions_many(
    """updates to execute, in order"""
    updates: [app_versions_updates!]!
  ): [app_versions_mutation_response]

  """
  update data of the table: "appointment_status"
  """
  update_appointment_status(
    """sets the columns of the filtered rows to the given values"""
    _set: appointment_status_set_input

    """filter the rows which have to be updated"""
    where: appointment_status_bool_exp!
  ): appointment_status_mutation_response

  """
  update single row of the table: "appointment_status"
  """
  update_appointment_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: appointment_status_set_input
    pk_columns: appointment_status_pk_columns_input!
  ): appointment_status

  """
  update multiples rows of table: "appointment_status"
  """
  update_appointment_status_many(
    """updates to execute, in order"""
    updates: [appointment_status_updates!]!
  ): [appointment_status_mutation_response]

  """
  update data of the table: "appointments"
  """
  update_appointments(
    """sets the columns of the filtered rows to the given values"""
    _set: appointments_set_input

    """filter the rows which have to be updated"""
    where: appointments_bool_exp!
  ): appointments_mutation_response

  """
  update single row of the table: "appointments"
  """
  update_appointments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: appointments_set_input
    pk_columns: appointments_pk_columns_input!
  ): appointments

  """
  update multiples rows of table: "appointments"
  """
  update_appointments_many(
    """updates to execute, in order"""
    updates: [appointments_updates!]!
  ): [appointments_mutation_response]

  """
  update data of the table: "attendance"
  """
  update_attendance(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_set_input

    """filter the rows which have to be updated"""
    where: attendance_bool_exp!
  ): attendance_mutation_response

  """
  update single row of the table: "attendance"
  """
  update_attendance_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_set_input
    pk_columns: attendance_pk_columns_input!
  ): attendance

  """
  update multiples rows of table: "attendance"
  """
  update_attendance_many(
    """updates to execute, in order"""
    updates: [attendance_updates!]!
  ): [attendance_mutation_response]

  """
  update data of the table: "attendance_new"
  """
  update_attendance_new(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_new_set_input

    """filter the rows which have to be updated"""
    where: attendance_new_bool_exp!
  ): attendance_new_mutation_response

  """
  update single row of the table: "attendance_new"
  """
  update_attendance_new_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_new_set_input
    pk_columns: attendance_new_pk_columns_input!
  ): attendance_new

  """
  update multiples rows of table: "attendance_new"
  """
  update_attendance_new_many(
    """updates to execute, in order"""
    updates: [attendance_new_updates!]!
  ): [attendance_new_mutation_response]

  """
  update data of the table: "attendance_state"
  """
  update_attendance_state(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_state_set_input

    """filter the rows which have to be updated"""
    where: attendance_state_bool_exp!
  ): attendance_state_mutation_response

  """
  update single row of the table: "attendance_state"
  """
  update_attendance_state_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attendance_state_set_input
    pk_columns: attendance_state_pk_columns_input!
  ): attendance_state

  """
  update multiples rows of table: "attendance_state"
  """
  update_attendance_state_many(
    """updates to execute, in order"""
    updates: [attendance_state_updates!]!
  ): [attendance_state_mutation_response]

  """
  update data of the table: "companies"
  """
  update_companies(
    """sets the columns of the filtered rows to the given values"""
    _set: companies_set_input

    """filter the rows which have to be updated"""
    where: companies_bool_exp!
  ): companies_mutation_response

  """
  update single row of the table: "companies"
  """
  update_companies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: companies_set_input
    pk_columns: companies_pk_columns_input!
  ): companies

  """
  update multiples rows of table: "companies"
  """
  update_companies_many(
    """updates to execute, in order"""
    updates: [companies_updates!]!
  ): [companies_mutation_response]

  """
  update data of the table: "company_settings"
  """
  update_company_settings(
    """increments the numeric columns with given value of the filtered values"""
    _inc: company_settings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: company_settings_set_input

    """filter the rows which have to be updated"""
    where: company_settings_bool_exp!
  ): company_settings_mutation_response

  """
  update single row of the table: "company_settings"
  """
  update_company_settings_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: company_settings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: company_settings_set_input
    pk_columns: company_settings_pk_columns_input!
  ): company_settings

  """
  update multiples rows of table: "company_settings"
  """
  update_company_settings_many(
    """updates to execute, in order"""
    updates: [company_settings_updates!]!
  ): [company_settings_mutation_response]

  """
  update data of the table: "departments"
  """
  update_departments(
    """sets the columns of the filtered rows to the given values"""
    _set: departments_set_input

    """filter the rows which have to be updated"""
    where: departments_bool_exp!
  ): departments_mutation_response

  """
  update single row of the table: "departments"
  """
  update_departments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: departments_set_input
    pk_columns: departments_pk_columns_input!
  ): departments

  """
  update multiples rows of table: "departments"
  """
  update_departments_many(
    """updates to execute, in order"""
    updates: [departments_updates!]!
  ): [departments_mutation_response]

  """
  update data of the table: "employee_notifications"
  """
  update_employee_notifications(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_notifications_set_input

    """filter the rows which have to be updated"""
    where: employee_notifications_bool_exp!
  ): employee_notifications_mutation_response

  """
  update single row of the table: "employee_notifications"
  """
  update_employee_notifications_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_notifications_set_input
    pk_columns: employee_notifications_pk_columns_input!
  ): employee_notifications

  """
  update multiples rows of table: "employee_notifications"
  """
  update_employee_notifications_many(
    """updates to execute, in order"""
    updates: [employee_notifications_updates!]!
  ): [employee_notifications_mutation_response]

  """
  update data of the table: "employee_roles"
  """
  update_employee_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_roles_set_input

    """filter the rows which have to be updated"""
    where: employee_roles_bool_exp!
  ): employee_roles_mutation_response

  """
  update single row of the table: "employee_roles"
  """
  update_employee_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_roles_set_input
    pk_columns: employee_roles_pk_columns_input!
  ): employee_roles

  """
  update multiples rows of table: "employee_roles"
  """
  update_employee_roles_many(
    """updates to execute, in order"""
    updates: [employee_roles_updates!]!
  ): [employee_roles_mutation_response]

  """
  update data of the table: "employee_shifts"
  """
  update_employee_shifts(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_shifts_set_input

    """filter the rows which have to be updated"""
    where: employee_shifts_bool_exp!
  ): employee_shifts_mutation_response

  """
  update single row of the table: "employee_shifts"
  """
  update_employee_shifts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employee_shifts_set_input
    pk_columns: employee_shifts_pk_columns_input!
  ): employee_shifts

  """
  update multiples rows of table: "employee_shifts"
  """
  update_employee_shifts_many(
    """updates to execute, in order"""
    updates: [employee_shifts_updates!]!
  ): [employee_shifts_mutation_response]

  """
  update data of the table: "employees"
  """
  update_employees(
    """sets the columns of the filtered rows to the given values"""
    _set: employees_set_input

    """filter the rows which have to be updated"""
    where: employees_bool_exp!
  ): employees_mutation_response

  """
  update single row of the table: "employees"
  """
  update_employees_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employees_set_input
    pk_columns: employees_pk_columns_input!
  ): employees

  """
  update multiples rows of table: "employees"
  """
  update_employees_many(
    """updates to execute, in order"""
    updates: [employees_updates!]!
  ): [employees_mutation_response]

  """
  update data of the table: "files"
  """
  update_files(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "files"
  """
  update_files_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update multiples rows of table: "files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "gender"
  """
  update_gender(
    """sets the columns of the filtered rows to the given values"""
    _set: gender_set_input

    """filter the rows which have to be updated"""
    where: gender_bool_exp!
  ): gender_mutation_response

  """
  update single row of the table: "gender"
  """
  update_gender_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: gender_set_input
    pk_columns: gender_pk_columns_input!
  ): gender

  """
  update multiples rows of table: "gender"
  """
  update_gender_many(
    """updates to execute, in order"""
    updates: [gender_updates!]!
  ): [gender_mutation_response]

  """
  update data of the table: "geometry_columns"
  """
  update_geometry_columns(
    """increments the numeric columns with given value of the filtered values"""
    _inc: geometry_columns_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: geometry_columns_set_input

    """filter the rows which have to be updated"""
    where: geometry_columns_bool_exp!
  ): geometry_columns_mutation_response

  """
  update multiples rows of table: "geometry_columns"
  """
  update_geometry_columns_many(
    """updates to execute, in order"""
    updates: [geometry_columns_updates!]!
  ): [geometry_columns_mutation_response]

  """
  update data of the table: "leave_approval"
  """
  update_leave_approval(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_approval_set_input

    """filter the rows which have to be updated"""
    where: leave_approval_bool_exp!
  ): leave_approval_mutation_response

  """
  update single row of the table: "leave_approval"
  """
  update_leave_approval_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_approval_set_input
    pk_columns: leave_approval_pk_columns_input!
  ): leave_approval

  """
  update multiples rows of table: "leave_approval"
  """
  update_leave_approval_many(
    """updates to execute, in order"""
    updates: [leave_approval_updates!]!
  ): [leave_approval_mutation_response]

  """
  update data of the table: "leave_status"
  """
  update_leave_status(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_status_set_input

    """filter the rows which have to be updated"""
    where: leave_status_bool_exp!
  ): leave_status_mutation_response

  """
  update single row of the table: "leave_status"
  """
  update_leave_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_status_set_input
    pk_columns: leave_status_pk_columns_input!
  ): leave_status

  """
  update multiples rows of table: "leave_status"
  """
  update_leave_status_many(
    """updates to execute, in order"""
    updates: [leave_status_updates!]!
  ): [leave_status_mutation_response]

  """
  update data of the table: "leave_type"
  """
  update_leave_type(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_type_set_input

    """filter the rows which have to be updated"""
    where: leave_type_bool_exp!
  ): leave_type_mutation_response

  """
  update single row of the table: "leave_type"
  """
  update_leave_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_type_set_input
    pk_columns: leave_type_pk_columns_input!
  ): leave_type

  """
  update multiples rows of table: "leave_type"
  """
  update_leave_type_many(
    """updates to execute, in order"""
    updates: [leave_type_updates!]!
  ): [leave_type_mutation_response]

  """
  update data of the table: "leaves"
  """
  update_leaves(
    """sets the columns of the filtered rows to the given values"""
    _set: leaves_set_input

    """filter the rows which have to be updated"""
    where: leaves_bool_exp!
  ): leaves_mutation_response

  """
  update single row of the table: "leaves"
  """
  update_leaves_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leaves_set_input
    pk_columns: leaves_pk_columns_input!
  ): leaves

  """
  update multiples rows of table: "leaves"
  """
  update_leaves_many(
    """updates to execute, in order"""
    updates: [leaves_updates!]!
  ): [leaves_mutation_response]

  """
  update data of the table: "locations"
  """
  update_locations(
    """sets the columns of the filtered rows to the given values"""
    _set: locations_set_input

    """filter the rows which have to be updated"""
    where: locations_bool_exp!
  ): locations_mutation_response

  """
  update single row of the table: "locations"
  """
  update_locations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: locations_set_input
    pk_columns: locations_pk_columns_input!
  ): locations

  """
  update multiples rows of table: "locations"
  """
  update_locations_many(
    """updates to execute, in order"""
    updates: [locations_updates!]!
  ): [locations_mutation_response]

  """
  update data of the table: "positions"
  """
  update_positions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: positions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: positions_set_input

    """filter the rows which have to be updated"""
    where: positions_bool_exp!
  ): positions_mutation_response

  """
  update single row of the table: "positions"
  """
  update_positions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: positions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: positions_set_input
    pk_columns: positions_pk_columns_input!
  ): positions

  """
  update multiples rows of table: "positions"
  """
  update_positions_many(
    """updates to execute, in order"""
    updates: [positions_updates!]!
  ): [positions_mutation_response]

  """
  update data of the table: "roles"
  """
  update_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update multiples rows of table: "roles"
  """
  update_roles_many(
    """updates to execute, in order"""
    updates: [roles_updates!]!
  ): [roles_mutation_response]

  """
  update data of the table: "services"
  """
  update_services(
    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input

    """filter the rows which have to be updated"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  update single row of the table: "services"
  """
  update_services_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input
    pk_columns: services_pk_columns_input!
  ): services

  """
  update multiples rows of table: "services"
  """
  update_services_many(
    """updates to execute, in order"""
    updates: [services_updates!]!
  ): [services_mutation_response]

  """
  update data of the table: "shifts"
  """
  update_shifts(
    """sets the columns of the filtered rows to the given values"""
    _set: shifts_set_input

    """filter the rows which have to be updated"""
    where: shifts_bool_exp!
  ): shifts_mutation_response

  """
  update single row of the table: "shifts"
  """
  update_shifts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: shifts_set_input
    pk_columns: shifts_pk_columns_input!
  ): shifts

  """
  update multiples rows of table: "shifts"
  """
  update_shifts_many(
    """updates to execute, in order"""
    updates: [shifts_updates!]!
  ): [shifts_mutation_response]

  """
  update data of the table: "spatial_ref_sys"
  """
  update_spatial_ref_sys(
    """increments the numeric columns with given value of the filtered values"""
    _inc: spatial_ref_sys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: spatial_ref_sys_set_input

    """filter the rows which have to be updated"""
    where: spatial_ref_sys_bool_exp!
  ): spatial_ref_sys_mutation_response

  """
  update single row of the table: "spatial_ref_sys"
  """
  update_spatial_ref_sys_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: spatial_ref_sys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: spatial_ref_sys_set_input
    pk_columns: spatial_ref_sys_pk_columns_input!
  ): spatial_ref_sys

  """
  update multiples rows of table: "spatial_ref_sys"
  """
  update_spatial_ref_sys_many(
    """updates to execute, in order"""
    updates: [spatial_ref_sys_updates!]!
  ): [spatial_ref_sys_mutation_response]

  """
  update data of the table: "status"
  """
  update_status(
    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input

    """filter the rows which have to be updated"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  update single row of the table: "status"
  """
  update_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input
    pk_columns: status_pk_columns_input!
  ): status

  """
  update multiples rows of table: "status"
  """
  update_status_many(
    """updates to execute, in order"""
    updates: [status_updates!]!
  ): [status_mutation_response]

  """
  update data of the table: "text_content"
  """
  update_text_content(
    """sets the columns of the filtered rows to the given values"""
    _set: text_content_set_input

    """filter the rows which have to be updated"""
    where: text_content_bool_exp!
  ): text_content_mutation_response

  """
  update single row of the table: "text_content"
  """
  update_text_content_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: text_content_set_input
    pk_columns: text_content_pk_columns_input!
  ): text_content

  """
  update multiples rows of table: "text_content"
  """
  update_text_content_many(
    """updates to execute, in order"""
    updates: [text_content_updates!]!
  ): [text_content_mutation_response]

  """
  update data of the table: "translations"
  """
  update_translations(
    """sets the columns of the filtered rows to the given values"""
    _set: translations_set_input

    """filter the rows which have to be updated"""
    where: translations_bool_exp!
  ): translations_mutation_response

  """
  update single row of the table: "translations"
  """
  update_translations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: translations_set_input
    pk_columns: translations_pk_columns_input!
  ): translations

  """
  update multiples rows of table: "translations"
  """
  update_translations_many(
    """updates to execute, in order"""
    updates: [translations_updates!]!
  ): [translations_mutation_response]

  """
  update data of the table: "vehicles"
  """
  update_vehicles(
    """sets the columns of the filtered rows to the given values"""
    _set: vehicles_set_input

    """filter the rows which have to be updated"""
    where: vehicles_bool_exp!
  ): vehicles_mutation_response

  """
  update single row of the table: "vehicles"
  """
  update_vehicles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: vehicles_set_input
    pk_columns: vehicles_pk_columns_input!
  ): vehicles

  """
  update multiples rows of table: "vehicles"
  """
  update_vehicles_many(
    """updates to execute, in order"""
    updates: [vehicles_updates!]!
  ): [vehicles_mutation_response]

  """
  update data of the table: "visit_status"
  """
  update_visit_status(
    """sets the columns of the filtered rows to the given values"""
    _set: visit_status_set_input

    """filter the rows which have to be updated"""
    where: visit_status_bool_exp!
  ): visit_status_mutation_response

  """
  update single row of the table: "visit_status"
  """
  update_visit_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: visit_status_set_input
    pk_columns: visit_status_pk_columns_input!
  ): visit_status

  """
  update multiples rows of table: "visit_status"
  """
  update_visit_status_many(
    """updates to execute, in order"""
    updates: [visit_status_updates!]!
  ): [visit_status_mutation_response]

  """
  update data of the table: "visitors"
  """
  update_visitors(
    """sets the columns of the filtered rows to the given values"""
    _set: visitors_set_input

    """filter the rows which have to be updated"""
    where: visitors_bool_exp!
  ): visitors_mutation_response

  """
  update single row of the table: "visitors"
  """
  update_visitors_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: visitors_set_input
    pk_columns: visitors_pk_columns_input!
  ): visitors

  """
  update multiples rows of table: "visitors"
  """
  update_visitors_many(
    """updates to execute, in order"""
    updates: [visitors_updates!]!
  ): [visitors_mutation_response]

  """
  update data of the table: "visits"
  """
  update_visits(
    """sets the columns of the filtered rows to the given values"""
    _set: visits_set_input

    """filter the rows which have to be updated"""
    where: visits_bool_exp!
  ): visits_mutation_response

  """
  update single row of the table: "visits"
  """
  update_visits_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: visits_set_input
    pk_columns: visits_pk_columns_input!
  ): visits

  """
  update multiples rows of table: "visits"
  """
  update_visits_many(
    """updates to execute, in order"""
    updates: [visits_updates!]!
  ): [visits_mutation_response]
}

scalar name

"""
Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'.
"""
input name_comparison_exp {
  _eq: name
  _gt: name
  _gte: name
  _in: [name!]
  _is_null: Boolean
  _lt: name
  _lte: name
  _neq: name
  _nin: [name!]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type percentage_count_visit {
  percentage_change: numeric
  today_visits: bigint
  yesterday_visits: bigint
}

"""
Boolean expression to filter rows from the logical model for
"percentage_count_visit". All fields are combined with a logical 'AND'.
"""
input percentage_count_visit_bool_exp_bool_exp {
  _and: [percentage_count_visit_bool_exp_bool_exp!]
  _not: percentage_count_visit_bool_exp_bool_exp
  _or: [percentage_count_visit_bool_exp_bool_exp!]
  percentage_change: numeric_comparison_exp
  today_visits: bigint_comparison_exp
  yesterday_visits: bigint_comparison_exp
}

enum percentage_count_visit_enum_name {
  """column name"""
  percentage_change

  """column name"""
  today_visits

  """column name"""
  yesterday_visits
}

"""Ordering options when selecting data from "percentage_count_visit"."""
input percentage_count_visit_order_by {
  percentage_change: order_by
  today_visits: order_by
  yesterday_visits: order_by
}

"""
columns and relationships of "positions"
"""
type positions {
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz

  """An object relationship"""
  employee: employees

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  level: Int
  name: uuid

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz
}

"""
aggregated selection of "positions"
"""
type positions_aggregate {
  aggregate: positions_aggregate_fields
  nodes: [positions!]!
}

input positions_aggregate_bool_exp {
  count: positions_aggregate_bool_exp_count
}

input positions_aggregate_bool_exp_count {
  arguments: [positions_select_column!]
  distinct: Boolean
  filter: positions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "positions"
"""
type positions_aggregate_fields {
  avg: positions_avg_fields
  count(columns: [positions_select_column!], distinct: Boolean): Int!
  max: positions_max_fields
  min: positions_min_fields
  stddev: positions_stddev_fields
  stddev_pop: positions_stddev_pop_fields
  stddev_samp: positions_stddev_samp_fields
  sum: positions_sum_fields
  var_pop: positions_var_pop_fields
  var_samp: positions_var_samp_fields
  variance: positions_variance_fields
}

"""
order by aggregate values of table "positions"
"""
input positions_aggregate_order_by {
  avg: positions_avg_order_by
  count: order_by
  max: positions_max_order_by
  min: positions_min_order_by
  stddev: positions_stddev_order_by
  stddev_pop: positions_stddev_pop_order_by
  stddev_samp: positions_stddev_samp_order_by
  sum: positions_sum_order_by
  var_pop: positions_var_pop_order_by
  var_samp: positions_var_samp_order_by
  variance: positions_variance_order_by
}

"""
input type for inserting array relation for remote table "positions"
"""
input positions_arr_rel_insert_input {
  data: [positions_insert_input!]!

  """upsert condition"""
  on_conflict: positions_on_conflict
}

"""aggregate avg on columns"""
type positions_avg_fields {
  level: Float
}

"""
order by avg() on columns of table "positions"
"""
input positions_avg_order_by {
  level: order_by
}

"""
Boolean expression to filter rows from the table "positions". All fields are combined with a logical 'AND'.
"""
input positions_bool_exp {
  _and: [positions_bool_exp!]
  _not: positions_bool_exp
  _or: [positions_bool_exp!]
  agency_id: uuid_comparison_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  employee: employees_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  level: Int_comparison_exp
  name: uuid_comparison_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "positions"
"""
enum positions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  positions_pkey
}

"""
input type for incrementing numeric columns in table "positions"
"""
input positions_inc_input {
  level: Int
}

"""
input type for inserting data into table "positions"
"""
input positions_insert_input {
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  employee: employees_obj_rel_insert_input
  employees: employees_arr_rel_insert_input
  id: uuid
  level: Int
  name: uuid
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type positions_max_fields {
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  level: Int
  name: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "positions"
"""
input positions_max_order_by {
  agency_id: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  level: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type positions_min_fields {
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  level: Int
  name: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "positions"
"""
input positions_min_order_by {
  agency_id: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  level: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "positions"
"""
type positions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [positions!]!
}

"""
input type for inserting object relation for remote table "positions"
"""
input positions_obj_rel_insert_input {
  data: positions_insert_input!

  """upsert condition"""
  on_conflict: positions_on_conflict
}

"""
on_conflict condition type for table "positions"
"""
input positions_on_conflict {
  constraint: positions_constraint!
  update_columns: [positions_update_column!]! = []
  where: positions_bool_exp
}

"""Ordering options when selecting data from "positions"."""
input positions_order_by {
  agency_id: order_by
  company_id: order_by
  created_at: order_by
  employee: employees_order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  level: order_by
  name: order_by
  text_content: text_content_order_by
  updated_at: order_by
}

"""primary key columns input for table: positions"""
input positions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "positions"
"""
enum positions_select_column {
  """column name"""
  agency_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  level

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "positions"
"""
input positions_set_input {
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  level: Int
  name: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type positions_stddev_fields {
  level: Float
}

"""
order by stddev() on columns of table "positions"
"""
input positions_stddev_order_by {
  level: order_by
}

"""aggregate stddev_pop on columns"""
type positions_stddev_pop_fields {
  level: Float
}

"""
order by stddev_pop() on columns of table "positions"
"""
input positions_stddev_pop_order_by {
  level: order_by
}

"""aggregate stddev_samp on columns"""
type positions_stddev_samp_fields {
  level: Float
}

"""
order by stddev_samp() on columns of table "positions"
"""
input positions_stddev_samp_order_by {
  level: order_by
}

"""
Streaming cursor of the table "positions"
"""
input positions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: positions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input positions_stream_cursor_value_input {
  agency_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
  level: Int
  name: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type positions_sum_fields {
  level: Int
}

"""
order by sum() on columns of table "positions"
"""
input positions_sum_order_by {
  level: order_by
}

"""
update columns of table "positions"
"""
enum positions_update_column {
  """column name"""
  agency_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  level

  """column name"""
  name

  """column name"""
  updated_at
}

input positions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: positions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: positions_set_input

  """filter the rows which have to be updated"""
  where: positions_bool_exp!
}

"""aggregate var_pop on columns"""
type positions_var_pop_fields {
  level: Float
}

"""
order by var_pop() on columns of table "positions"
"""
input positions_var_pop_order_by {
  level: order_by
}

"""aggregate var_samp on columns"""
type positions_var_samp_fields {
  level: Float
}

"""
order by var_samp() on columns of table "positions"
"""
input positions_var_samp_order_by {
  level: order_by
}

"""aggregate variance on columns"""
type positions_variance_fields {
  level: Float
}

"""
order by variance() on columns of table "positions"
"""
input positions_variance_order_by {
  level: order_by
}

type PositionType {
  id: UUID!
  level: Int!
}

type query_root {
  """An array relationship"""
  agencies(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An aggregate relationship"""
  agencies_aggregate(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): agencies_aggregate!

  """fetch data from the table: "agencies" using primary key columns"""
  agencies_by_pk(id: uuid!): agencies

  """
  fetch data from the table: "alembic_version"
  """
  alembic_version(
    """distinct select on columns"""
    distinct_on: [alembic_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alembic_version_order_by!]

    """filter the rows returned"""
    where: alembic_version_bool_exp
  ): [alembic_version!]!

  """
  fetch aggregated fields from the table: "alembic_version"
  """
  alembic_version_aggregate(
    """distinct select on columns"""
    distinct_on: [alembic_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alembic_version_order_by!]

    """filter the rows returned"""
    where: alembic_version_bool_exp
  ): alembic_version_aggregate!

  """fetch data from the table: "alembic_version" using primary key columns"""
  alembic_version_by_pk(version_num: String!): alembic_version

  """
  fetch data from the table: "app_versions"
  """
  app_versions(
    """distinct select on columns"""
    distinct_on: [app_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_versions_order_by!]

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): [app_versions!]!

  """
  fetch aggregated fields from the table: "app_versions"
  """
  app_versions_aggregate(
    """distinct select on columns"""
    distinct_on: [app_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_versions_order_by!]

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): app_versions_aggregate!

  """fetch data from the table: "app_versions" using primary key columns"""
  app_versions_by_pk(version: String!): app_versions

  """
  fetch data from the table: "appointment_status"
  """
  appointment_status(
    """distinct select on columns"""
    distinct_on: [appointment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_status_order_by!]

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): [appointment_status!]!

  """
  fetch aggregated fields from the table: "appointment_status"
  """
  appointment_status_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_status_order_by!]

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): appointment_status_aggregate!

  """
  fetch data from the table: "appointment_status" using primary key columns
  """
  appointment_status_by_pk(status: String!): appointment_status

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!

  """fetch data from the table: "appointments" using primary key columns"""
  appointments_by_pk(id: uuid!): appointments

  """
  fetch data from the table: "attendance"
  """
  attendance(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """
  fetch aggregated fields from the table: "attendance"
  """
  attendance_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): attendance_aggregate!

  """fetch data from the table: "attendance" using primary key columns"""
  attendance_by_pk(id: uuid!): attendance

  """
  fetch data from the table: "attendance_new"
  """
  attendance_new(
    """distinct select on columns"""
    distinct_on: [attendance_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_new_order_by!]

    """filter the rows returned"""
    where: attendance_new_bool_exp
  ): [attendance_new!]!

  """
  fetch aggregated fields from the table: "attendance_new"
  """
  attendance_new_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_new_order_by!]

    """filter the rows returned"""
    where: attendance_new_bool_exp
  ): attendance_new_aggregate!

  """fetch data from the table: "attendance_new" using primary key columns"""
  attendance_new_by_pk(id: uuid!): attendance_new

  """
  fetch data from the table: "attendance_state"
  """
  attendance_state(
    """distinct select on columns"""
    distinct_on: [attendance_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_state_order_by!]

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): [attendance_state!]!

  """
  fetch aggregated fields from the table: "attendance_state"
  """
  attendance_state_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_state_order_by!]

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): attendance_state_aggregate!

  """
  fetch data from the table: "attendance_state" using primary key columns
  """
  attendance_state_by_pk(id: uuid!): attendance_state

  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An aggregate relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!

  """fetch data from the table: "companies" using primary key columns"""
  companies_by_pk(id: uuid!): companies

  """An array relationship"""
  company_settings(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): [company_settings!]!

  """An aggregate relationship"""
  company_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): company_settings_aggregate!

  """
  fetch data from the table: "company_settings" using primary key columns
  """
  company_settings_by_pk(id: uuid!): company_settings

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """fetch data from the table: "departments" using primary key columns"""
  departments_by_pk(id: uuid!): departments

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!

  """
  fetch data from the table: "employee_notifications" using primary key columns
  """
  employee_notifications_by_pk(id: uuid!): employee_notifications

  """An array relationship"""
  employee_roles(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An aggregate relationship"""
  employee_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): employee_roles_aggregate!

  """fetch data from the table: "employee_roles" using primary key columns"""
  employee_roles_by_pk(id: uuid!): employee_roles

  """An array relationship"""
  employee_shifts(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An aggregate relationship"""
  employee_shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): employee_shifts_aggregate!

  """fetch data from the table: "employee_shifts" using primary key columns"""
  employee_shifts_by_pk(id: uuid!): employee_shifts

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """fetch data from the table: "employees" using primary key columns"""
  employees_by_pk(id: uuid!): employees

  """
  fetch data from the table: "files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: uuid!): files

  """
  fetch data from the table: "gender"
  """
  gender(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch aggregated fields from the table: "gender"
  """
  gender_aggregate(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): gender_aggregate!

  """fetch data from the table: "gender" using primary key columns"""
  gender_by_pk(gender: String!): gender

  """
  fetch data from the table: "geography_columns"
  """
  geography_columns(
    """distinct select on columns"""
    distinct_on: [geography_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geography_columns_order_by!]

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): [geography_columns!]!

  """
  fetch aggregated fields from the table: "geography_columns"
  """
  geography_columns_aggregate(
    """distinct select on columns"""
    distinct_on: [geography_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geography_columns_order_by!]

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): geography_columns_aggregate!

  """
  fetch data from the table: "geometry_columns"
  """
  geometry_columns(
    """distinct select on columns"""
    distinct_on: [geometry_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geometry_columns_order_by!]

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): [geometry_columns!]!

  """
  fetch aggregated fields from the table: "geometry_columns"
  """
  geometry_columns_aggregate(
    """distinct select on columns"""
    distinct_on: [geometry_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geometry_columns_order_by!]

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): geometry_columns_aggregate!
  getReportAttandance(input: AttendanceInpuType!): [DayAttendanceType!]!
  get_attenance_monthly(
    """distinct select on columns"""
    distinct_on: [clock_in_count_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clock_in_count_order_by!]

    """filter the rows returned"""
    where: clock_in_count_bool_exp_bool_exp
  ): [clock_in_count!]!
  get_attenance_monthly_all_employee(
    """get_attenance_monthly_all_employeeNative Query Arguments"""
    args: get_attenance_monthly_all_employee_arguments!

    """distinct select on columns"""
    distinct_on: [attendance_all_month_employee_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_all_month_employee_order_by!]

    """filter the rows returned"""
    where: attendance_all_month_employee_bool_exp_bool_exp
  ): [attendance_all_month_employee!]!
  get_attendance_weekly(
    """distinct select on columns"""
    distinct_on: [attendance_week_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_week_order_by!]

    """filter the rows returned"""
    where: attendance_week_bool_exp_bool_exp
  ): [attendance_week!]!
  get_visit_percentage_difference(
    """distinct select on columns"""
    distinct_on: [percentage_count_visit_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [percentage_count_visit_order_by!]

    """filter the rows returned"""
    where: percentage_count_visit_bool_exp_bool_exp
  ): [percentage_count_visit!]!
  get_visits_stat(
    """distinct select on columns"""
    distinct_on: [get_visitor_stat_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [get_visitor_stat_order_by!]

    """filter the rows returned"""
    where: get_visitor_stat_bool_exp_bool_exp
  ): [get_visitor_stat!]!

  """
  fetch data from the table: "leave_approval"
  """
  leave_approval(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """
  fetch aggregated fields from the table: "leave_approval"
  """
  leave_approval_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """fetch data from the table: "leave_approval" using primary key columns"""
  leave_approval_by_pk(id: uuid!): leave_approval

  """
  fetch data from the table: "leave_status"
  """
  leave_status(
    """distinct select on columns"""
    distinct_on: [leave_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_status_order_by!]

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): [leave_status!]!

  """
  fetch aggregated fields from the table: "leave_status"
  """
  leave_status_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_status_order_by!]

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): leave_status_aggregate!

  """fetch data from the table: "leave_status" using primary key columns"""
  leave_status_by_pk(status: String!): leave_status

  """
  fetch data from the table: "leave_type"
  """
  leave_type(
    """distinct select on columns"""
    distinct_on: [leave_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_type_order_by!]

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): [leave_type!]!

  """
  fetch aggregated fields from the table: "leave_type"
  """
  leave_type_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_type_order_by!]

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): leave_type_aggregate!

  """fetch data from the table: "leave_type" using primary key columns"""
  leave_type_by_pk(type: String!): leave_type

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!

  """fetch data from the table: "leaves" using primary key columns"""
  leaves_by_pk(id: uuid!): leaves

  """
  fetch data from the table: "locations"
  """
  locations(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """
  fetch aggregated fields from the table: "locations"
  """
  locations_aggregate(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): locations_aggregate!

  """fetch data from the table: "locations" using primary key columns"""
  locations_by_pk(id: uuid!): locations
  loginEmployee(firebaseToken: String = null, password: String!, phoneNumber: String!): LoginReturnType
  name: String!

  """An array relationship"""
  positions(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """An aggregate relationship"""
  positions_aggregate(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): positions_aggregate!

  """fetch data from the table: "positions" using primary key columns"""
  positions_by_pk(id: uuid!): positions

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(id: uuid!): services

  """
  fetch data from the table: "shifts"
  """
  shifts(
    """distinct select on columns"""
    distinct_on: [shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shifts_order_by!]

    """filter the rows returned"""
    where: shifts_bool_exp
  ): [shifts!]!

  """
  fetch aggregated fields from the table: "shifts"
  """
  shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shifts_order_by!]

    """filter the rows returned"""
    where: shifts_bool_exp
  ): shifts_aggregate!

  """fetch data from the table: "shifts" using primary key columns"""
  shifts_by_pk(id: uuid!): shifts

  """
  fetch data from the table: "spatial_ref_sys"
  """
  spatial_ref_sys(
    """distinct select on columns"""
    distinct_on: [spatial_ref_sys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [spatial_ref_sys_order_by!]

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): [spatial_ref_sys!]!

  """
  fetch aggregated fields from the table: "spatial_ref_sys"
  """
  spatial_ref_sys_aggregate(
    """distinct select on columns"""
    distinct_on: [spatial_ref_sys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [spatial_ref_sys_order_by!]

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): spatial_ref_sys_aggregate!

  """fetch data from the table: "spatial_ref_sys" using primary key columns"""
  spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(status: String!): status

  """
  fetch data from the table: "text_content"
  """
  text_content(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): [text_content!]!

  """
  fetch aggregated fields from the table: "text_content"
  """
  text_content_aggregate(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): text_content_aggregate!

  """fetch data from the table: "text_content" using primary key columns"""
  text_content_by_pk(id: uuid!): text_content

  """
  fetch data from the table: "translations"
  """
  translations(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): [translations!]!

  """
  fetch aggregated fields from the table: "translations"
  """
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): translations_aggregate!

  """fetch data from the table: "translations" using primary key columns"""
  translations_by_pk(id: uuid!): translations

  """
  fetch data from the table: "vehicles"
  """
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """
  fetch aggregated fields from the table: "vehicles"
  """
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!

  """fetch data from the table: "vehicles" using primary key columns"""
  vehicles_by_pk(id: uuid!): vehicles

  """
  fetch data from the table: "visit_status"
  """
  visit_status(
    """distinct select on columns"""
    distinct_on: [visit_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visit_status_order_by!]

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): [visit_status!]!

  """
  fetch aggregated fields from the table: "visit_status"
  """
  visit_status_aggregate(
    """distinct select on columns"""
    distinct_on: [visit_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visit_status_order_by!]

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): visit_status_aggregate!

  """fetch data from the table: "visit_status" using primary key columns"""
  visit_status_by_pk(status: String!): visit_status

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!

  """fetch data from the table: "visitors" using primary key columns"""
  visitors_by_pk(id: uuid!): visitors

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!

  """fetch data from the table: "visits" using primary key columns"""
  visits_by_pk(id: uuid!): visits
}

"""
columns and relationships of "roles"
"""
type roles {
  created_at: timestamptz

  """An array relationship"""
  employee_roles(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An aggregate relationship"""
  employee_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): employee_roles_aggregate!
  id: uuid!
  role_name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  count(columns: [roles_select_column!], distinct: Boolean): Int!
  max: roles_max_fields
  min: roles_min_fields
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  created_at: timestamptz_comparison_exp
  employee_roles: employee_roles_bool_exp
  employee_roles_aggregate: employee_roles_aggregate_bool_exp
  id: uuid_comparison_exp
  role_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey

  """
  unique or primary key constraint on columns "role_name"
  """
  roles_role_name_key
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  created_at: timestamptz
  employee_roles: employee_roles_arr_rel_insert_input
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type roles_max_fields {
  created_at: timestamptz
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type roles_min_fields {
  created_at: timestamptz
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input roles_obj_rel_insert_input {
  data: roles_insert_input!

  """upsert condition"""
  on_conflict: roles_on_conflict
}

"""
on_conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]! = []
  where: roles_bool_exp
}

"""Ordering options when selecting data from "roles"."""
input roles_order_by {
  created_at: order_by
  employee_roles_aggregate: employee_roles_aggregate_order_by
  id: order_by
  role_name: order_by
  updated_at: order_by
}

"""primary key columns input for table: roles"""
input roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role_name

  """column name"""
  updated_at
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  created_at: timestamptz
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "roles"
"""
input roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input roles_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  role_name: String
  updated_at: timestamptz
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role_name

  """column name"""
  updated_at
}

input roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: roles_set_input

  """filter the rows which have to be updated"""
  where: roles_bool_exp!
}

type RoleType {
  createdAt: DateTime
  id: UUID!
  roleName: String!
  updatedAt: DateTime
}

"""
columns and relationships of "services"
"""
type services {
  """An object relationship"""
  agency: agencies
  agency_id: uuid
  chief_service: uuid

  """An object relationship"""
  company: companies
  company_id: uuid
  created_at: timestamptz

  """An object relationship"""
  department: departments
  department_id: uuid

  """An object relationship"""
  employee: employees

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  id: uuid!
  name: uuid
  status: status_enum

  """An object relationship"""
  statusByStatus: status

  """An object relationship"""
  text_content: text_content
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "services"
"""
type services_aggregate {
  aggregate: services_aggregate_fields
  nodes: [services!]!
}

input services_aggregate_bool_exp {
  count: services_aggregate_bool_exp_count
}

input services_aggregate_bool_exp_count {
  arguments: [services_select_column!]
  distinct: Boolean
  filter: services_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "services"
"""
type services_aggregate_fields {
  count(columns: [services_select_column!], distinct: Boolean): Int!
  max: services_max_fields
  min: services_min_fields
}

"""
order by aggregate values of table "services"
"""
input services_aggregate_order_by {
  count: order_by
  max: services_max_order_by
  min: services_min_order_by
}

"""
input type for inserting array relation for remote table "services"
"""
input services_arr_rel_insert_input {
  data: [services_insert_input!]!

  """upsert condition"""
  on_conflict: services_on_conflict
}

"""
Boolean expression to filter rows from the table "services". All fields are combined with a logical 'AND'.
"""
input services_bool_exp {
  _and: [services_bool_exp!]
  _not: services_bool_exp
  _or: [services_bool_exp!]
  agency: agencies_bool_exp
  agency_id: uuid_comparison_exp
  chief_service: uuid_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  department: departments_bool_exp
  department_id: uuid_comparison_exp
  employee: employees_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  id: uuid_comparison_exp
  name: uuid_comparison_exp
  status: status_enum_comparison_exp
  statusByStatus: status_bool_exp
  text_content: text_content_bool_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "services"
"""
enum services_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  services_pkey
}

"""
input type for inserting data into table "services"
"""
input services_insert_input {
  agency: agencies_obj_rel_insert_input
  agency_id: uuid
  chief_service: uuid
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  department: departments_obj_rel_insert_input
  department_id: uuid
  employee: employees_obj_rel_insert_input
  employees: employees_arr_rel_insert_input
  id: uuid
  name: uuid
  status: status_enum
  statusByStatus: status_obj_rel_insert_input
  text_content: text_content_obj_rel_insert_input
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type services_max_fields {
  agency_id: uuid
  chief_service: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  id: uuid
  name: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "services"
"""
input services_max_order_by {
  agency_id: order_by
  chief_service: order_by
  company_id: order_by
  created_at: order_by
  department_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type services_min_fields {
  agency_id: uuid
  chief_service: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  id: uuid
  name: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "services"
"""
input services_min_order_by {
  agency_id: order_by
  chief_service: order_by
  company_id: order_by
  created_at: order_by
  department_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "services"
"""
type services_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [services!]!
}

"""
input type for inserting object relation for remote table "services"
"""
input services_obj_rel_insert_input {
  data: services_insert_input!

  """upsert condition"""
  on_conflict: services_on_conflict
}

"""
on_conflict condition type for table "services"
"""
input services_on_conflict {
  constraint: services_constraint!
  update_columns: [services_update_column!]! = []
  where: services_bool_exp
}

"""Ordering options when selecting data from "services"."""
input services_order_by {
  agency: agencies_order_by
  agency_id: order_by
  chief_service: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  department: departments_order_by
  department_id: order_by
  employee: employees_order_by
  employees_aggregate: employees_aggregate_order_by
  id: order_by
  name: order_by
  status: order_by
  statusByStatus: status_order_by
  text_content: text_content_order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: services"""
input services_pk_columns_input {
  id: uuid!
}

"""
select columns of table "services"
"""
enum services_select_column {
  """column name"""
  agency_id

  """column name"""
  chief_service

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  department_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "services"
"""
input services_set_input {
  agency_id: uuid
  chief_service: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  id: uuid
  name: uuid
  status: status_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "services"
"""
input services_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: services_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input services_stream_cursor_value_input {
  agency_id: uuid
  chief_service: uuid
  company_id: uuid
  created_at: timestamptz
  department_id: uuid
  id: uuid
  name: uuid
  status: status_enum
  updated_at: timestamptz
}

"""
update columns of table "services"
"""
enum services_update_column {
  """column name"""
  agency_id

  """column name"""
  chief_service

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  department_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  status

  """column name"""
  updated_at
}

input services_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: services_set_input

  """filter the rows which have to be updated"""
  where: services_bool_exp!
}

"""
columns and relationships of "shifts"
"""
type shifts {
  """An array relationship"""
  attendance_news(
    """distinct select on columns"""
    distinct_on: [attendance_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_new_order_by!]

    """filter the rows returned"""
    where: attendance_new_bool_exp
  ): [attendance_new!]!

  """An aggregate relationship"""
  attendance_news_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_new_order_by!]

    """filter the rows returned"""
    where: attendance_new_bool_exp
  ): attendance_new_aggregate!

  """An array relationship"""
  attendances(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """An aggregate relationship"""
  attendances_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): attendance_aggregate!

  """An array relationship"""
  employee_shifts(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An aggregate relationship"""
  employee_shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): employee_shifts_aggregate!
  end_time: time!
  id: uuid!
  name: String!
  start_time: time!
}

"""
aggregated selection of "shifts"
"""
type shifts_aggregate {
  aggregate: shifts_aggregate_fields
  nodes: [shifts!]!
}

"""
aggregate fields of "shifts"
"""
type shifts_aggregate_fields {
  count(columns: [shifts_select_column!], distinct: Boolean): Int!
  max: shifts_max_fields
  min: shifts_min_fields
}

"""
Boolean expression to filter rows from the table "shifts". All fields are combined with a logical 'AND'.
"""
input shifts_bool_exp {
  _and: [shifts_bool_exp!]
  _not: shifts_bool_exp
  _or: [shifts_bool_exp!]
  attendance_news: attendance_new_bool_exp
  attendance_news_aggregate: attendance_new_aggregate_bool_exp
  attendances: attendance_bool_exp
  attendances_aggregate: attendance_aggregate_bool_exp
  employee_shifts: employee_shifts_bool_exp
  employee_shifts_aggregate: employee_shifts_aggregate_bool_exp
  end_time: time_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  start_time: time_comparison_exp
}

"""
unique or primary key constraints on table "shifts"
"""
enum shifts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shifts_pkey
}

"""
input type for inserting data into table "shifts"
"""
input shifts_insert_input {
  attendance_news: attendance_new_arr_rel_insert_input
  attendances: attendance_arr_rel_insert_input
  employee_shifts: employee_shifts_arr_rel_insert_input
  end_time: time
  id: uuid
  name: String
  start_time: time
}

"""aggregate max on columns"""
type shifts_max_fields {
  id: uuid
  name: String
}

"""aggregate min on columns"""
type shifts_min_fields {
  id: uuid
  name: String
}

"""
response of any mutation on the table "shifts"
"""
type shifts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shifts!]!
}

"""
input type for inserting object relation for remote table "shifts"
"""
input shifts_obj_rel_insert_input {
  data: shifts_insert_input!

  """upsert condition"""
  on_conflict: shifts_on_conflict
}

"""
on_conflict condition type for table "shifts"
"""
input shifts_on_conflict {
  constraint: shifts_constraint!
  update_columns: [shifts_update_column!]! = []
  where: shifts_bool_exp
}

"""Ordering options when selecting data from "shifts"."""
input shifts_order_by {
  attendance_news_aggregate: attendance_new_aggregate_order_by
  attendances_aggregate: attendance_aggregate_order_by
  employee_shifts_aggregate: employee_shifts_aggregate_order_by
  end_time: order_by
  id: order_by
  name: order_by
  start_time: order_by
}

"""primary key columns input for table: shifts"""
input shifts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "shifts"
"""
enum shifts_select_column {
  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  name

  """column name"""
  start_time
}

"""
input type for updating data in table "shifts"
"""
input shifts_set_input {
  end_time: time
  id: uuid
  name: String
  start_time: time
}

"""
Streaming cursor of the table "shifts"
"""
input shifts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shifts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shifts_stream_cursor_value_input {
  end_time: time
  id: uuid
  name: String
  start_time: time
}

"""
update columns of table "shifts"
"""
enum shifts_update_column {
  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  name

  """column name"""
  start_time
}

input shifts_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: shifts_set_input

  """filter the rows which have to be updated"""
  where: shifts_bool_exp!
}

"""
columns and relationships of "spatial_ref_sys"
"""
type spatial_ref_sys {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int!
  srtext: String
}

"""
aggregated selection of "spatial_ref_sys"
"""
type spatial_ref_sys_aggregate {
  aggregate: spatial_ref_sys_aggregate_fields
  nodes: [spatial_ref_sys!]!
}

"""
aggregate fields of "spatial_ref_sys"
"""
type spatial_ref_sys_aggregate_fields {
  avg: spatial_ref_sys_avg_fields
  count(columns: [spatial_ref_sys_select_column!], distinct: Boolean): Int!
  max: spatial_ref_sys_max_fields
  min: spatial_ref_sys_min_fields
  stddev: spatial_ref_sys_stddev_fields
  stddev_pop: spatial_ref_sys_stddev_pop_fields
  stddev_samp: spatial_ref_sys_stddev_samp_fields
  sum: spatial_ref_sys_sum_fields
  var_pop: spatial_ref_sys_var_pop_fields
  var_samp: spatial_ref_sys_var_samp_fields
  variance: spatial_ref_sys_variance_fields
}

"""aggregate avg on columns"""
type spatial_ref_sys_avg_fields {
  auth_srid: Float
  srid: Float
}

"""
Boolean expression to filter rows from the table "spatial_ref_sys". All fields are combined with a logical 'AND'.
"""
input spatial_ref_sys_bool_exp {
  _and: [spatial_ref_sys_bool_exp!]
  _not: spatial_ref_sys_bool_exp
  _or: [spatial_ref_sys_bool_exp!]
  auth_name: String_comparison_exp
  auth_srid: Int_comparison_exp
  proj4text: String_comparison_exp
  srid: Int_comparison_exp
  srtext: String_comparison_exp
}

"""
unique or primary key constraints on table "spatial_ref_sys"
"""
enum spatial_ref_sys_constraint {
  """
  unique or primary key constraint on columns "srid"
  """
  spatial_ref_sys_pkey
}

"""
input type for incrementing numeric columns in table "spatial_ref_sys"
"""
input spatial_ref_sys_inc_input {
  auth_srid: Int
  srid: Int
}

"""
input type for inserting data into table "spatial_ref_sys"
"""
input spatial_ref_sys_insert_input {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""aggregate max on columns"""
type spatial_ref_sys_max_fields {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""aggregate min on columns"""
type spatial_ref_sys_min_fields {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""
response of any mutation on the table "spatial_ref_sys"
"""
type spatial_ref_sys_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [spatial_ref_sys!]!
}

"""
on_conflict condition type for table "spatial_ref_sys"
"""
input spatial_ref_sys_on_conflict {
  constraint: spatial_ref_sys_constraint!
  update_columns: [spatial_ref_sys_update_column!]! = []
  where: spatial_ref_sys_bool_exp
}

"""Ordering options when selecting data from "spatial_ref_sys"."""
input spatial_ref_sys_order_by {
  auth_name: order_by
  auth_srid: order_by
  proj4text: order_by
  srid: order_by
  srtext: order_by
}

"""primary key columns input for table: spatial_ref_sys"""
input spatial_ref_sys_pk_columns_input {
  srid: Int!
}

"""
select columns of table "spatial_ref_sys"
"""
enum spatial_ref_sys_select_column {
  """column name"""
  auth_name

  """column name"""
  auth_srid

  """column name"""
  proj4text

  """column name"""
  srid

  """column name"""
  srtext
}

"""
input type for updating data in table "spatial_ref_sys"
"""
input spatial_ref_sys_set_input {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""aggregate stddev on columns"""
type spatial_ref_sys_stddev_fields {
  auth_srid: Float
  srid: Float
}

"""aggregate stddev_pop on columns"""
type spatial_ref_sys_stddev_pop_fields {
  auth_srid: Float
  srid: Float
}

"""aggregate stddev_samp on columns"""
type spatial_ref_sys_stddev_samp_fields {
  auth_srid: Float
  srid: Float
}

"""
Streaming cursor of the table "spatial_ref_sys"
"""
input spatial_ref_sys_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: spatial_ref_sys_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input spatial_ref_sys_stream_cursor_value_input {
  auth_name: String
  auth_srid: Int
  proj4text: String
  srid: Int
  srtext: String
}

"""aggregate sum on columns"""
type spatial_ref_sys_sum_fields {
  auth_srid: Int
  srid: Int
}

"""
update columns of table "spatial_ref_sys"
"""
enum spatial_ref_sys_update_column {
  """column name"""
  auth_name

  """column name"""
  auth_srid

  """column name"""
  proj4text

  """column name"""
  srid

  """column name"""
  srtext
}

input spatial_ref_sys_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: spatial_ref_sys_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: spatial_ref_sys_set_input

  """filter the rows which have to be updated"""
  where: spatial_ref_sys_bool_exp!
}

"""aggregate var_pop on columns"""
type spatial_ref_sys_var_pop_fields {
  auth_srid: Float
  srid: Float
}

"""aggregate var_samp on columns"""
type spatial_ref_sys_var_samp_fields {
  auth_srid: Float
  srid: Float
}

"""aggregate variance on columns"""
type spatial_ref_sys_variance_fields {
  auth_srid: Float
  srid: Float
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"""
columns and relationships of "status"
"""
type status {
  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  status: String!
}

"""
aggregated selection of "status"
"""
type status_aggregate {
  aggregate: status_aggregate_fields
  nodes: [status!]!
}

"""
aggregate fields of "status"
"""
type status_aggregate_fields {
  count(columns: [status_select_column!], distinct: Boolean): Int!
  max: status_max_fields
  min: status_min_fields
}

"""
Boolean expression to filter rows from the table "status". All fields are combined with a logical 'AND'.
"""
input status_bool_exp {
  _and: [status_bool_exp!]
  _not: status_bool_exp
  _or: [status_bool_exp!]
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  employees: employees_bool_exp
  employees_aggregate: employees_aggregate_bool_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "status"
"""
enum status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  status_pkey
}

enum status_enum {
  ACTIVE
  INACTIVE
}

"""
Boolean expression to compare columns of type "status_enum". All fields are combined with logical 'AND'.
"""
input status_enum_comparison_exp {
  _eq: status_enum
  _in: [status_enum!]
  _is_null: Boolean
  _neq: status_enum
  _nin: [status_enum!]
}

"""
input type for inserting data into table "status"
"""
input status_insert_input {
  departments: departments_arr_rel_insert_input
  employees: employees_arr_rel_insert_input
  services: services_arr_rel_insert_input
  status: String
}

"""aggregate max on columns"""
type status_max_fields {
  status: String
}

"""aggregate min on columns"""
type status_min_fields {
  status: String
}

"""
response of any mutation on the table "status"
"""
type status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [status!]!
}

"""
input type for inserting object relation for remote table "status"
"""
input status_obj_rel_insert_input {
  data: status_insert_input!

  """upsert condition"""
  on_conflict: status_on_conflict
}

"""
on_conflict condition type for table "status"
"""
input status_on_conflict {
  constraint: status_constraint!
  update_columns: [status_update_column!]! = []
  where: status_bool_exp
}

"""Ordering options when selecting data from "status"."""
input status_order_by {
  departments_aggregate: departments_aggregate_order_by
  employees_aggregate: employees_aggregate_order_by
  services_aggregate: services_aggregate_order_by
  status: order_by
}

"""primary key columns input for table: status"""
input status_pk_columns_input {
  status: String!
}

"""
select columns of table "status"
"""
enum status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "status"
"""
input status_set_input {
  status: String
}

"""
Streaming cursor of the table "status"
"""
input status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "status"
"""
enum status_update_column {
  """column name"""
  status
}

input status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: status_set_input

  """filter the rows which have to be updated"""
  where: status_bool_exp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """An array relationship"""
  agencies(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An aggregate relationship"""
  agencies_aggregate(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): agencies_aggregate!

  """fetch data from the table: "agencies" using primary key columns"""
  agencies_by_pk(id: uuid!): agencies

  """
  fetch data from the table in a streaming manner: "agencies"
  """
  agencies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [agencies_stream_cursor_input]!

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """
  fetch data from the table: "alembic_version"
  """
  alembic_version(
    """distinct select on columns"""
    distinct_on: [alembic_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alembic_version_order_by!]

    """filter the rows returned"""
    where: alembic_version_bool_exp
  ): [alembic_version!]!

  """
  fetch aggregated fields from the table: "alembic_version"
  """
  alembic_version_aggregate(
    """distinct select on columns"""
    distinct_on: [alembic_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [alembic_version_order_by!]

    """filter the rows returned"""
    where: alembic_version_bool_exp
  ): alembic_version_aggregate!

  """fetch data from the table: "alembic_version" using primary key columns"""
  alembic_version_by_pk(version_num: String!): alembic_version

  """
  fetch data from the table in a streaming manner: "alembic_version"
  """
  alembic_version_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [alembic_version_stream_cursor_input]!

    """filter the rows returned"""
    where: alembic_version_bool_exp
  ): [alembic_version!]!

  """
  fetch data from the table: "app_versions"
  """
  app_versions(
    """distinct select on columns"""
    distinct_on: [app_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_versions_order_by!]

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): [app_versions!]!

  """
  fetch aggregated fields from the table: "app_versions"
  """
  app_versions_aggregate(
    """distinct select on columns"""
    distinct_on: [app_versions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_versions_order_by!]

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): app_versions_aggregate!

  """fetch data from the table: "app_versions" using primary key columns"""
  app_versions_by_pk(version: String!): app_versions

  """
  fetch data from the table in a streaming manner: "app_versions"
  """
  app_versions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [app_versions_stream_cursor_input]!

    """filter the rows returned"""
    where: app_versions_bool_exp
  ): [app_versions!]!

  """
  fetch data from the table: "appointment_status"
  """
  appointment_status(
    """distinct select on columns"""
    distinct_on: [appointment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_status_order_by!]

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): [appointment_status!]!

  """
  fetch aggregated fields from the table: "appointment_status"
  """
  appointment_status_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_status_order_by!]

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): appointment_status_aggregate!

  """
  fetch data from the table: "appointment_status" using primary key columns
  """
  appointment_status_by_pk(status: String!): appointment_status

  """
  fetch data from the table in a streaming manner: "appointment_status"
  """
  appointment_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [appointment_status_stream_cursor_input]!

    """filter the rows returned"""
    where: appointment_status_bool_exp
  ): [appointment_status!]!

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!

  """fetch data from the table: "appointments" using primary key columns"""
  appointments_by_pk(id: uuid!): appointments

  """
  fetch data from the table in a streaming manner: "appointments"
  """
  appointments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [appointments_stream_cursor_input]!

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """
  fetch data from the table: "attendance"
  """
  attendance(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """
  fetch aggregated fields from the table: "attendance"
  """
  attendance_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_order_by!]

    """filter the rows returned"""
    where: attendance_bool_exp
  ): attendance_aggregate!

  """fetch data from the table: "attendance" using primary key columns"""
  attendance_by_pk(id: uuid!): attendance

  """
  fetch data from the table: "attendance_new"
  """
  attendance_new(
    """distinct select on columns"""
    distinct_on: [attendance_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_new_order_by!]

    """filter the rows returned"""
    where: attendance_new_bool_exp
  ): [attendance_new!]!

  """
  fetch aggregated fields from the table: "attendance_new"
  """
  attendance_new_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_new_order_by!]

    """filter the rows returned"""
    where: attendance_new_bool_exp
  ): attendance_new_aggregate!

  """fetch data from the table: "attendance_new" using primary key columns"""
  attendance_new_by_pk(id: uuid!): attendance_new

  """
  fetch data from the table in a streaming manner: "attendance_new"
  """
  attendance_new_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attendance_new_stream_cursor_input]!

    """filter the rows returned"""
    where: attendance_new_bool_exp
  ): [attendance_new!]!

  """
  fetch data from the table: "attendance_state"
  """
  attendance_state(
    """distinct select on columns"""
    distinct_on: [attendance_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_state_order_by!]

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): [attendance_state!]!

  """
  fetch aggregated fields from the table: "attendance_state"
  """
  attendance_state_aggregate(
    """distinct select on columns"""
    distinct_on: [attendance_state_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_state_order_by!]

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): attendance_state_aggregate!

  """
  fetch data from the table: "attendance_state" using primary key columns
  """
  attendance_state_by_pk(id: uuid!): attendance_state

  """
  fetch data from the table in a streaming manner: "attendance_state"
  """
  attendance_state_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attendance_state_stream_cursor_input]!

    """filter the rows returned"""
    where: attendance_state_bool_exp
  ): [attendance_state!]!

  """
  fetch data from the table in a streaming manner: "attendance"
  """
  attendance_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attendance_stream_cursor_input]!

    """filter the rows returned"""
    where: attendance_bool_exp
  ): [attendance!]!

  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An aggregate relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!

  """fetch data from the table: "companies" using primary key columns"""
  companies_by_pk(id: uuid!): companies

  """
  fetch data from the table in a streaming manner: "companies"
  """
  companies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [companies_stream_cursor_input]!

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An array relationship"""
  company_settings(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): [company_settings!]!

  """An aggregate relationship"""
  company_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [company_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_settings_order_by!]

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): company_settings_aggregate!

  """
  fetch data from the table: "company_settings" using primary key columns
  """
  company_settings_by_pk(id: uuid!): company_settings

  """
  fetch data from the table in a streaming manner: "company_settings"
  """
  company_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [company_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: company_settings_bool_exp
  ): [company_settings!]!

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!

  """fetch data from the table: "departments" using primary key columns"""
  departments_by_pk(id: uuid!): departments

  """
  fetch data from the table in a streaming manner: "departments"
  """
  departments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [departments_stream_cursor_input]!

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An array relationship"""
  employee_notifications(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An aggregate relationship"""
  employee_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_notifications_order_by!]

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): employee_notifications_aggregate!

  """
  fetch data from the table: "employee_notifications" using primary key columns
  """
  employee_notifications_by_pk(id: uuid!): employee_notifications

  """
  fetch data from the table in a streaming manner: "employee_notifications"
  """
  employee_notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employee_notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: employee_notifications_bool_exp
  ): [employee_notifications!]!

  """An array relationship"""
  employee_roles(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An aggregate relationship"""
  employee_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_roles_order_by!]

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): employee_roles_aggregate!

  """fetch data from the table: "employee_roles" using primary key columns"""
  employee_roles_by_pk(id: uuid!): employee_roles

  """
  fetch data from the table in a streaming manner: "employee_roles"
  """
  employee_roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employee_roles_stream_cursor_input]!

    """filter the rows returned"""
    where: employee_roles_bool_exp
  ): [employee_roles!]!

  """An array relationship"""
  employee_shifts(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An aggregate relationship"""
  employee_shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [employee_shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employee_shifts_order_by!]

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): employee_shifts_aggregate!

  """fetch data from the table: "employee_shifts" using primary key columns"""
  employee_shifts_by_pk(id: uuid!): employee_shifts

  """
  fetch data from the table in a streaming manner: "employee_shifts"
  """
  employee_shifts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employee_shifts_stream_cursor_input]!

    """filter the rows returned"""
    where: employee_shifts_bool_exp
  ): [employee_shifts!]!

  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregate relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """fetch data from the table: "employees" using primary key columns"""
  employees_by_pk(id: uuid!): employees

  """
  fetch data from the table in a streaming manner: "employees"
  """
  employees_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employees_stream_cursor_input]!

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """
  fetch data from the table: "files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "files"
  """
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """fetch data from the table: "files" using primary key columns"""
  files_by_pk(id: uuid!): files

  """
  fetch data from the table in a streaming manner: "files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "gender"
  """
  gender(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch aggregated fields from the table: "gender"
  """
  gender_aggregate(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): gender_aggregate!

  """fetch data from the table: "gender" using primary key columns"""
  gender_by_pk(gender: String!): gender

  """
  fetch data from the table in a streaming manner: "gender"
  """
  gender_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [gender_stream_cursor_input]!

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch data from the table: "geography_columns"
  """
  geography_columns(
    """distinct select on columns"""
    distinct_on: [geography_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geography_columns_order_by!]

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): [geography_columns!]!

  """
  fetch aggregated fields from the table: "geography_columns"
  """
  geography_columns_aggregate(
    """distinct select on columns"""
    distinct_on: [geography_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geography_columns_order_by!]

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): geography_columns_aggregate!

  """
  fetch data from the table in a streaming manner: "geography_columns"
  """
  geography_columns_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [geography_columns_stream_cursor_input]!

    """filter the rows returned"""
    where: geography_columns_bool_exp
  ): [geography_columns!]!

  """
  fetch data from the table: "geometry_columns"
  """
  geometry_columns(
    """distinct select on columns"""
    distinct_on: [geometry_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geometry_columns_order_by!]

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): [geometry_columns!]!

  """
  fetch aggregated fields from the table: "geometry_columns"
  """
  geometry_columns_aggregate(
    """distinct select on columns"""
    distinct_on: [geometry_columns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geometry_columns_order_by!]

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): geometry_columns_aggregate!

  """
  fetch data from the table in a streaming manner: "geometry_columns"
  """
  geometry_columns_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [geometry_columns_stream_cursor_input]!

    """filter the rows returned"""
    where: geometry_columns_bool_exp
  ): [geometry_columns!]!
  get_attenance_monthly(
    """distinct select on columns"""
    distinct_on: [clock_in_count_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clock_in_count_order_by!]

    """filter the rows returned"""
    where: clock_in_count_bool_exp_bool_exp
  ): [clock_in_count!]!
  get_attenance_monthly_all_employee(
    """get_attenance_monthly_all_employeeNative Query Arguments"""
    args: get_attenance_monthly_all_employee_arguments!

    """distinct select on columns"""
    distinct_on: [attendance_all_month_employee_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_all_month_employee_order_by!]

    """filter the rows returned"""
    where: attendance_all_month_employee_bool_exp_bool_exp
  ): [attendance_all_month_employee!]!
  get_attendance_weekly(
    """distinct select on columns"""
    distinct_on: [attendance_week_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attendance_week_order_by!]

    """filter the rows returned"""
    where: attendance_week_bool_exp_bool_exp
  ): [attendance_week!]!
  get_visit_percentage_difference(
    """distinct select on columns"""
    distinct_on: [percentage_count_visit_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [percentage_count_visit_order_by!]

    """filter the rows returned"""
    where: percentage_count_visit_bool_exp_bool_exp
  ): [percentage_count_visit!]!
  get_visits_stat(
    """distinct select on columns"""
    distinct_on: [get_visitor_stat_enum_name!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [get_visitor_stat_order_by!]

    """filter the rows returned"""
    where: get_visitor_stat_bool_exp_bool_exp
  ): [get_visitor_stat!]!

  """
  fetch data from the table: "leave_approval"
  """
  leave_approval(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """
  fetch aggregated fields from the table: "leave_approval"
  """
  leave_approval_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_approval_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_approval_order_by!]

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): leave_approval_aggregate!

  """fetch data from the table: "leave_approval" using primary key columns"""
  leave_approval_by_pk(id: uuid!): leave_approval

  """
  fetch data from the table in a streaming manner: "leave_approval"
  """
  leave_approval_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_approval_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_approval_bool_exp
  ): [leave_approval!]!

  """
  fetch data from the table: "leave_status"
  """
  leave_status(
    """distinct select on columns"""
    distinct_on: [leave_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_status_order_by!]

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): [leave_status!]!

  """
  fetch aggregated fields from the table: "leave_status"
  """
  leave_status_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_status_order_by!]

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): leave_status_aggregate!

  """fetch data from the table: "leave_status" using primary key columns"""
  leave_status_by_pk(status: String!): leave_status

  """
  fetch data from the table in a streaming manner: "leave_status"
  """
  leave_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_status_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_status_bool_exp
  ): [leave_status!]!

  """
  fetch data from the table: "leave_type"
  """
  leave_type(
    """distinct select on columns"""
    distinct_on: [leave_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_type_order_by!]

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): [leave_type!]!

  """
  fetch aggregated fields from the table: "leave_type"
  """
  leave_type_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_type_order_by!]

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): leave_type_aggregate!

  """fetch data from the table: "leave_type" using primary key columns"""
  leave_type_by_pk(type: String!): leave_type

  """
  fetch data from the table in a streaming manner: "leave_type"
  """
  leave_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_type_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_type_bool_exp
  ): [leave_type!]!

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leaves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leaves_order_by!]

    """filter the rows returned"""
    where: leaves_bool_exp
  ): leaves_aggregate!

  """fetch data from the table: "leaves" using primary key columns"""
  leaves_by_pk(id: uuid!): leaves

  """
  fetch data from the table in a streaming manner: "leaves"
  """
  leaves_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leaves_stream_cursor_input]!

    """filter the rows returned"""
    where: leaves_bool_exp
  ): [leaves!]!

  """
  fetch data from the table: "locations"
  """
  locations(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """
  fetch aggregated fields from the table: "locations"
  """
  locations_aggregate(
    """distinct select on columns"""
    distinct_on: [locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [locations_order_by!]

    """filter the rows returned"""
    where: locations_bool_exp
  ): locations_aggregate!

  """fetch data from the table: "locations" using primary key columns"""
  locations_by_pk(id: uuid!): locations

  """
  fetch data from the table in a streaming manner: "locations"
  """
  locations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [locations_stream_cursor_input]!

    """filter the rows returned"""
    where: locations_bool_exp
  ): [locations!]!

  """An array relationship"""
  positions(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """An aggregate relationship"""
  positions_aggregate(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): positions_aggregate!

  """fetch data from the table: "positions" using primary key columns"""
  positions_by_pk(id: uuid!): positions

  """
  fetch data from the table in a streaming manner: "positions"
  """
  positions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [positions_stream_cursor_input]!

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [roles_stream_cursor_input]!

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(id: uuid!): services

  """
  fetch data from the table in a streaming manner: "services"
  """
  services_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [services_stream_cursor_input]!

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """
  fetch data from the table: "shifts"
  """
  shifts(
    """distinct select on columns"""
    distinct_on: [shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shifts_order_by!]

    """filter the rows returned"""
    where: shifts_bool_exp
  ): [shifts!]!

  """
  fetch aggregated fields from the table: "shifts"
  """
  shifts_aggregate(
    """distinct select on columns"""
    distinct_on: [shifts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shifts_order_by!]

    """filter the rows returned"""
    where: shifts_bool_exp
  ): shifts_aggregate!

  """fetch data from the table: "shifts" using primary key columns"""
  shifts_by_pk(id: uuid!): shifts

  """
  fetch data from the table in a streaming manner: "shifts"
  """
  shifts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shifts_stream_cursor_input]!

    """filter the rows returned"""
    where: shifts_bool_exp
  ): [shifts!]!

  """
  fetch data from the table: "spatial_ref_sys"
  """
  spatial_ref_sys(
    """distinct select on columns"""
    distinct_on: [spatial_ref_sys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [spatial_ref_sys_order_by!]

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): [spatial_ref_sys!]!

  """
  fetch aggregated fields from the table: "spatial_ref_sys"
  """
  spatial_ref_sys_aggregate(
    """distinct select on columns"""
    distinct_on: [spatial_ref_sys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [spatial_ref_sys_order_by!]

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): spatial_ref_sys_aggregate!

  """fetch data from the table: "spatial_ref_sys" using primary key columns"""
  spatial_ref_sys_by_pk(srid: Int!): spatial_ref_sys

  """
  fetch data from the table in a streaming manner: "spatial_ref_sys"
  """
  spatial_ref_sys_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [spatial_ref_sys_stream_cursor_input]!

    """filter the rows returned"""
    where: spatial_ref_sys_bool_exp
  ): [spatial_ref_sys!]!

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(status: String!): status

  """
  fetch data from the table in a streaming manner: "status"
  """
  status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [status_stream_cursor_input]!

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch data from the table: "text_content"
  """
  text_content(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): [text_content!]!

  """
  fetch aggregated fields from the table: "text_content"
  """
  text_content_aggregate(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): text_content_aggregate!

  """fetch data from the table: "text_content" using primary key columns"""
  text_content_by_pk(id: uuid!): text_content

  """
  fetch data from the table in a streaming manner: "text_content"
  """
  text_content_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [text_content_stream_cursor_input]!

    """filter the rows returned"""
    where: text_content_bool_exp
  ): [text_content!]!

  """
  fetch data from the table: "translations"
  """
  translations(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): [translations!]!

  """
  fetch aggregated fields from the table: "translations"
  """
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): translations_aggregate!

  """fetch data from the table: "translations" using primary key columns"""
  translations_by_pk(id: uuid!): translations

  """
  fetch data from the table in a streaming manner: "translations"
  """
  translations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [translations_stream_cursor_input]!

    """filter the rows returned"""
    where: translations_bool_exp
  ): [translations!]!

  """
  fetch data from the table: "vehicles"
  """
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """
  fetch aggregated fields from the table: "vehicles"
  """
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!

  """fetch data from the table: "vehicles" using primary key columns"""
  vehicles_by_pk(id: uuid!): vehicles

  """
  fetch data from the table in a streaming manner: "vehicles"
  """
  vehicles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [vehicles_stream_cursor_input]!

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """
  fetch data from the table: "visit_status"
  """
  visit_status(
    """distinct select on columns"""
    distinct_on: [visit_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visit_status_order_by!]

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): [visit_status!]!

  """
  fetch aggregated fields from the table: "visit_status"
  """
  visit_status_aggregate(
    """distinct select on columns"""
    distinct_on: [visit_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visit_status_order_by!]

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): visit_status_aggregate!

  """fetch data from the table: "visit_status" using primary key columns"""
  visit_status_by_pk(status: String!): visit_status

  """
  fetch data from the table in a streaming manner: "visit_status"
  """
  visit_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [visit_status_stream_cursor_input]!

    """filter the rows returned"""
    where: visit_status_bool_exp
  ): [visit_status!]!

  """An array relationship"""
  visitors(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An aggregate relationship"""
  visitors_aggregate(
    """distinct select on columns"""
    distinct_on: [visitors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visitors_order_by!]

    """filter the rows returned"""
    where: visitors_bool_exp
  ): visitors_aggregate!

  """fetch data from the table: "visitors" using primary key columns"""
  visitors_by_pk(id: uuid!): visitors

  """
  fetch data from the table in a streaming manner: "visitors"
  """
  visitors_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [visitors_stream_cursor_input]!

    """filter the rows returned"""
    where: visitors_bool_exp
  ): [visitors!]!

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!

  """fetch data from the table: "visits" using primary key columns"""
  visits_by_pk(id: uuid!): visits

  """
  fetch data from the table in a streaming manner: "visits"
  """
  visits_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [visits_stream_cursor_input]!

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!
}

"""
columns and relationships of "text_content"
"""
type text_content {
  """An array relationship"""
  agencies(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): [agencies!]!

  """An aggregate relationship"""
  agencies_aggregate(
    """distinct select on columns"""
    distinct_on: [agencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agencies_order_by!]

    """filter the rows returned"""
    where: agencies_bool_exp
  ): agencies_aggregate!

  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """An aggregate relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!
  content: String!
  created_at: timestamptz

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): [departments!]!

  """An aggregate relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [departments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [departments_order_by!]

    """filter the rows returned"""
    where: departments_bool_exp
  ): departments_aggregate!
  id: uuid!

  """An array relationship"""
  positions(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): [positions!]!

  """An aggregate relationship"""
  positions_aggregate(
    """distinct select on columns"""
    distinct_on: [positions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [positions_order_by!]

    """filter the rows returned"""
    where: positions_bool_exp
  ): positions_aggregate!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """An object relationship"""
  translation: translations
  translations: uuid

  """An array relationship"""
  translationsByContent(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): [translations!]!

  """An aggregate relationship"""
  translationsByContent_aggregate(
    """distinct select on columns"""
    distinct_on: [translations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [translations_order_by!]

    """filter the rows returned"""
    where: translations_bool_exp
  ): translations_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "text_content"
"""
type text_content_aggregate {
  aggregate: text_content_aggregate_fields
  nodes: [text_content!]!
}

input text_content_aggregate_bool_exp {
  count: text_content_aggregate_bool_exp_count
}

input text_content_aggregate_bool_exp_count {
  arguments: [text_content_select_column!]
  distinct: Boolean
  filter: text_content_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "text_content"
"""
type text_content_aggregate_fields {
  count(columns: [text_content_select_column!], distinct: Boolean): Int!
  max: text_content_max_fields
  min: text_content_min_fields
}

"""
order by aggregate values of table "text_content"
"""
input text_content_aggregate_order_by {
  count: order_by
  max: text_content_max_order_by
  min: text_content_min_order_by
}

"""
input type for inserting array relation for remote table "text_content"
"""
input text_content_arr_rel_insert_input {
  data: [text_content_insert_input!]!

  """upsert condition"""
  on_conflict: text_content_on_conflict
}

"""
Boolean expression to filter rows from the table "text_content". All fields are combined with a logical 'AND'.
"""
input text_content_bool_exp {
  _and: [text_content_bool_exp!]
  _not: text_content_bool_exp
  _or: [text_content_bool_exp!]
  agencies: agencies_bool_exp
  agencies_aggregate: agencies_aggregate_bool_exp
  companies: companies_bool_exp
  companies_aggregate: companies_aggregate_bool_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  departments: departments_bool_exp
  departments_aggregate: departments_aggregate_bool_exp
  id: uuid_comparison_exp
  positions: positions_bool_exp
  positions_aggregate: positions_aggregate_bool_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  translation: translations_bool_exp
  translations: uuid_comparison_exp
  translationsByContent: translations_bool_exp
  translationsByContent_aggregate: translations_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "text_content"
"""
enum text_content_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  text_content_pkey
}

"""
input type for inserting data into table "text_content"
"""
input text_content_insert_input {
  agencies: agencies_arr_rel_insert_input
  companies: companies_arr_rel_insert_input
  content: String
  created_at: timestamptz
  departments: departments_arr_rel_insert_input
  id: uuid
  positions: positions_arr_rel_insert_input
  services: services_arr_rel_insert_input
  translation: translations_obj_rel_insert_input
  translations: uuid
  translationsByContent: translations_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type text_content_max_fields {
  content: String
  created_at: timestamptz
  id: uuid
  translations: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "text_content"
"""
input text_content_max_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  translations: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type text_content_min_fields {
  content: String
  created_at: timestamptz
  id: uuid
  translations: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "text_content"
"""
input text_content_min_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  translations: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "text_content"
"""
type text_content_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [text_content!]!
}

"""
input type for inserting object relation for remote table "text_content"
"""
input text_content_obj_rel_insert_input {
  data: text_content_insert_input!

  """upsert condition"""
  on_conflict: text_content_on_conflict
}

"""
on_conflict condition type for table "text_content"
"""
input text_content_on_conflict {
  constraint: text_content_constraint!
  update_columns: [text_content_update_column!]! = []
  where: text_content_bool_exp
}

"""Ordering options when selecting data from "text_content"."""
input text_content_order_by {
  agencies_aggregate: agencies_aggregate_order_by
  companies_aggregate: companies_aggregate_order_by
  content: order_by
  created_at: order_by
  departments_aggregate: departments_aggregate_order_by
  id: order_by
  positions_aggregate: positions_aggregate_order_by
  services_aggregate: services_aggregate_order_by
  translation: translations_order_by
  translations: order_by
  translationsByContent_aggregate: translations_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: text_content"""
input text_content_pk_columns_input {
  id: uuid!
}

"""
select columns of table "text_content"
"""
enum text_content_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  translations

  """column name"""
  updated_at
}

"""
input type for updating data in table "text_content"
"""
input text_content_set_input {
  content: String
  created_at: timestamptz
  id: uuid
  translations: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "text_content"
"""
input text_content_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: text_content_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input text_content_stream_cursor_value_input {
  content: String
  created_at: timestamptz
  id: uuid
  translations: uuid
  updated_at: timestamptz
}

"""
update columns of table "text_content"
"""
enum text_content_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  translations

  """column name"""
  updated_at
}

input text_content_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: text_content_set_input

  """filter the rows which have to be updated"""
  where: text_content_bool_exp!
}

scalar time

"""
Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'.
"""
input time_comparison_exp {
  _eq: time
  _gt: time
  _gte: time
  _in: [time!]
  _is_null: Boolean
  _lt: time
  _lte: time
  _neq: time
  _nin: [time!]
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "translations"
"""
type translations {
  content: uuid
  created_at: timestamptz
  id: uuid!
  language_iso_code: String

  """An object relationship"""
  text_content: text_content

  """An array relationship"""
  text_contents(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): [text_content!]!

  """An aggregate relationship"""
  text_contents_aggregate(
    """distinct select on columns"""
    distinct_on: [text_content_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [text_content_order_by!]

    """filter the rows returned"""
    where: text_content_bool_exp
  ): text_content_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "translations"
"""
type translations_aggregate {
  aggregate: translations_aggregate_fields
  nodes: [translations!]!
}

input translations_aggregate_bool_exp {
  count: translations_aggregate_bool_exp_count
}

input translations_aggregate_bool_exp_count {
  arguments: [translations_select_column!]
  distinct: Boolean
  filter: translations_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "translations"
"""
type translations_aggregate_fields {
  count(columns: [translations_select_column!], distinct: Boolean): Int!
  max: translations_max_fields
  min: translations_min_fields
}

"""
order by aggregate values of table "translations"
"""
input translations_aggregate_order_by {
  count: order_by
  max: translations_max_order_by
  min: translations_min_order_by
}

"""
input type for inserting array relation for remote table "translations"
"""
input translations_arr_rel_insert_input {
  data: [translations_insert_input!]!

  """upsert condition"""
  on_conflict: translations_on_conflict
}

"""
Boolean expression to filter rows from the table "translations". All fields are combined with a logical 'AND'.
"""
input translations_bool_exp {
  _and: [translations_bool_exp!]
  _not: translations_bool_exp
  _or: [translations_bool_exp!]
  content: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  language_iso_code: String_comparison_exp
  text_content: text_content_bool_exp
  text_contents: text_content_bool_exp
  text_contents_aggregate: text_content_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "translations"
"""
enum translations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  translations_pkey
}

"""
input type for inserting data into table "translations"
"""
input translations_insert_input {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  text_content: text_content_obj_rel_insert_input
  text_contents: text_content_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type translations_max_fields {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "translations"
"""
input translations_max_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  language_iso_code: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type translations_min_fields {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "translations"
"""
input translations_min_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  language_iso_code: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "translations"
"""
type translations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [translations!]!
}

"""
input type for inserting object relation for remote table "translations"
"""
input translations_obj_rel_insert_input {
  data: translations_insert_input!

  """upsert condition"""
  on_conflict: translations_on_conflict
}

"""
on_conflict condition type for table "translations"
"""
input translations_on_conflict {
  constraint: translations_constraint!
  update_columns: [translations_update_column!]! = []
  where: translations_bool_exp
}

"""Ordering options when selecting data from "translations"."""
input translations_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  language_iso_code: order_by
  text_content: text_content_order_by
  text_contents_aggregate: text_content_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: translations"""
input translations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "translations"
"""
enum translations_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  language_iso_code

  """column name"""
  updated_at
}

"""
input type for updating data in table "translations"
"""
input translations_set_input {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "translations"
"""
input translations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: translations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input translations_stream_cursor_value_input {
  content: uuid
  created_at: timestamptz
  id: uuid
  language_iso_code: String
  updated_at: timestamptz
}

"""
update columns of table "translations"
"""
enum translations_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  language_iso_code

  """column name"""
  updated_at
}

input translations_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: translations_set_input

  """filter the rows which have to be updated"""
  where: translations_bool_exp!
}

input UpdateEmployeeInput {
  address: String = null
  firstname: String = null
  id: UUID!
  lastname: String = null
  phoneNumber: String = null
}

input UpdatePasswordInputType {
  currentPassword: String!
  newPassword: String!
  phoneNumber: String!
}

type UpdatePasswordOutputType {
  success: String!
}

scalar uuid

scalar UUID

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "vehicles"
"""
type vehicles {
  color: String
  created_at: timestamptz
  id: uuid!
  license: String
  make: String
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "vehicles"
"""
type vehicles_aggregate {
  aggregate: vehicles_aggregate_fields
  nodes: [vehicles!]!
}

"""
aggregate fields of "vehicles"
"""
type vehicles_aggregate_fields {
  count(columns: [vehicles_select_column!], distinct: Boolean): Int!
  max: vehicles_max_fields
  min: vehicles_min_fields
}

"""
Boolean expression to filter rows from the table "vehicles". All fields are combined with a logical 'AND'.
"""
input vehicles_bool_exp {
  _and: [vehicles_bool_exp!]
  _not: vehicles_bool_exp
  _or: [vehicles_bool_exp!]
  color: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  license: String_comparison_exp
  make: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "vehicles"
"""
enum vehicles_constraint {
  """
  unique or primary key constraint on columns "license"
  """
  vehicles_license_key

  """
  unique or primary key constraint on columns "id"
  """
  vehicles_pkey
}

"""
input type for inserting data into table "vehicles"
"""
input vehicles_insert_input {
  color: String
  created_at: timestamptz
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type vehicles_max_fields {
  color: String
  created_at: timestamptz
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type vehicles_min_fields {
  color: String
  created_at: timestamptz
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "vehicles"
"""
type vehicles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [vehicles!]!
}

"""
input type for inserting object relation for remote table "vehicles"
"""
input vehicles_obj_rel_insert_input {
  data: vehicles_insert_input!

  """upsert condition"""
  on_conflict: vehicles_on_conflict
}

"""
on_conflict condition type for table "vehicles"
"""
input vehicles_on_conflict {
  constraint: vehicles_constraint!
  update_columns: [vehicles_update_column!]! = []
  where: vehicles_bool_exp
}

"""Ordering options when selecting data from "vehicles"."""
input vehicles_order_by {
  color: order_by
  created_at: order_by
  id: order_by
  license: order_by
  make: order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: vehicles"""
input vehicles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "vehicles"
"""
enum vehicles_select_column {
  """column name"""
  color

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  license

  """column name"""
  make

  """column name"""
  updated_at
}

"""
input type for updating data in table "vehicles"
"""
input vehicles_set_input {
  color: String
  created_at: timestamptz
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "vehicles"
"""
input vehicles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: vehicles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input vehicles_stream_cursor_value_input {
  color: String
  created_at: timestamptz
  id: uuid
  license: String
  make: String
  updated_at: timestamptz
}

"""
update columns of table "vehicles"
"""
enum vehicles_update_column {
  """column name"""
  color

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  license

  """column name"""
  make

  """column name"""
  updated_at
}

input vehicles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: vehicles_set_input

  """filter the rows which have to be updated"""
  where: vehicles_bool_exp!
}

"""
columns and relationships of "visit_status"
"""
type visit_status {
  status: String!

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "visit_status"
"""
type visit_status_aggregate {
  aggregate: visit_status_aggregate_fields
  nodes: [visit_status!]!
}

"""
aggregate fields of "visit_status"
"""
type visit_status_aggregate_fields {
  count(columns: [visit_status_select_column!], distinct: Boolean): Int!
  max: visit_status_max_fields
  min: visit_status_min_fields
}

"""
Boolean expression to filter rows from the table "visit_status". All fields are combined with a logical 'AND'.
"""
input visit_status_bool_exp {
  _and: [visit_status_bool_exp!]
  _not: visit_status_bool_exp
  _or: [visit_status_bool_exp!]
  status: String_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "visit_status"
"""
enum visit_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  visit_status_pkey
}

enum visit_status_enum {
  ACCEPTED
  PENDING
  REJECTED
}

"""
Boolean expression to compare columns of type "visit_status_enum". All fields are combined with logical 'AND'.
"""
input visit_status_enum_comparison_exp {
  _eq: visit_status_enum
  _in: [visit_status_enum!]
  _is_null: Boolean
  _neq: visit_status_enum
  _nin: [visit_status_enum!]
}

"""
input type for inserting data into table "visit_status"
"""
input visit_status_insert_input {
  status: String
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type visit_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type visit_status_min_fields {
  status: String
}

"""
response of any mutation on the table "visit_status"
"""
type visit_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [visit_status!]!
}

"""
input type for inserting object relation for remote table "visit_status"
"""
input visit_status_obj_rel_insert_input {
  data: visit_status_insert_input!

  """upsert condition"""
  on_conflict: visit_status_on_conflict
}

"""
on_conflict condition type for table "visit_status"
"""
input visit_status_on_conflict {
  constraint: visit_status_constraint!
  update_columns: [visit_status_update_column!]! = []
  where: visit_status_bool_exp
}

"""Ordering options when selecting data from "visit_status"."""
input visit_status_order_by {
  status: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: visit_status"""
input visit_status_pk_columns_input {
  status: String!
}

"""
select columns of table "visit_status"
"""
enum visit_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "visit_status"
"""
input visit_status_set_input {
  status: String
}

"""
Streaming cursor of the table "visit_status"
"""
input visit_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: visit_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input visit_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "visit_status"
"""
enum visit_status_update_column {
  """column name"""
  status
}

input visit_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: visit_status_set_input

  """filter the rows which have to be updated"""
  where: visit_status_bool_exp!
}

"""
columns and relationships of "visitors"
"""
type visitors {
  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): [appointments!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointments_order_by!]

    """filter the rows returned"""
    where: appointments_bool_exp
  ): appointments_aggregate!
  back_id: uuid

  """An object relationship"""
  company: companies
  company_id: uuid
  created_at: timestamptz

  """An object relationship"""
  file: files

  """An object relationship"""
  fileByBackId: files

  """An object relationship"""
  fileByFrontId: files
  firstname: String!
  front_id: uuid
  gender: gender_enum

  """An object relationship"""
  genderByGender: gender
  id: uuid!
  id_number: String!
  lastname: String
  phone_number: String!
  photo: uuid
  updated_at: timestamptz

  """An array relationship"""
  visits(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): [visits!]!

  """An aggregate relationship"""
  visits_aggregate(
    """distinct select on columns"""
    distinct_on: [visits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [visits_order_by!]

    """filter the rows returned"""
    where: visits_bool_exp
  ): visits_aggregate!
}

"""
aggregated selection of "visitors"
"""
type visitors_aggregate {
  aggregate: visitors_aggregate_fields
  nodes: [visitors!]!
}

input visitors_aggregate_bool_exp {
  count: visitors_aggregate_bool_exp_count
}

input visitors_aggregate_bool_exp_count {
  arguments: [visitors_select_column!]
  distinct: Boolean
  filter: visitors_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "visitors"
"""
type visitors_aggregate_fields {
  count(columns: [visitors_select_column!], distinct: Boolean): Int!
  max: visitors_max_fields
  min: visitors_min_fields
}

"""
order by aggregate values of table "visitors"
"""
input visitors_aggregate_order_by {
  count: order_by
  max: visitors_max_order_by
  min: visitors_min_order_by
}

"""
input type for inserting array relation for remote table "visitors"
"""
input visitors_arr_rel_insert_input {
  data: [visitors_insert_input!]!

  """upsert condition"""
  on_conflict: visitors_on_conflict
}

"""
Boolean expression to filter rows from the table "visitors". All fields are combined with a logical 'AND'.
"""
input visitors_bool_exp {
  _and: [visitors_bool_exp!]
  _not: visitors_bool_exp
  _or: [visitors_bool_exp!]
  appointments: appointments_bool_exp
  appointments_aggregate: appointments_aggregate_bool_exp
  back_id: uuid_comparison_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  file: files_bool_exp
  fileByBackId: files_bool_exp
  fileByFrontId: files_bool_exp
  firstname: String_comparison_exp
  front_id: uuid_comparison_exp
  gender: gender_enum_comparison_exp
  genderByGender: gender_bool_exp
  id: uuid_comparison_exp
  id_number: String_comparison_exp
  lastname: String_comparison_exp
  phone_number: String_comparison_exp
  photo: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  visits: visits_bool_exp
  visits_aggregate: visits_aggregate_bool_exp
}

"""
unique or primary key constraints on table "visitors"
"""
enum visitors_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  visitors_pkey
}

"""
input type for inserting data into table "visitors"
"""
input visitors_insert_input {
  appointments: appointments_arr_rel_insert_input
  back_id: uuid
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  file: files_obj_rel_insert_input
  fileByBackId: files_obj_rel_insert_input
  fileByFrontId: files_obj_rel_insert_input
  firstname: String
  front_id: uuid
  gender: gender_enum
  genderByGender: gender_obj_rel_insert_input
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
  visits: visits_arr_rel_insert_input
}

"""aggregate max on columns"""
type visitors_max_fields {
  back_id: uuid
  company_id: uuid
  created_at: timestamptz
  firstname: String
  front_id: uuid
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "visitors"
"""
input visitors_max_order_by {
  back_id: order_by
  company_id: order_by
  created_at: order_by
  firstname: order_by
  front_id: order_by
  id: order_by
  id_number: order_by
  lastname: order_by
  phone_number: order_by
  photo: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type visitors_min_fields {
  back_id: uuid
  company_id: uuid
  created_at: timestamptz
  firstname: String
  front_id: uuid
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "visitors"
"""
input visitors_min_order_by {
  back_id: order_by
  company_id: order_by
  created_at: order_by
  firstname: order_by
  front_id: order_by
  id: order_by
  id_number: order_by
  lastname: order_by
  phone_number: order_by
  photo: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "visitors"
"""
type visitors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [visitors!]!
}

"""
input type for inserting object relation for remote table "visitors"
"""
input visitors_obj_rel_insert_input {
  data: visitors_insert_input!

  """upsert condition"""
  on_conflict: visitors_on_conflict
}

"""
on_conflict condition type for table "visitors"
"""
input visitors_on_conflict {
  constraint: visitors_constraint!
  update_columns: [visitors_update_column!]! = []
  where: visitors_bool_exp
}

"""Ordering options when selecting data from "visitors"."""
input visitors_order_by {
  appointments_aggregate: appointments_aggregate_order_by
  back_id: order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  file: files_order_by
  fileByBackId: files_order_by
  fileByFrontId: files_order_by
  firstname: order_by
  front_id: order_by
  gender: order_by
  genderByGender: gender_order_by
  id: order_by
  id_number: order_by
  lastname: order_by
  phone_number: order_by
  photo: order_by
  updated_at: order_by
  visits_aggregate: visits_aggregate_order_by
}

"""primary key columns input for table: visitors"""
input visitors_pk_columns_input {
  id: uuid!
}

"""
select columns of table "visitors"
"""
enum visitors_select_column {
  """column name"""
  back_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  firstname

  """column name"""
  front_id

  """column name"""
  gender

  """column name"""
  id

  """column name"""
  id_number

  """column name"""
  lastname

  """column name"""
  phone_number

  """column name"""
  photo

  """column name"""
  updated_at
}

"""
input type for updating data in table "visitors"
"""
input visitors_set_input {
  back_id: uuid
  company_id: uuid
  created_at: timestamptz
  firstname: String
  front_id: uuid
  gender: gender_enum
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "visitors"
"""
input visitors_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: visitors_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input visitors_stream_cursor_value_input {
  back_id: uuid
  company_id: uuid
  created_at: timestamptz
  firstname: String
  front_id: uuid
  gender: gender_enum
  id: uuid
  id_number: String
  lastname: String
  phone_number: String
  photo: uuid
  updated_at: timestamptz
}

"""
update columns of table "visitors"
"""
enum visitors_update_column {
  """column name"""
  back_id

  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  firstname

  """column name"""
  front_id

  """column name"""
  gender

  """column name"""
  id

  """column name"""
  id_number

  """column name"""
  lastname

  """column name"""
  phone_number

  """column name"""
  photo

  """column name"""
  updated_at
}

input visitors_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: visitors_set_input

  """filter the rows which have to be updated"""
  where: visitors_bool_exp!
}

"""
columns and relationships of "visits"
"""
type visits {
  check_in_at: timestamptz
  check_out_at: timestamptz
  created_at: timestamptz
  date: date

  """An object relationship"""
  department: departments

  """An object relationship"""
  employee: employees
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid!
  reason: String
  reg_no: String

  """An object relationship"""
  service: services
  status: visit_status_enum
  updated_at: timestamptz
  vehicle: uuid

  """An object relationship"""
  vehicleByVehicle: vehicles

  """An object relationship"""
  visit_status: visit_status
  visitor: uuid

  """An object relationship"""
  visitorByVisitor: visitors
}

"""
aggregated selection of "visits"
"""
type visits_aggregate {
  aggregate: visits_aggregate_fields
  nodes: [visits!]!
}

input visits_aggregate_bool_exp {
  count: visits_aggregate_bool_exp_count
}

input visits_aggregate_bool_exp_count {
  arguments: [visits_select_column!]
  distinct: Boolean
  filter: visits_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "visits"
"""
type visits_aggregate_fields {
  count(columns: [visits_select_column!], distinct: Boolean): Int!
  max: visits_max_fields
  min: visits_min_fields
}

"""
order by aggregate values of table "visits"
"""
input visits_aggregate_order_by {
  count: order_by
  max: visits_max_order_by
  min: visits_min_order_by
}

"""
input type for inserting array relation for remote table "visits"
"""
input visits_arr_rel_insert_input {
  data: [visits_insert_input!]!

  """upsert condition"""
  on_conflict: visits_on_conflict
}

"""
Boolean expression to filter rows from the table "visits". All fields are combined with a logical 'AND'.
"""
input visits_bool_exp {
  _and: [visits_bool_exp!]
  _not: visits_bool_exp
  _or: [visits_bool_exp!]
  check_in_at: timestamptz_comparison_exp
  check_out_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  department: departments_bool_exp
  employee: employees_bool_exp
  host_department: uuid_comparison_exp
  host_employee: uuid_comparison_exp
  host_service: uuid_comparison_exp
  id: uuid_comparison_exp
  reason: String_comparison_exp
  reg_no: String_comparison_exp
  service: services_bool_exp
  status: visit_status_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  vehicle: uuid_comparison_exp
  vehicleByVehicle: vehicles_bool_exp
  visit_status: visit_status_bool_exp
  visitor: uuid_comparison_exp
  visitorByVisitor: visitors_bool_exp
}

"""
unique or primary key constraints on table "visits"
"""
enum visits_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  visits_pkey
}

"""
input type for inserting data into table "visits"
"""
input visits_insert_input {
  check_in_at: timestamptz
  check_out_at: timestamptz
  created_at: timestamptz
  date: date
  department: departments_obj_rel_insert_input
  employee: employees_obj_rel_insert_input
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  service: services_obj_rel_insert_input
  status: visit_status_enum
  updated_at: timestamptz
  vehicle: uuid
  vehicleByVehicle: vehicles_obj_rel_insert_input
  visit_status: visit_status_obj_rel_insert_input
  visitor: uuid
  visitorByVisitor: visitors_obj_rel_insert_input
}

"""aggregate max on columns"""
type visits_max_fields {
  check_in_at: timestamptz
  check_out_at: timestamptz
  created_at: timestamptz
  date: date
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  updated_at: timestamptz
  vehicle: uuid
  visitor: uuid
}

"""
order by max() on columns of table "visits"
"""
input visits_max_order_by {
  check_in_at: order_by
  check_out_at: order_by
  created_at: order_by
  date: order_by
  host_department: order_by
  host_employee: order_by
  host_service: order_by
  id: order_by
  reason: order_by
  reg_no: order_by
  updated_at: order_by
  vehicle: order_by
  visitor: order_by
}

"""aggregate min on columns"""
type visits_min_fields {
  check_in_at: timestamptz
  check_out_at: timestamptz
  created_at: timestamptz
  date: date
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  updated_at: timestamptz
  vehicle: uuid
  visitor: uuid
}

"""
order by min() on columns of table "visits"
"""
input visits_min_order_by {
  check_in_at: order_by
  check_out_at: order_by
  created_at: order_by
  date: order_by
  host_department: order_by
  host_employee: order_by
  host_service: order_by
  id: order_by
  reason: order_by
  reg_no: order_by
  updated_at: order_by
  vehicle: order_by
  visitor: order_by
}

"""
response of any mutation on the table "visits"
"""
type visits_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [visits!]!
}

"""
on_conflict condition type for table "visits"
"""
input visits_on_conflict {
  constraint: visits_constraint!
  update_columns: [visits_update_column!]! = []
  where: visits_bool_exp
}

"""Ordering options when selecting data from "visits"."""
input visits_order_by {
  check_in_at: order_by
  check_out_at: order_by
  created_at: order_by
  date: order_by
  department: departments_order_by
  employee: employees_order_by
  host_department: order_by
  host_employee: order_by
  host_service: order_by
  id: order_by
  reason: order_by
  reg_no: order_by
  service: services_order_by
  status: order_by
  updated_at: order_by
  vehicle: order_by
  vehicleByVehicle: vehicles_order_by
  visit_status: visit_status_order_by
  visitor: order_by
  visitorByVisitor: visitors_order_by
}

"""primary key columns input for table: visits"""
input visits_pk_columns_input {
  id: uuid!
}

"""
select columns of table "visits"
"""
enum visits_select_column {
  """column name"""
  check_in_at

  """column name"""
  check_out_at

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  host_department

  """column name"""
  host_employee

  """column name"""
  host_service

  """column name"""
  id

  """column name"""
  reason

  """column name"""
  reg_no

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  vehicle

  """column name"""
  visitor
}

"""
input type for updating data in table "visits"
"""
input visits_set_input {
  check_in_at: timestamptz
  check_out_at: timestamptz
  created_at: timestamptz
  date: date
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  status: visit_status_enum
  updated_at: timestamptz
  vehicle: uuid
  visitor: uuid
}

"""
Streaming cursor of the table "visits"
"""
input visits_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: visits_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input visits_stream_cursor_value_input {
  check_in_at: timestamptz
  check_out_at: timestamptz
  created_at: timestamptz
  date: date
  host_department: uuid
  host_employee: uuid
  host_service: uuid
  id: uuid
  reason: String
  reg_no: String
  status: visit_status_enum
  updated_at: timestamptz
  vehicle: uuid
  visitor: uuid
}

"""
update columns of table "visits"
"""
enum visits_update_column {
  """column name"""
  check_in_at

  """column name"""
  check_out_at

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  host_department

  """column name"""
  host_employee

  """column name"""
  host_service

  """column name"""
  id

  """column name"""
  reason

  """column name"""
  reg_no

  """column name"""
  status

  """column name"""
  updated_at

  """column name"""
  vehicle

  """column name"""
  visitor
}

input visits_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: visits_set_input

  """filter the rows which have to be updated"""
  where: visits_bool_exp!
}

